#
#   Demo script file for setup bring

# python generic imports
import yaml
import logging
import argparse
import re
import time
from common_lib import utils
from common_lib.utils import *
import MyLib
from MyLib import my_utils
from MyLib import my_config_utils
from MyLib import my_trigger_utils
from MyLib import my_multisite_lib
from MyLib import my_cloudsec_lib

from pyats import aetest
from common_lib import config_bringup
import yaml
import logging
from pyats.topology import loader
import argparse
import json
import datetime
from datetime import datetime,timedelta
import unicon.statemachine.statemachine
import random

# pyATS imports


from common_lib import routing_utils
from common_lib.routing_utils import *

from unicon import Connection
from ats import aetest
from ats.log.utils import banner
from ats.datastructures.logic import Not, And, Or
from ats.easypy import run
from ats.log.utils import banner
from common_lib import bringup_lib
#import evpn_lib
from feature_lib.vxlan import vxlan_lib
from feature_lib.l3 import ospfv2_lib
from feature_lib.l3 import ospfv3_lib
from feature_lib.l3 import bgp_lib
from feature_lib.vxlan import evpn_lib
from common_lib import tcam_lib
from feature_lib.l3 import pim_lib
from feature_lib.l2 import vpc_lib
#import oam_lib
from pyats.async_ import pcall
from pyats.async_ import Pcall

import threading

#Ixia Libraries
from common_lib import ixia_lib_new
from common_lib.ixia_lib_new import *

# N39k Library imports
from common_lib import config_bringup
# import config_bringup_test
from common_lib import config_bringup_test_vijay
from common_lib import interface_lib
import ipaddress

from itertools import chain
from collections import OrderedDict
from itertools import permutations
import json
from bs4 import BeautifulSoup
from prettytable import PrettyTable
from _ast import alias


def MergeDict(dict1,dict2):
    return (dict2.update(dict1))


def expandTrafficItemList(a):
    skip_list = []
    pat = re.compile(r'([A-Za-z]+)(\d+)-[A-Za-z]+(\d+)', flags=re.I)
    if a:
        log.info(banner('The Value of a is : {0}'.format(a)))
        c = a.split(',')
        log.info(banner('The Value of c is : {0}'.format(c)))
        for items in c:
            b = pat.search(items)
            [skip_list.append(b.group(1) + str("{:03d}".format(i))) for i in range(int(b.group(2)), int(b.group(3))+1)]
            
    return skip_list

def countDownTimer(a):
    for i in range(a):
        log.info('seconds remaining is: {0}'.format(int(a-i)))
        time.sleep(1)
    return 1

def startStopIgmpReports(tg_hdl='',action=''):
    log.info('The value of tg_hdl is = %r', tg_hdl)
    log.info('The value of action  is = %r', action)
    igmp_status = tg_hdl.test_control(action = action)
    return(igmp_status)  

def returnIPFlag(v4_flag = '', v6_flag = ''):
    if v4_flag and v6_flag:
        return 1
    if v4_flag:
        return 2
    if v6_flag:
        return 3


def parseScaleTGParams(log,args):
    arggrammar = {}
    arggrammar['no_of_intf'] = '-type int'
    arggrammar['no_of_vlans'] = '-type int'
    arggrammar['vlan_start'] = '-type int'
    arggrammar['ip_addr_start'] = '-type str'
    arggrammar['netmask'] = '-type str'
    arggrammar['ip_addr_step'] = '-type str'
    arggrammar['ipv4_network_step'] = '-type str'
    arggrammar['gateway'] = '-type str'
    arggrammar['mode'] = '-type str'
    arggrammar['vlan'] = '-type int'
    arggrammar['ipv6_addr_start'] = '-type str'
    arggrammar['ipv6_prefix_length'] = '-type int'
    arggrammar['ipv6_intf_addr_step'] = '-type str'
    arggrammar['ipv6_network_step'] = '-type str'
    arggrammar['v6_gateway'] = '-type str'
    ns = parserutils_lib.argsToCommandOptions(args,arggrammar,log)
    return ns

def generateTrafficGenIntfConfigs(log,args):
    intf_list = []

    count = 1
    ns = parseScaleTGParams(log,args)
    log.info('the value of ns is : {0}'.format(ns))
    
    res = returnIPFlag(ns.ip_addr_start,ns.ipv6_addr_start)
    log.info('The value of res is: {0}'.format(res))
    
    no_of_intf_per_vlan = ns.no_of_intf / ns.no_of_vlans
    print('The value of no_of_intf_per_vlan is : {0}'.format(no_of_intf_per_vlan))
    ip_addr = ipaddress.IPv4Address(ns.ip_addr_start)
    if ns.ipv6_addr_start:
        ipv6_addr = ipaddress.IPv6Address(ns.ipv6_addr_start)
        gwv6 = ipaddress.IPv6Address(ns.v6_gateway)
    gw = ipaddress.IPv4Address(ns.gateway)
    v = ns.vlan_start
    ip_addr_step = '0.0.0.1'
    gw_addr_step = '0.0.0.0'
    v6_gw_addr_step = '0:0:0:0:0:0:0:0'
    vlan_step = 0
    
    if res == 1:
        for i in range(0,ns.no_of_intf):
            if(count <= int(no_of_intf_per_vlan)): 
                if(count == 1):
                    a = "".join('-mode {0} -connected_count {1} -intf_ip_addr {2} -intf_ip_addr_step {3} -netmask {4} \
                                -gateway {5} -gateway_step {6} -vlan {7} -vlan_id {8} -vlan_id_step {9} \
                                -ipv6_intf_addr {10} -ipv6_intf_addr_step {11} -ipv6_prefix_length {12} \
                                -ipv6_gateway {13} -ipv6_gateway_step {14}'.format(ns.mode,int(no_of_intf_per_vlan),ip_addr,ip_addr_step,ns.netmask,gw,gw_addr_step,ns.vlan,v,vlan_step,ipv6_addr,ns.ipv6_intf_addr_step,ns.ipv6_prefix_length,gwv6,v6_gw_addr_step))
                    intf_list.append(a)
                ip_addr = ipaddress.IPv4Address(ip_addr) + int(ipaddress.IPv4Address(ns.ip_addr_step))
                ipv6_addr = ipaddress.IPv6Address(ipv6_addr) + int(ipaddress.IPv6Address(ns.ipv6_intf_addr_step))
                count = count+1
            if(count > no_of_intf_per_vlan):
                ns.ip_addr_start = ipaddress.IPv4Address(ns.ip_addr_start)+int(ipaddress.IPv4Address(ns.ipv4_network_step))
                ns.ipv6_addr_start = ipaddress.IPv6Address(ns.ipv6_addr_start)+int(ipaddress.IPv6Address(ns.ipv6_network_step))
                ip_addr = ns.ip_addr_start
                ipv6_addr = ns.ipv6_addr_start
                gw = ipaddress.IPv4Address(gw) + int(ipaddress.IPv4Address(ns.ipv4_network_step))
                gwv6 = ipaddress.IPv6Address(gwv6) + int(ipaddress.IPv6Address(ns.ipv6_network_step))
                v = v + 1
                count = 1
        
    
    if res == 2:
        for i in range(0,ns.no_of_intf):
            if(count <= int(no_of_intf_per_vlan)): 
                if(count == 1):
                    a = "".join('-mode {0} -connected_count {1} -intf_ip_addr {2} -intf_ip_addr_step {3} -netmask {4} -gateway {5} -gateway_step {6} -vlan {7} -vlan_id {8} -vlan_id_step {9}'.format(ns.mode,int(no_of_intf_per_vlan),ip_addr,ip_addr_step,ns.netmask,gw,gw_addr_step,ns.vlan,v,vlan_step))
                    intf_list.append(a)
                ip_addr = ipaddress.IPv4Address(ip_addr) + int(ipaddress.IPv4Address(ns.ip_addr_step))
                count = count+1
            if(count > no_of_intf_per_vlan):
                ns.ip_addr_start = ipaddress.IPv4Address(ns.ip_addr_start)+int(ipaddress.IPv4Address(ns.ipv4_network_step))
                ip_addr = ns.ip_addr_start
                gw = ipaddress.IPv4Address(gw) + int(ipaddress.IPv4Address(ns.ipv4_network_step))
                v = v + 1
                count = 1
                
                
    if res == 3:
        for i in range(0,ns.no_of_intf):
            if(count <= int(no_of_intf_per_vlan)): 
                if(count == 1):
                    a = "".join('-mode {0} -connected_count {1} -ipv6_intf_addr {2} -ipv6_intf_addr_step {3} -ipv6_prefix_length {4} -ipv6_gateway {5} -vlan {6} -vlan_id {7} -vlan_id_step {8}'.format(ns.mode,int(no_of_intf_per_vlan),ipv6_addr,ipv6_addr_step,ns.ipv6_prefix_length,gwv6,v6_gw_addr_step,ns.vlan,v,vlan_step))
                    intf_list.append(a)
                ipv6_addr = ipaddress.IPv6Address(ipv6_addr) + int(ipaddress.IPv6Address(ns.ipv6_addr_step))
                count = count+1
            if(count > no_of_intf_per_vlan):
                ns.ipv6_addr_start = ipaddress.IPv6Address(ns.ipv6_addr_start)+int(ipaddress.IPv6Address(ns.ipv6_network_step))
                ipv6_addr = ns.ipv6_addr_start
                gwv6 = ipaddress.IPv6Address(gwv6) + int(ipaddress.IPv6Address(ns.ipv6_network_step))
                v = v + 1
                count = 1
        
    
    log.info('The value of interface_list is : {0}'.format(intf_list))
    return intf_list
            
        

def verifyProcessRestart(dut, p_name):
    
    log.info('Inside verifyProcessRestart .....')
#     unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
#     unicon_state.add_state_pattern(pattern_list = "r'bash-*$'")
    
    dut.configure("feature bash-shell")
    dut.configure('system no hap-reset')
    
    # Get the PID of the process before killing it
    pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    pid_regex = re.search("PID = (\\d+)",pid_data,re.I)
    if pid_regex is not 0:
        pid = pid_regex.group(1)
    
    # Kill the process in bash prompt
    dut.execute("run bash", allow_state_change = "True")
    dut.execute("sudo su", allow_state_change = "True")
    dut.execute("kill -9 "+str(pid), allow_state_change = "True")
    dut.execute("exit", allow_state_change = "True")
    dut.execute("exit", allow_state_change = "True")
    
#     unicon_state.restore_state_pattern()
#     unicon_state = ""
    
    countDownTimer(30)
    
    # Get the PID of the process after killing it
    post_kill_pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    post_kill_pid_regex = re.search("PID = (\\d+)",post_kill_pid_data,re.I)
    if post_kill_pid_regex is not 0:
        post_kill_pid = post_kill_pid_regex.group(1)
    
    # Check if pre-kill PID and post-kill PID are different
    if pid != post_kill_pid:
        return 1
    else:
        return 0

def verifyProcessRestartWithFlushRoutes(dut, p_name,**kwargs):
    
    log.info('Inside verifyProcessRestart wtih Flush Route .....')
#     unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
#     unicon_state.add_state_pattern(pattern_list = "r'bash-*$'")
    
    dut.configure("feature bash-shell")
    dut.configure('system no hap-reset')
    
    if kwargs:
        process_id = kwargs['process_id']
    # Get the PID of the process before restarting it
    pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    pid_regex = re.search("PID = (\\d+)",pid_data,re.I)
    if pid_regex is not 0:
        pid = pid_regex.group(1)
    
    if p_name == 'ospf' and kwargs:
        cfg = ''' router {0} {1}
                  flush-routes
              '''.format(p_name,process_id)
        dut.configure(cfg)
        dut.configure('restart {0} {1}'.format(p_name,process_id))
    if p_name == 'igmp':
        dut.configure('ip igmp flush-routes')
        dut.configure('restart {0}'.format(p_name))
    if p_name == 'pim':
        dut.configure('ip pim flush-routes')
        dut.configure('restart {0}'.format(p_name))
    if p_name == 'bgp' and kwargs:
        cfg = ''' router {0} {1}
                  flush-routes
              '''.format(p_name,process_id)
        dut.configure(cfg)
        dut.configure('restart {0} {1}'.format(p_name,process_id))
    if p_name == 'ngmvpn':
        dut.configure('restart {0}'.format(p_name))

    countDownTimer(30)
    # Get the PID of the process after restarting it
    post_kill_pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    post_kill_pid_regex = re.search("PID = (\\d+)",post_kill_pid_data,re.I)
    if post_kill_pid_regex is not 0:
        post_kill_pid = post_kill_pid_regex.group(1)

    # Check if pre-kill PID and post-kill PID are different
    if pid != post_kill_pid:
        return 1
    else:
        return 0


class CommonSetup(aetest.CommonSetup):
    

    '''
    Setup :
        **********

    '''

    uid = 'common_setup'
    @aetest.subsection
    def initialize_logging(self, testscript):
        """ Common setup section to initialize logging for script"""

        log = logging.getLogger(__name__)
        log.setLevel(logging.DEBUG)
        testscript.parameters['log'] = log


    @aetest.subsection
    def check_topology(self, testbed, testscript,log,traffic_threshold='', tgn_connect = '', **kwargs):
        """ common setup subsection: connecting devices """

        testscript.parameters['traffic_threshold'] = traffic_threshold
        testscript.parameters['tgn_connect'] = tgn_connect
 
        log.info(banner('The value of kwargs is : {0}'.format(kwargs)))
        testscript.parameters['config_interface'] = kwargs['config_interface']
        testscript.parameters['config_ospf'] = kwargs['config_ospf']
        testscript.parameters['config_ospfv3'] = kwargs['config_ospfv3']
        testscript.parameters['config_bgp'] = kwargs['config_bgp']
        testscript.parameters['config_vpc'] = kwargs['config_vpc']
        testscript.parameters['config_pim'] = kwargs['config_pim']
        testscript.parameters['config_vxlan_global'] = kwargs['config_vxlan_global']
        testscript.parameters['config_bgp_global'] = kwargs['config_bgp_global']
        testscript.parameters['config_vlan'] = kwargs['config_vlan']
        testscript.parameters['config_vrf'] = kwargs['config_vrf']
        testscript.parameters['config_svi'] = kwargs['config_svi']
        testscript.parameters['config_evpn'] = kwargs['config_evpn']
        testscript.parameters['config_nve_global'] = kwargs['config_nve_global'] 
        testscript.parameters['config_nve_l2vni'] = kwargs['config_nve_l2vni']
        testscript.parameters['config_nve_l3vni'] = kwargs['config_nve_l3vni']
        testscript.parameters['config_sub_intf'] = kwargs['config_sub_intf']
        testscript.parameters['config_loopback_intf'] = kwargs['config_loopback_intf']
        testscript.parameters['config_ospf_router_id'] = kwargs['config_ospf_router_id']
        testscript.parameters['config_route_map'] = kwargs['config_route_map']
        testscript.parameters['config_multisite'] = kwargs['config_multisite']
        testscript.parameters['config_tunnel_encryption'] = kwargs['config_tunnel_encryption']
        testscript.parameters['config_tgn_conn'] = kwargs['config_tgn_conn']
        testscript.parameters['config_tgn_interface'] = kwargs['config_tgn_interface']
                                         
        parser = argparse.ArgumentParser()
        parser.add_argument('--config-file',dest='config_file',type=str)
        args = parser.parse_args()
        config_file = args.config_file
        fp = open(config_file)
        configdict=yaml.safe_load(fp)
        fp.close()        
        fail_result=0
        log.info('Getting testbed objects from the testbed file')
        testbed_obj = testbed

        # Way to get password and login from Testbed file
        passw = testbed_obj.passwords['tacacs']
        login = testbed_obj.tacacs['username']

        log.info(banner('The Devices in Testbed File are : \n {0}'.format("\n".join(list(testbed_obj.devices.keys())))))

        duts = list(filter(lambda x: 'TG' not in x, list(testbed_obj.devices.aliases)))
        TGs = list(filter(lambda x: 'uut' not in x , list (testbed_obj.devices.aliases)))

        log.info('{0} are the available duts in the testbed'.format(duts))
        log.info('{0} are the available TGs in the testbed'.format(TGs))   
                
        duts.sort()
        TGs.sort()

        # As per Testbed File following links are present.
        
        alias_intf_mapping = {}
        for dut in list(testbed_obj.devices.keys()):
            a = testbed_obj.devices[dut].alias
            log.info(banner('Dut Alias is  : {0}'.format(a)))
            alias_intf_mapping[a] = {}
            if 'ixia' not in dut:
                log.info(banner('DUT is {0}'.format(dut)))
            else:
                log.info(banner('TRAFFIC GENERATOR is: {0}'.format(dut)))
            intf = [x for x in testbed_obj.devices[dut].interfaces.keys()]
            alias = [testbed_obj.devices[dut].interfaces[x].alias for x in testbed_obj.devices[dut].interfaces.keys()]
            res = list(zip(intf,alias))
            alias_intf_mapping.update(dict(zip(alias,intf)))
            alias_intf_mapping[a].update(dict(zip(alias,intf)))
            alias_intf_mapping.setdefault('all_intf',{})
            alias_intf_mapping['all_intf'].update(dict(zip(alias,intf)))
            log.info(banner('The interfaces and alias on dut {1} are \n {0}'.format("\n".join(["->".join(x) for x in res]),dut)))
            
            
        log.info('The value of alias_intf_mapping is {0}'.format(yaml.dump(alias_intf_mapping)))

        # Way to take variable to other section
        testscript.parameters['testbed_obj'] = testbed_obj
        testscript.parameters['configdict'] = configdict
        testscript.parameters['fail_result'] = fail_result
        testscript.parameters['alias_intf_mapping'] = alias_intf_mapping
       
    @aetest.subsection
    def configBringUp(self,testscript,log,steps):
        
        testbed_obj = testscript.parameters['testbed_obj']

        # DUTs required to test this feature 
        dutList_config_file = list(testscript.parameters['configdict']['dut'].keys())
        log.info('{0} are the duts required for EVPN tests'.format(dutList_config_file))
        
        # TGNs required for this CFD
        TGList_config_file = list(testscript.parameters['configdict']['TG'].keys())
        log.info('{0} are the TGNs required for EVPN tests'.format(TGList_config_file))
        
        # Create obj for each node from config file
        dutList_obj_config_file = []
        for dut_config_file in dutList_config_file:
            dutList_obj_config_file.append(testscript.parameters['testbed_obj'].devices[dut_config_file])
            
        # declaring vtep list
        node_dict = {}
        
        for node in list(testbed_obj.devices.keys()):
            log.info('The Value of node is : {0}'.format(node))
            log.info('The value of node.type is : {0}'.format(testbed_obj.devices[node].type))
            if re.search('Site1',testbed_obj.devices[node].type):
                node_dict.setdefault('Site1',{})
                node_dict.setdefault('all_bgws',{})
                if re.search('BGW',testbed_obj.devices[node].type):
                    node_dict['Site1'].setdefault('BGW',{})
                    node_dict['Site1']['BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    node_dict['all_bgws'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('SPINE',testbed_obj.devices[node].type):
                    node_dict['Site1'].setdefault('SPINE',{})
                    node_dict['Site1']['SPINE'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('LEAF',testbed_obj.devices[node].type):
                    node_dict['Site1'].setdefault('LEAF',{})
                    node_dict['Site1']['LEAF'][testbed_obj.devices[node].alias] = testbed_obj.devices[node] 
                if re.search('MACSEC',testbed_obj.devices[node].type):
                    node_dict['Site1'].setdefault('MACSEC',{})
                    node_dict['Site1']['MACSEC'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]  
            elif re.search('Site2',testbed_obj.devices[node].type):
                node_dict.setdefault('Site2',{})
                node_dict.setdefault('all_bgws',{})
                if re.search('BGW',testbed_obj.devices[node].type):
                    node_dict['Site2'].setdefault('BGW',{})
                    node_dict['Site2']['BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    node_dict['all_bgws'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('SPINE',testbed_obj.devices[node].type):
                    node_dict['Site2'].setdefault('SPINE',{})
                    node_dict['Site2']['SPINE'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('LEAF',testbed_obj.devices[node].type):
                    node_dict['Site2'].setdefault('LEAF',{})
                    node_dict['Site2']['LEAF'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('Site3',testbed_obj.devices[node].type):
                node_dict.setdefault('Site3',{})
                node_dict.setdefault('all_bgws',{})
                if re.search('BGW',testbed_obj.devices[node].type):
                    node_dict['Site3'].setdefault('BGW',{})
                    node_dict['Site3']['BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    node_dict['all_bgws'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('SPINE',testbed_obj.devices[node].type):
                    node_dict['Site3'].setdefault('SPINE',{})
                    node_dict['Site3']['SPINE'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('LEAF',testbed_obj.devices[node].type):
                    node_dict['Site3'].setdefault('LEAF',{})
                    node_dict['Site3']['LEAF'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('DCI',testbed_obj.devices[node].type):
                node_dict.setdefault('DCI',{})
                node_dict['DCI'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('ixia',testbed_obj.devices[node].type):
                node_dict.setdefault('trf_gen',{})
                node_dict['trf_gen'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            node_dict.setdefault('all_dut',{})
            node_dict['all_dut'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]

        log.info(banner('Value of Node dict is : {0}'.format(node_dict)))
#         log.info('Value of Node dict is : {0}'.format(node_dict))
#         log.info(banner('The Value of node_dict - Readability is '))
#         
#         log.info(json.dumps(node_dict,sort_keys=True,indent=4))
                
        for dut in node_dict['all_dut']:
            if not re.search(r'TG',dut,re.I):
                node_dict['all_dut'][dut].connect()
        
        testscript.parameters['node_dict'] = node_dict
        testscript.parameters['TGList'] = TGList_config_file
                            
    @aetest.subsection
    def configureInterfaces(self,testscript,log):
        
        config_interface = testscript.parameters['config_interface']
        
        if config_interface:
            #interface config dict 
            config_dict = testscript.parameters['configdict']
            node_dict = testscript.parameters['node_dict']
            testbed_obj = testscript.parameters['testbed_obj']
            
            intf_config_dict = testscript.parameters['configdict']['interface_config_dict']
    
            log.info(banner('The value of interface_config_dict is {0} '.format(intf_config_dict)))
            
            log.info(banner('The value of node_dict is {0} '.format(node_dict)))
            
            intf_obj = config_bringup_test_vijay.configSetup(config_dict,testbed_obj,log)
            
            if not intf_obj:
                self.failed()
        else:
            pass
        
    @aetest.subsection
    def configureUnderlayOSPF(self,testscript,log):

        config_ospf = testscript.parameters['config_ospf']
        if config_ospf:
            #ospf_config_dict
            ospf_config_dict = testscript.parameters['configdict']['ospfv2_config_dict']
            node_dict = testscript.parameters['node_dict']
            
            obj_ospf=ospfv2_lib.configOspfv2(node_dict['all_dut'],ospf_config_dict,log)
            
            if not obj_ospf:
                self.failed()
        else:
            pass

    @aetest.subsection
    def configureUnderlayOSPFv3(self,testscript,log):
        
        config_ospfv3 = testscript.parameters['config_ospfv3']
        
        if config_ospfv3:
            #ospf_config_dict
            ospfv3_config_dict = testscript.parameters['configdict']['ospfv3_config_dict']
            node_dict = testscript.parameters['node_dict']
            
            obj_ospf=ospfv3_lib.configOspfv3(node_dict['all_dut'],ospfv3_config_dict,log)
            
            if not obj_ospf:
                self.failed()
        else:
            pass
            
            
    @aetest.subsection       
    def configureBGPNeighbors(self,testscript,log):

        config_bgp = testscript.parameters['config_bgp']
        
        if config_bgp:
        
            #BGP_config_dict 
            bgp_config_dict = testscript.parameters['configdict']['bgp_config_dict']
    
            node_dict = testscript.parameters['node_dict']
            
            for dut in bgp_config_dict.keys():
                obj_bgp=bgp_lib.configBgp(bgp_config_dict,node_dict['all_dut'],log)
                if not obj_bgp.Nodes(dut):
                    self.failed()
        else:
            pass
        
    @aetest.subsection       
    def configureVPCSwitches(self,testscript,log):
        
        config_vpc = testscript.parameters['config_vpc']
        
        if config_vpc:
            node_dict = testscript.parameters['node_dict']
            config_dict = testscript.parameters['configdict']
            
            for dut in node_dict['vpc_vteps'].keys():
                hdl = node_dict['vpc_vteps'][dut]
                d = config_bringup.setupConfigVpc(hdl,dut,log,config_dict)
        else:
            pass
        
    @aetest.subsection       
    def configurePIMNeighbors(self,testscript,log):

        config_pim = testscript.parameters['config_pim']
        
        if config_pim:
            intf_config_dict = testscript.parameters['configdict']['interface_config_dict']
      
            pim_config_dict = testscript.parameters['configdict']['pim_config_dict']
    
            node_dict = testscript.parameters['node_dict']
            
            for dut in pim_config_dict.keys():
                obj_pim = pim_lib.configPim(intf_config_dict,pim_config_dict,node_dict['all_dut'],log,'-dut {0}'.format(dut))
                
            if  obj_pim.result=='fail':
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureGlobalVxlan(self,testscript,log):    
        
        config_vxlan_global = testscript.parameters['config_vxlan_global']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_vxlan_global:
            #SCALE_Config_dict
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
            log.info(banner('The value of vtep_dict is {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureGlobalVxlanParams(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureGlobalBGP(self,testscript,log):    
        
        config_bgp_global = testscript.parameters['config_bgp_global']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_bgp_global:
            #SCALE_Config_dict
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')

            log.info(banner('The value of vtep_dict is {0}'.format(vtep_dict)))
            
            res = scale_config_obj.configureGlobalBGPParams(vtep_dict)
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection       
    def configureScaleVlan(self,testscript,log):
        
        config_vlan = testscript.parameters['config_vlan']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_vlan:
            #SCALE_Config_dict
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            # device_dict = {}
            # for dut in ['all_vtep','core','l2_switch']:
            #     device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            
            res = scale_config_obj.configScaleVlans(device_dict)
    
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection  
    def configureScaleVRF(self,testscript,log):
        
        config_vrf = testscript.parameters['config_vrf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_vrf:
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            # device_dict = {}
            # for dut in ['all_vtep','external_rp','core']:
            #     device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            
            res = scale_config_obj.configScaleVRFs(device_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection       
    def configureScaleSVI(self,testscript,log):     
        
        config_svi = testscript.parameters['config_svi']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_svi:
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
#             device_dict = {}
#             for dut in ['all_vtep','core']:
#             for dut in ['core']:
#                 device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            
            res = scale_config_obj.configScaleSVIs(device_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureScaleEvpn(self,testscript,log):  
        
        config_evpn = testscript.parameters['config_evpn']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
                
        if config_evpn:
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configScaleEVPN(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureNveInterfaceGlobals(self,testscript,log):  
        
        config_nve_global = testscript.parameters['config_nve_global']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']        
        
        if config_nve_global:
            
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureNveGlobal(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureL2VNIOnNveInterface(self,testscript,log):     
        
        config_nve_l2vni = testscript.parameters['config_nve_l2vni']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']  
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_nve_l2vni:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureL2VNIOnNve(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureL3VNIOnNveInterface(self,testscript,log):     
        
        config_nve_l3vni = testscript.parameters['config_nve_l3vni']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_nve_l3vni:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureL3VNIOnNve(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureSubInterfaces(self,testscript,log):     
        
        config_sub_intf = testscript.parameters['config_sub_intf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_sub_intf:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = {}
            for dut in ['vpc_vtep','external_rp','core']:
                device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
    
            res = scale_config_obj.configureL3SubInterface(device_dict)
             
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureLoopbackInterfaces(self,testscript,log):     
        
        config_loopback_intf = testscript.parameters['config_loopback_intf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_loopback_intf:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            external_rp_dict = scale_config_obj.getDeviceDict('external_rp')

            log.info(banner('The value of external_rp_dict is : {0}'.format(external_rp_dict)))
    
            res = scale_config_obj.configureLoopbackInterface(external_rp_dict)
             
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureVRFOspfRouterID(self,testscript,log):     
        
        config_ospf_router_id = testscript.parameters['config_ospf_router_id']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_ospf_router_id:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getDeviceDict('vpc_vtep')

            log.info(banner('The value of external_rp_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureOspfRouterID(vtep_dict)
             
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureGlobalRouteMaps(self,testscript,log):     
        
        config_route_map = testscript.parameters['config_route_map']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_route_map:
            
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            temp_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            dci_dict= node_dict['DCI']
            log.info('The value of dci_dict is : {0}'.format(dci_dict))
            temp_dict.update(dci_dict)
            route_map_config_dict = config_dict['route_map_config_dict']
            res = routing_utils.configRouteMaps(log,temp_dict,route_map_config_dict)
                
        else:
            pass    
        
    @aetest.subsection                     
    def configureMultisiteConfigs(self,testscript,log):     
        
        config_multisite = testscript.parameters['config_multisite']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_multisite:
        
            multisite_config_dict = config_dict['multisite_config_dict']
    
            for dut in multisite_config_dict.keys():
                obj_ms=MyLib.my_multisite_lib.configMultisite(multisite_config_dict,node_dict,alias_intf_mapping,log)
                if not obj_ms.Nodes(dut):
                    self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureTunnelEncryptionConfigs(self,testscript,log):     
        
        config_tun_encr = testscript.parameters['config_tunnel_encryption']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_tun_encr:
        
            cloudsec_config_dict = config_dict['cloudsec_config_dict']
    
            for dut in cloudsec_config_dict.keys():
                obj_cs=MyLib.my_cloudsec_lib.configTunnelEncryption(cloudsec_config_dict,node_dict,alias_intf_mapping,log)
                if not obj_cs.Nodes(dut):
                    self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def getNvePeerDictFromConfigs(self,testscript,log,steps):

        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        res = MyLib.my_config_utils.getMSNvePeerDict(log,node_dict,config_dict)
        
    @aetest.subsection                     
    def connectionToTrafficGenerator(self,testscript,log): 


        config_tgn_conn =  testscript.parameters['config_tgn_conn']
        
        if config_tgn_conn:
            # Connect and confiure TG
    
            log.info('Connecting and configuring TG as per config dict...')
            # Get physical interface from logical interface of config file for TG
             
            testbed_obj = testscript.parameters['testbed_obj']
     
            TGList_config_file = testscript.parameters['TGList']
            ix_port_list = []
            ix_port_list_alias = []
            tgn_port_dut_mapping={}
            for TG in TGList_config_file:
                d = testscript.parameters['testbed_obj'].devices[TG]
                log.info('The value of d is : {0}'.format(d))
                TGIntList = testscript.parameters['configdict']['TG'][TG]['global']['ports'].keys()
                for port in TGIntList:
                    a = d.interfaces[port].alias
                    b = re.search('(uut[\d]+)',a)
                    if b:
                        dut = b.group(1)
                        tgn_port_dut_mapping[port] = dut
                
                
                for TGInt in TGIntList:
                    log.info('The value of TGint is : {0}'.format(TGInt))
                    ix_port_list.append(d.interfaces[TGInt].name)
                    ix_port_list_alias.append(d.interfaces[TGInt].alias)
                    # Connect to TG
                ix_port_list.sort(key=lambda x: '{0:0>8}'.format(x).lower())
                log.info('The value of ix_port_list is : {0}'.format(ix_port_list))
                log.info('The value of ix_port_list_alias is : {0}'.format(ix_port_list_alias))
                ixia_connect = connectToIxNetwork(self, tg_hdl = d, port_list = ix_port_list)
                     
                # Get port handles
                port_handle_list = []
                for port_handle in ixia_connect['vport_list'].split():
                    port_handle_list.append(port_handle)
                 
                port_handle_list.sort(key=lambda x: '{0:0>8}'.format(x).lower())
                 
                port_handle_dict = dict(zip(ix_port_list,port_handle_list))
                log.info("Port handles are {0}".format(port_handle_list))
                log.info('The Value of port_handle_dict is: {0}'.format(port_handle_dict))
                testscript.parameters['port_handle_dict'] = port_handle_dict
                log.info('The value of tgn_port_dut_mapping is : {0}'.format(tgn_port_dut_mapping))
                testscript.parameters['tgn_port_dut_mapping'] = tgn_port_dut_mapping
                
    @aetest.subsection      
    def configuringInterfacesOnTrafficGenerator(self,testscript,log):
        
        config_tgn_interface = testscript.parameters['config_tgn_interface']

        if config_tgn_interface:
            tg_interface_hdl_dict = {}
            port_handle_dict = testscript.parameters['port_handle_dict']
     
                #interface_handle_list = []
            TGList_config_file = testscript.parameters['TGList']
            for TG in TGList_config_file:
                tg_interface_hdl_dict[TG] = {}
                d = testscript.parameters['testbed_obj'].devices[TG]
                skip_traffic_items = testscript.parameters['configdict']['TG'][TG]['skip_traffic_items']
                log.info('Type of skip_traffic_items is : {0}'.format(type(skip_traffic_items)))
                if skip_traffic_items:
                    traffic_item_skip_list = expandTrafficItemList(testscript.parameters['configdict']['TG'][TG]['skip_traffic_items'])
                    log.info('The value of traffic_item_skip_list is : {0}'.format(traffic_item_skip_list))
                else:
                    traffic_item_skip_list = ''
                log.info('The value of traffic_item_skip_list is : {0}'.format(traffic_item_skip_list))       
                configured_stream  = []
                skipped_stream = []     
                for trf_stream in testscript.parameters['configdict']['TG'][TG]:
                    if(re.search('TRF',trf_stream)):
                        if trf_stream not in traffic_item_skip_list:
                            configured_stream.append(trf_stream)
                            tg_interface_hdl_dict[TG][trf_stream] = {}
                            TGIntList = testscript.parameters['configdict']['TG'][TG][trf_stream]['tg_interface_config_dict'].keys()
                            for TGInt in TGIntList:
                                log.info('The value of TGInt is : {0}'.format(TGInt))
                                ixia_intf_ip_list=[]
                                tg_interface_hdl_dict[TG][trf_stream][TGInt] = {}
                                intf_args = generateTrafficGenIntfConfigs(log,testscript.parameters['configdict']['TG'][TG][trf_stream]['tg_interface_config_dict'][TGInt]) 
                                log.info('The value of intf_args is : {0}'.format(intf_args))
                                for j,k  in enumerate(intf_args):
                                    a = intf_args[j]
                                    ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=d,port_handle=port_handle_dict[TGInt])
                                    log.info('the value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                                    for b in ixia_interface_config:
                                        ixia_intf_ip_list.append(b)
                                        tg_interface_hdl_dict[TG][trf_stream][TGInt][b]={}
                                        tg_interface_hdl_dict[TG][trf_stream][TGInt][b]['handle']=ixia_interface_config[b]
                                    tg_interface_hdl_dict[TG][trf_stream][TGInt]['ip_list']=ixia_intf_ip_list
                        else:
                            skipped_stream.append(trf_stream)

                    elif(re.search('RAW',trf_stream)):
                        if trf_stream not in traffic_item_skip_list:
                            configured_stream.append(trf_stream)
                        else:
                            skipped_stream.append(trf_stream)
            
            log.info(banner('The following traffic stream  %s is skipped from configuring ... ' % skipped_stream))
                        
            c = yaml.dump(tg_interface_hdl_dict)
            log.info('The value of c is : {0}'.format(c))
            testscript.parameters['tg_interface_hdl_dict'] = tg_interface_hdl_dict
            testscript.parameters['configured_stream'] = configured_stream
            log.info(banner('The value of configured_stream is : {0}'.format(configured_stream)))


        
    

    @aetest.subsection                     
    def verifyConfiguationsBeforeStartOfTest(self,testscript,log,steps):
#         '''
        config_dict = testscript.parameters['configdict']
        cloudsec_dict = config_dict['cloudsec_config_dict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
        vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
                
        verify_obj = MyLib.my_config_utils.VerifyConfigs(log,config_dict,node_dict,alias_intf_mapping)
        
        verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_dict,node_dict,alias_intf_mapping)
        '''
        with steps.start('Verify OSPFv2 Neighborship on all duts') as s:
            log.info('Verifying the OSPFv2 Neighborship on all duts ......')
            res = verify_obj.verifyOSPFv4Neighorship()
            if not res:
                self.failed()

#         with steps.start('Verify OSPFv3 Neighborship on all duts') as s:
#             log.info('Verifying the OSPFv3 Neighborship on all duts ......')
#             res = verify_obj.verifyOSPFv6Neighorship()
#             if not res:
#                 self.failed()

        log.info('Waiting for 15 seconds before checking the BGP Neighborship')
        countDownTimer(15)
        with steps.start('Verify BGP L2EVPN Neighborship on all duts') as s:
            log.info('Verify BGP L2EVPN Neighborship on all duts ......')
            res = verify_obj.verifyBGPL2EVPNNeighbor()
            if not res:
                self.failed()

        with steps.start('Verify BGP L2EVPN Neighborship on all duts') as s:
            log.info('Verify BGP mVPN Neighborship on all duts ......')
            res = verify_obj.verifyBGPL2EVPNNeighbor()
            if not res:
                self.failed()
                        
        with steps.start('Verify L2 and L3 VNI Status on all VTEPS') as s:
            log.info('Verifying L2 and L3 VNI status on all VTEPs ......')
            res = verify_obj.verifyVNIStatus(vtep_dict)
            if not res:
                self.failed()

        with steps.start('Verify Nve Peers in VTEPs') as s:
            log.info('Verify Nve Peers in VTEPs ......')
            res = verify_obj.verifyNVEStatus(vtep_dict)
            if not res:
                self.failed()
                
        with steps.start('Verify the CloudSec peers in BGWs') as s:
            log.info('Verify the CloudSec peers in BGWs.......')
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(vtep_dict,from_configfile)
            if not res:
                self.failed()
        '''
        log.info(banner('Waiting for 30 seconds before Configuring the Traffic ... {0}'.format(countDownTimer(30))))


    @aetest.subsection     
    def configureTrafficStreams(self,testscript,log):
        
#         '''
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        log.info('the value of tg_interface_hdl_dict is : {0}'.format(tg_interface_hdl_dict))
        configured_stream = testscript.parameters['configured_stream']
        
        log.info(banner('The value of configured_stream is : {0}'.format(configured_stream)))
        port_handle_dict = testscript.parameters['port_handle_dict']
        log.info('the value of port_handle_dict is : {0}'.format(port_handle_dict))
         
        TGList_config_file = testscript.parameters['TGList']
         
        traffic_stream_dict = {}
        for TG in TGList_config_file:
            d = testscript.parameters['testbed_obj'].devices[TG]
            for trf_stream in testscript.parameters['configdict']['TG'][TG]:
                log.info(banner('The value of trf_stream is : {0}'.format(trf_stream)))
                if(re.search('TRF',trf_stream)):
                    if trf_stream in configured_stream:
                        TGIgmpIntList = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict'].keys()
                        src_handle = []
                        dest_handle = []
                        traffic_stream_dict[trf_stream] = {}
                        source_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['source']
                        receiver_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['receivers']
                        traffic_args=testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['params']
                        if isinstance(source_port, list):
                            for i in source_port:
                                log.info('src: The value of i is : {0}'.format(i))
                                for port in tg_interface_hdl_dict[TG][trf_stream]:
                                    log.info('src: The value of port is : {0}'.format(port))
                                    if(port == i):
                                        pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                        for ip in tg_interface_hdl_dict[TG][trf_stream][port]:
                                            test=pat.match(ip)
                                            if test:
                                                log.info('src: The value of i is : {0}'.format(i))
                                                log.info('src: The value of port is : {0}'.format(port))
                                                log.info('src: The value of ip is : {0}'.format(ip))
                                                log.info('src: The value of trf_stream is : {0}'.format(trf_stream))
                                                handle = tg_interface_hdl_dict[TG][trf_stream][port][ip]['handle']
                                                src_handle.append(handle)
                     
                        if isinstance(receiver_port,list):
                            for i in receiver_port:
                                log.info('rcv:The value of i is : {0}'.format(i))
                                for port in tg_interface_hdl_dict[TG][trf_stream]:
                                    log.info('rcv: The value of port is : {0}'.format(port))
                                    if(port == i):
                                        pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                        for ip in tg_interface_hdl_dict[TG][trf_stream][port]:
                                            test=pat.match(ip)
                                            if test:
                                                log.info('rcv: The value of i is : {0}'.format(i))
                                                log.info('rcv: The value of port is : {0}'.format(port))
                                                log.info('rcv: The value of ip is : {0}'.format(ip))
                                                log.info('rcv: The value of trf_stream is : {0}'.format(trf_stream))
                                                handle = tg_interface_hdl_dict[TG][trf_stream][port][ip]['handle']
                                                dest_handle.append(handle)
                        traffic_stream_dict[trf_stream]['source'] = source_port
                        traffic_stream_dict[trf_stream]['destination'] = receiver_port
                     
                        log.info('The value of src_handle is : {0}'.format(src_handle))
                        log.info('The value of dest_handle is : {0}'.format(dest_handle))
                         
                        ixia_traffic_config = configureIxNetworkTraffic(self, traffic_args, tg_hdl=d, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                        log.info('The value of ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                    
                        traffic_stream_dict[trf_stream]['stream_id'] = ixia_traffic_config.stream_id
                        traffic_stream_dict[trf_stream]['traffic_item'] = ixia_traffic_config.traffic_item
                        traffic_stream_dict[trf_stream]['status'] = ixia_traffic_config.status
                        
                elif(re.search('RAW',trf_stream)):
                    log.info(banner('Inside RAW Stream Configuration : '))
                    if trf_stream in configured_stream:
                        TGIgmpIntList = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict'].keys()
                        traffic_stream_dict[trf_stream] = {}
                        source_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['source']
                        receiver_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['receivers']
                        traffic_args=testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['params']

                        traffic_stream_dict[trf_stream]['source'] = source_port
                        traffic_stream_dict[trf_stream]['destination'] = receiver_port
                         
                        src_port = [port_handle_dict[x] for x in source_port]
                        dst_port = [port_handle_dict[x] for x in receiver_port]
                        log.info('The value of src_port is : {0}'.format(src_port))
                        log.info('The value of dst_port is : {0}'.format(dst_port))
                        
                        ixia_traffic_config = configureIxNetworkRawTrafficL2(self, traffic_args, tg_hdl=d, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                        log.info('The value of ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                    
                        traffic_stream_dict[trf_stream]['stream_id'] = ixia_traffic_config.stream_id
                        traffic_stream_dict[trf_stream]['traffic_item'] = ixia_traffic_config.traffic_item
                        traffic_stream_dict[trf_stream]['status'] = ixia_traffic_config.status
                    
 
        log.info('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict))
        testscript.parameters['traffic_stream_dict']  = traffic_stream_dict     
    
    @aetest.subsection     
    def startAllTrafficStreams(self,testscript,log):  
   
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold'] 
        
        log.info(banner('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict)))
           
        unstarted_stream = []
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            flag = 1
            failed_traffic_stream_stats = {}
            for trf_stream in traffic_stream_dict:
                if traffic_stream_dict[trf_stream]['status']:
                    stream_handle = traffic_stream_dict[trf_stream]['traffic_item']
                    x = tgn_hdl.traffic_control(action='run', handle = stream_handle, max_wait_timer=60)
                    stream_id = traffic_stream_dict[trf_stream]['stream_id']
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(stream_id)))
                        unstarted_stream.append(stream_id)
                        
        if unstarted_stream:
            log.error(banner('The Following Streams could not be started..{0}'.format(unstarted_stream)))
            self.failed()
    
    @aetest.subsection     
    def checkAllTrafficStreamsStats(self,testscript,log):  
   
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        
        log.info(banner('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict)))
        
        failed_stream_list = []
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            for trf_stream in traffic_stream_dict:
                if traffic_stream_dict[trf_stream]['status']:
                    stream_handle = traffic_stream_dict[trf_stream]['traffic_item']
                    x = tgn_hdl.traffic_control(action='clear_stats', handle = stream_handle, max_wait_timer=60)
                    stream_id = traffic_stream_dict[trf_stream]['stream_id']
                    countDownTimer(10)
                    y = tgn_hdl.traffic_stats(stream=stream_id,mode='traffic_item')
                    log.info(banner('The value of y is : {0}'.format(y)))
                    for i in y['traffic_item']:
                        if i == stream_id:
                            loss_percent= y['traffic_item'][i]['rx']['loss_percent']
                            log.info(banner('The value of loss_percent is : {0}'.format(loss_percent)))
                            if loss_percent > 1.0:
                                failed_stream_list.append(trf_stream)
            
            log.info(banner('Traffic Stream Details and Breakup is'))
            
            traffic_obj = MyLib.my_config_utils.TrafficStatistics(log,tg_interface_hdl_dict,traffic_stream_dict,port_handle_dict,
                                                              threshold,node_dict,alias_intf_mapping,configured_stream)
            
            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
#            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
        
            if failed_stream_list:
                log.error(banner('The Initial Traffic Pass Criteria is not met for the following streams..{0}'.format(failed_stream_list)))
                failed_stream_dict = {}
                for stream in failed_stream_list:
                    failed_stream_dict[stream] = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,traffic_stream_dict,stream)
                log.info('the value of failed_stream_dict is : {0}'.format(failed_stream_dict))
                MyLib.my_config_utils.drawTrafficTable(log,failed_stream_dict,traffic_stream_dict)
                self.failed()


    @aetest.subsection     
    def initializeFewThingsForTest(self,testscript,log):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict']
        traffic_stream_dict = testscript.parameters['traffic_stream_dict']
        port_handle_dict = testscript.parameters['port_handle_dict']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        config_dict = testscript.parameters['configdict']

        traffic_obj = MyLib.my_config_utils.TrafficStatistics(log,tg_interface_hdl_dict,traffic_stream_dict,port_handle_dict,
                                                       threshold,node_dict,alias_intf_mapping,configured_stream)
        testscript.parameters['traffic_obj'] = traffic_obj
        
        traffic_config_obj = MyLib.my_config_utils.TrafficConfiguration(log,testscript,config_dict,port_handle_dict)
        
        testscript.parameters['traffic_config_obj'] = traffic_config_obj
        
        scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
        
        testscript.parameters['scale_config_obj'] = scale_config_obj
        
        multicast_trigger_obj = MyLib.my_trigger_utils.MulticastTrigger(log,node_dict,config_dict,alias_intf_mapping)
        
        testscript.parameters['multicast_trigger_obj'] = multicast_trigger_obj
        
        trigger_obj = MyLib.my_utils.TriggerItems(log,node_dict,config_dict,traffic_stream_dict,port_handle_dict,threshold,alias_intf_mapping,configured_stream)
        testscript.parameters['trigger_obj'] = trigger_obj
 
        
# Generating Other Traffic Items : VRF V-011 to V-020
class VxlanCloudSec_Func001(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-001"""

    uid = 'VXLAN-CS-FUNC-001'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func001(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-011 to V-020'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-011 to V-020')
                traffic_item_list = ['TRF011','TRF012','TRF013','TRF014','TRF015','TRF016','TRF017','TRF018','TRF019','TRF020']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-011 to V-020')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-021 to V-030
class VxlanCloudSec_Func002(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-002"""

    uid = 'VXLAN-CS-FUNC-002'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func002(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-021 to V-030'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-011 to V-020')
                traffic_item_list = ['TRF021','TRF022','TRF023','TRF024','TRF025','TRF026','TRF027','TRF028','TRF029','TRF030']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-011 to V-020')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-031 to V-040
class VxlanCloudSec_Func003(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-003"""

    uid = 'VXLAN-CS-FUNC-003'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func003(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-031 to V-040'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-011 to V-020')
                traffic_item_list = ['TRF031','TRF032','TRF033','TRF034','TRF035','TRF036','TRF037','TRF038','TRF039','TRF040']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-031 to V-040')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-041 to V-050
class VxlanCloudSec_Func004(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-004"""

    uid = 'VXLAN-CS-FUNC-004'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func004(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-041 to V-050'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-041 to V-050')
                traffic_item_list = ['TRF041','TRF042','TRF043','TRF044','TRF045','TRF046','TRF047','TRF048','TRF049','TRF050']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-041 to V-050')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-051 to V-060
class VxlanCloudSec_Func005(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-005"""

    uid = 'VXLAN-CS-FUNC-005'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func005(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-051 to V-060'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-051 to V-060')
                traffic_item_list = ['TRF051','TRF052','TRF053','TRF054','TRF055','TRF056','TRF057','TRF058','TRF059','TRF060']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-051 to V-060')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-061 to V-070
class VxlanCloudSec_Func006(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-006"""

    uid = 'VXLAN-CS-FUNC-006'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func006(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-061 to V-070'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-061 to V-070')
                traffic_item_list = ['TRF061','TRF062','TRF063','TRF064','TRF065','TRF066','TRF067','TRF068','TRF069','TRF070']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-061 to V-070')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-071 to V-080
class VxlanCloudSec_Func007(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-007"""

    uid = 'VXLAN-CS-FUNC-007'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func007(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-071 to V-080'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-071 to V-080')
                traffic_item_list = ['TRF071','TRF072','TRF073','TRF074','TRF075','TRF076','TRF077','TRF078','TRF079','TRF080']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-011 to V-020')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-081 to V-090
class VxlanCloudSec_Func008(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-008"""

    uid = 'VXLAN-CS-FUNC-008'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func008(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-081 to V-090'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-081 to V-090')
                traffic_item_list = ['TRF081','TRF082','TRF083','TRF084','TRF085','TRF086','TRF087','TRF088','TRF089','TRF090']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-011 to V-020')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Other Traffic Items : VRF V-091 to V-100
class VxlanCloudSec_Func009(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-009"""

    uid = 'VXLAN-CS-FUNC-009'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func009(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating Other Traffic Items : VRF V-091 to V-100'))
        
        global_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        new_tg_interface_hdl_dict= {}
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : V-091 to V-100')
                traffic_item_list = ['TRF091','TRF092','TRF093','TRF094','TRF095','TRF096','TRF097','TRF098','TRF099','TRF100']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : V-091 to V-100')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating BUM TRaffic - Broadcast Traffic
class VxlanCloudSec_Func010(aetest.Testcase):

    """ Vxlan CloudSec - Func-010"""

    uid = 'VXLAN-CS-FUNC-010'

    @aetest.test
    def VxlanCS_BUMTraffic_Func010(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test10:- Generating BUM TRaffic - Broadcast Traffic'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
            vlan_start = 101
            num_of_vlans = 100
            vni_start = 100101
            
            global_flag = 0
            stream_create_flag = 0
            stream_start_flag = 0
            stream_stat_fail_flag = 0
            stream_stop_flag = 0
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                log.info('Configuring the vlans required for the tests in all VTEPs')
            
                log.info(banner('Configuring the Vlans on all VTEPs'))
                                
                args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                
                threads = []
                for dut in vtep_dict:
                    t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                         args = [log, vtep_dict[dut], args])
                    t.start()
                    threads.append(t)
                [thread.join() for thread in threads]
            
                testscript.parameters['bridge_vlan_start'] = vlan_start
                testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                testscript.parameters['bridge_vni_start'] = vni_start
            
            
            with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                evpn_config_dict = {}
                for dut in vtep_dict:
                    evpn_config_dict[dut]={}
                    evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                
                log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                
                new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                
                threads = []
                for dut in vtep_dict:
                    t = threading.Thread(target = evpn_lib.configEvpn,
                                         args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                    t.start()
                    threads.append(t)
                [thread.join() for thread in threads]
                
            with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                log.info('Configuring the EVPN configs for the tests in all VTEPs')
        
                args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                
                threads = []
                for dut in vtep_dict:
                    t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                         args = [dut,node_dict['all_dut'][dut],args,log])
                    t.start()
                    threads.append(t)
                [thread.join() for thread in threads]
                
            with steps.start('Configuring Raw Traffic -BUM') as s:
                raw_traffic_dict = {}
                raw_list  = []
                fail_stream = []
                for trf_item in tgn_config_dict[TG].keys():
                    if re.search('RAW', trf_item, re.IGNORECASE):
                        raw_list.append(trf_item)
                        
                log.info(banner('The value of raw_list is : {0}'.format(raw_list)))
                        
                for item in raw_list:
                    raw_traffic_dict[item] = {}
                    log.info('Creating Raw stream for traffic stream {0} as defined in Config File'.format(item))
                    source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    trf_args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    
                    src_port = [port_handle_dict[x] for x in source_port]
                    dst_port = [port_handle_dict[x] for x in receiver_port]
                    
                    raw_traffic_cfg = configureIxNetworkRawTrafficL2(self, trf_args, tg_hdl=tgn_hdl, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                    log.info('The value of ixia_traffic_config is : {0}'.format(raw_traffic_cfg))

                    if not raw_traffic_cfg.status:
                        log.error('The Raw stream {0} could not be generated'.format(item))
                        fail_stream.append(item)
                    else:
                        raw_traffic_dict[item]['source'] = source_port
                        raw_traffic_dict[item]['destination'] = receiver_port
                        raw_traffic_dict[item]['stream_id'] = raw_traffic_cfg['stream_id']
                        raw_traffic_dict[item]['status'] = raw_traffic_cfg['status']
                        raw_traffic_dict[item]['traffic_item'] = raw_traffic_cfg['traffic_item']
                        
                    if fail_stream:
                        global_flag  = 1
                        stream_create_flag  = 1

                
            with steps.start('Starting the BUM Traffic Stream one by one') as s:
                log.info(banner('Starting the BUM Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in raw_traffic_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                    
                    if len(raw_list) > 1:
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                    
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in raw_traffic_dict.keys():
                    ixia_stream = raw_traffic_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    exp_rx_traffic = res['tx'] * len(receiver_port)
                    log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                    
                    if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                        log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream RAW001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(raw_traffic_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in raw_traffic_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(raw_traffic_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(raw_traffic_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(raw_traffic_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(raw_traffic_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=raw_traffic_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

#Test11:- Verify Tunnel-Encryption CLI
class VxlanCloudSec_Func011(aetest.Testcase):

    """ Vxlan CloudSec - Func-011"""

    uid = 'VXLAN-CS-FUNC-011'

    @aetest.test
    def VxlanCloudSec_TunnelEncryptionCLI_Func011(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test11:- Verify Tunnel-Encryption CLI'))
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Verifying the Tunnel Encryption CLIs') as s:
                log.info('Verifying the Tunnel Encryption CLIs')
                vtep_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
                dut_list = list(vtep_dict.keys())
                log.info('The value of dut_list is : {0}'.format(dut_list))
                dut_taken = dut_list[0]
                hdl = node_dict['all_dut'][dut_taken]
                
                unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
                # unicon_state.add_state_pattern(pattern_list='^%\\s*[Ii]ncomplete (command|input)')
                unicon_state.add_state_pattern(pattern_list='.*')
                out = hdl.configure('tunnel-encryption ?',allow_state_change="True")
                unicon_state.restore_state_pattern()
                log.info('The value of out is : {0}'.format(out))

                global_flag = 0
                secure_flag = 0
                peer_ip_flag = 0
                policy_flag = 0
                source_intf_flag  = 0
                sak_rekey_flag = 0
                for line in out.splitlines():
                    log.info('the value of line is : {0}'.format(line))
                    if re.search(r'^  must-secure-policy', line, re.I):
                        secure_flag =1
                    if re.search(r'^  peer-ip', line, re.I):
                        peer_ip_flag =1                    
                    if re.search(r'^  policy', line, re.I):
                        policy_flag =1
                    if re.search(r'^  sak-rekey', line, re.I):
                        sak_rekey_flag =1                        
                    if re.search(r'^  source-interface', line, re.I):
                        source_intf_flag =1
                if secure_flag and peer_ip_flag and policy_flag and source_intf_flag and sak_rekey_flag:
                    global_flag = 1
                    
                if not global_flag:
                    log.error('The following CLI is not present: Hence failing the tc')
                    if not secure_flag:
                        log.error('The must-secure-policy cli is not present')
                    if not peer_ip_flag:
                        log.error('The peer_ip is not present')                        
                    if not policy_flag:
                        log.error('The policy cli is not present')
                    if not sak_rekey_flag:
                        log.error('The sak-rekey cli is not present')
                    if not source_intf_flag:
                        log.error('The source-interface cli is not present')
                    self.failed()
                
# Test11:- Verify Tunnel-Encryption sh tech debug CLI
class VxlanCloudSec_Func012(aetest.Testcase):

    """ Vxlan CloudSec - Func-012"""

    uid = 'VXLAN-CS-FUNC-012'

    @aetest.test
    def VxlanCloudSec_ShowTechCLIAndDebug_Func012(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test11:- Verify Tunnel-Encryption CLI'))
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Verifying the Show Tech and Debug CLIs') as s:
                log.info('Show Tech and Debug CLIs')
                vtep_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
                dut_list = list(vtep_dict.keys())
                log.info('The value of dut_list is : {0}'.format(dut_list))
                dut_taken = dut_list[0]
                hdl = node_dict['all_dut'][dut_taken]
                
                unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
                # unicon_state.add_state_pattern(pattern_list='^%\\s*[Ii]ncomplete (command|input)')
                unicon_state.add_state_pattern(pattern_list='.*')
                out = hdl.configure('show tech-support t?',allow_state_change="True")
                unicon_state.restore_state_pattern()
                log.info('The value of out is : {0}'.format(out))

                global_flag = 0
                show_tech_cli = 0
                debug_cli = 0
                for line in out.splitlines():
                    if re.search(r'tunnel-encryption', line, re.I):
                        show_tech_cli =1
                out = hdl.configure('debug tunnel-encryption ?')
                for line in out.splitlines():
                    if re.search(r'trace', line, re.I):
                        debug_cli =1                
                if show_tech_cli and debug_cli:
                    global_flag = 1
                    
                if not global_flag:
                    log.error('The following CLI is not present: Hence failing the tc')
                    if not show_tech_cli:
                        log.error('The cli show tech-support tunnel-encryption is not available.')
                    if not debug_cli:
                        log.error('The cli debug tunnel-encryption trace')                        
                    self.failed()

# Verify Tunnel-Encrypytion Syslog
class VxlanCloudSec_Func013(aetest.Testcase):

    """ Vxlan CloudSec - Func-013"""

    uid = 'VXLAN-CS-FUNC-013'

    @aetest.test
    def VxlanCloudSec_VerifySyslog_Func013(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test13:- Verify Tunnel-Encrypytion Syslog'))
        
        result_flag = 0
        session_down_flag = 0
        session_up_flag = 0
        stat_flag = 0
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Setting Logging Level for Tunnel Manager') as s:
                log.info('Setting Logging Level for Tunnel Manager ')
                vtep_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
                dut_list = list(vtep_dict.keys())
                log.info('The value of dut_list is : {0}'.format(dut_list))
                dut_taken = dut_list[0]
                hdl = node_dict['all_dut'][dut_taken]
                hdl.configure('logging level tunnel-encryption 7')
                
            with steps.start('Verify Logging Level for Tunnel Manager') as s:
                log.info('Verify Logging Level for Tunnel Manager ')
                out = hdl.configure('sh logging level | xml | grep -A 4 tun_enc_mgr')
                s = BeautifulSoup(out)
                try:
                    current_level = s.find('cur_level').string
                    if int(current_level) == 7:
                        flag = 1
                except Exception:
                    log.error('Logging level for Tunnel-Encryption Could not be found')
            syslog = 0
            if flag:
                with steps.start('Verifying the Syslog message  - Down condition') as s:
                    hdl.configure('clear logging logfile')
                    cfg = '''interface nve 1
                             shutdown'''
                    hdl.configure(cfg)
                    countDownTimer(3)
                    out = hdl.configure('show logging logfile')
                    pat = 'Tunnel-Encryption [T|R]x session ([A-Z]{2})?SECURED'
                    for line in out.splitlines():
                        if re.search(pat,line,re.I):
                            log.info('The entire line is : {0}'.format(line))
                            syslog = 1
                    if syslog:
                        log.info('Tunnel-Encryption Session-Down syslog is received as expected.')
                    else:
                        log.error('Tunnel-Encryption Session-Down syslog is NOT received as expected')
                        result_flag = 1
                        session_down_flag =1
                syslog = 0
                with steps.start('Verifying the Syslog message  - Down condition') as s:
                    hdl.configure('clear logging logfile')
                    cfg = '''interface nve 1
                             no shutdown'''
                    hdl.configure(cfg)
                    countDownTimer(3)
                    out = hdl.configure('show logging logfile')
                    for line in out.splitlines():
                        if re.search(pat,line,re.I):
                            log.info('The entire line is : {0}'.format(line))
                            syslog = 1
                    if syslog:
                        log.info('Tunnel-Encryption Session-Up syslog is received as expected.')
                    else:
                        log.error('Tunnel-Encryption Session-Up syslog is NOT received as expected')
                        result_flag = 1
                        session_up_flag =1                
            else:
                log.error('Unable to Set the Logging Level for tunnel-Encryption')
                self.failed()
                
            with steps.start('Waitig fot the traffic to converge After Nve Flap') as s:
                log.info('Waiting for 30 seconds before collecting the Traffic stats:')
                countDownTimer(60)
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    result_flag = 1
                    stat_flag = 1
            if result_flag:
                if session_down_flag:
                    log.error('Syslog message Not received during Tunnel-Encrypytion Down')
                if session_up_flag:
                    log.error('Syslog message Not received during Tunnel-Encrypytion Up')
                if stat_flag:
                    log.error('Traffic not recovered after flapping the nve ')
                self.failed()

# Verify feature enable and CloudSec Session Up
class VxlanCloudSec_Func014(aetest.Testcase):

    """ Vxlan CloudSec - Func-014"""

    uid = 'VXLAN-CS-FUNC-014'

    @aetest.test
    def VxlanCloudSec_VerifyTunnelUp_Func014(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test13:- Verify CloudSec Session Up'))
        
        result_flag = 1
        restore_flag = 0
        stat_flag = 0
        verify_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
            
            with steps.start('Remove Feature Tunnel-Encrpytion  - on BGWs') as s:
                log.info(banner('Remove Feature Tunnel-Encrpytion on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Removing feature Tunnel-Encrpytion on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature tunnel-encryption' )
                    if out.result=='fail':
                        log.error('Disable of Tunnel-Encrpytion failed on dut %s' % dut)
                        result_flag = 0
                        restore_flag = 1
                    else:
                        log.info('Disable of Tunnel-Encrpytion passes on dut %s' % dut)
                
            with steps.start('Checking the Traffic Stats after removing the feature tunnel-encryption') as s:
                log.info('Checking the Traffic Stats after removing the feature tunnel-encryption')
                log.info('Waiting for 30 seconds before measuring the Traffic stats')
                countDownTimer(60)
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                try:
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                except Exception:
                    log.info('No Raw Streams defined ... ')
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected after tunnel-encryption removal.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    try:
                        res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    except Exception:
                        log.info('No Raw Streams defined ... ')
                    result_flag=0
                    restore_flag = 1
                    stat_flag = 1

            with steps.start('Enable Feature Tunnel-Encrpytion  - on BGWs') as s:
                log.info(banner('Enable Feature Tunnel-Encrpytion on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Enable feature Tunnel-Encrpytion on dut : {0}'.format(dut)))
                    out=bringup_lib.configFeature(node_dict['all_dut'][dut], log, '-feature tunnel-encryption' )
                    if out.result=='fail':
                        log.error('Enable of Tunnel-Encrpytion failed on dut %s' % dut)
                        result_flag = 0
                        restore_flag = 1
                    else:
                        log.info('Enable of Tunnel-Encrpytion passes on dut %s' % dut)
                        
            with steps.start('Configure Tunnel-Encrpytion  - on BGWs') as s:
                log.info(banner('Configure Feature Tunnel-Encrpytion on duts {0}'.format(list(bgw_dict.keys()))))
                
                cloudsec_config_dict = configdict['cloudsec_config_dict']
                
                for dut in cloudsec_config_dict.keys():
                    obj_cs=MyLib.my_cloudsec_lib.configTunnelEncryption(cloudsec_config_dict,node_dict,alias_intf_mapping,log)
                    if not obj_cs.Nodes(dut):
                        restore_flag = 1
                        result_flag = 0
                        
            log.info(banner('waiting for 30 seconds before verifying the Cloudsec Session: '))
            countDownTimer(30)
                        
            with steps.start('Verify CloudSec Session across dut:') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    restore_flag = 1
                    result_flag = 0
                    verify_flag = 1
            
                
            with steps.start('Waitig fot the traffic to converge After Adding Tunnel-Encryption configs') as s:
                log.info('Waiting for 60 seconds before collecting the Traffic stats:')
                countDownTimer(60)
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                try:
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                except Exception:
                    log.info('No Raw Streams defined ... ')
                if not out:
                    log.error('The Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    try:
                        res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    except Exception:
                        log.info('No Raw Streams defined ... ')
                    result_flag = 0
                    stat_flag = 1
            with steps.start('Global-Verdict of Test case:') as s:
                log.info('Global-Verdict of Test Case')
                if not result_flag:
                    if verify_flag:
                        log.error('Tunnel_Encryption session was not Up. Hence Failing The test case')
                    if restore_flag:
                        for dut in bgw_dict.keys():
                            log.info(banner('Restoring  config on dut : {0}'.format(dut)))
                            res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                            if not res:
                                log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                                self.failed()
                    if stat_flag:
                        log.error('Traffic Check Failed. Refer Logs for details.')
                        out = trigger_obj.checkAllStreamStats(tgn_hdl)
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        try:
                            res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        except Exception:
                            log.info('No Raw Streams defined ... ')
                    self.failed()

# Verify CloudSec Session Up
class VxlanCloudSec_Func015(aetest.Testcase):

    """ Vxlan CloudSec - Func-015"""

    uid = 'VXLAN-CS-FUNC-015'

    @aetest.test
    def VxlanCloudSec_BUMTraffic_MustSecure_Func015(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test15:- Verify CloudSec Session Up'))
        
        config_flag = 0
        start_fail_stream = []
        stats_success_stream = []
        stats_fail_stream = []
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0

        
                
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                    
            with steps.start('Starting BUM Traffic') as s:
                log.info('Starting BUM Traffic')
                raw_traffic_list = [x for x in configured_stream if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list is : {0}'.format(raw_traffic_list))
                
                #raw_traffic_list = ['RAW004', 'RAW005', 'RAW003', 'RAW001', 'RAW002', 'RAW006']
                
                raw_traffic_list_from_cfgfile = [x for x in list(tgn_config_dict[TG].keys()) if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list_from_cfgfile is : {0}'.format(raw_traffic_list_from_cfgfile))
                           
                if len(raw_traffic_list) != len(raw_traffic_list_from_cfgfile):
                    for i in raw_traffic_list:
                        configured_stream.remove(i)
                        
                    config_flag = 1
                    
                else:
                    log.info('RAW Streams are already Created.')
                    
                    log.info(banner('Starting the Stream one by one...'))
                    
                    for item in raw_traffic_list:
                        log.info(banner('Starting the RAW Stream Created for this test . {0}'.format(item)))
                        x = tgn_hdl.traffic_control(action='run', handle = traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                        
                        if not x.status:
                            log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                            start_fail_stream.append(item)
                        
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                        
                    if start_fail_stream:
                        global_flag = 1
                        stream_start_flag = 1
                        
                        
                    log.info(banner('Measuring the Stats of Traffic Stream'))
                    for item in raw_traffic_list:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(15)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']  
                        exp_rx_traffic = res['tx'] * len(receiver_port)
                        log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                        
                        if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'], item)))
                            stats_fail_stream.append(item)
                    
                    if stats_fail_stream:
                        global_flag = 1
                        stream_stat_fail_flag = 1                        

                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
            

                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                        

            
                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
            
            
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
            
                    with steps.start('Configuring Raw Traffic -BUM') as s:
                        raw_traffic_dict = {}
                        raw_list  = []
                        fail_stream = []
                        for trf_item in tgn_config_dict[TG].keys():
                            if re.search('RAW', trf_item, re.IGNORECASE):
                                raw_list.append(trf_item)
                                
                        log.info(banner('The value of raw_list is : {0}'.format(raw_list)))
                                
                        for item in raw_list:
                            raw_traffic_dict[item] = {}
                            log.info('Creating Raw stream for traffic stream {0} as defined in Config File'.format(item))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            trf_args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            
                            src_port = [port_handle_dict[x] for x in source_port]
                            dst_port = [port_handle_dict[x] for x in receiver_port]
                            
                            raw_traffic_cfg = configureIxNetworkRawTrafficL2(self, trf_args, tg_hdl=tgn_hdl, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                            log.info('The value of ixia_traffic_config is : {0}'.format(raw_traffic_cfg))
        
                            if not raw_traffic_cfg.status:
                                log.error('The Raw stream {0} could not be generated'.format(item))
                                fail_stream.append(item)
                            else:
                                raw_traffic_dict[item]['source'] = source_port
                                raw_traffic_dict[item]['destination'] = receiver_port
                                raw_traffic_dict[item]['stream_id'] = raw_traffic_cfg['stream_id']
                                raw_traffic_dict[item]['status'] = raw_traffic_cfg['status']
                                raw_traffic_dict[item]['traffic_item'] = raw_traffic_cfg['traffic_item']
                        
                            if fail_stream:
                                global_flag  = 1
                                stream_create_flag  = 1

                
                    with steps.start('Starting the BUM Traffic Stream one by one') as s:
                        log.info(banner('Starting the BUM Traffic Stream one by one'))
                        countDownTimer(30)
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(raw_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))

                        
                        for item in raw_traffic_dict.keys():
                            ixia_stream = raw_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(receiver_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream RAW001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
                    
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(raw_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(raw_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(raw_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=raw_traffic_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
   
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify KUC-MustSecure
class VxlanCloudSec_Func016(aetest.Testcase):

    """ Vxlan CloudSec - Func-016"""

    uid = 'VXLAN-CS-FUNC-016'

    @aetest.test
    def VxlanCloudSec_KUCTraffic_MustSecure_Func016(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test16:- KUC-MustSecure'))
        
        config_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                    
            with steps.start('Starting KUC Traffic') as s:
                log.info('Starting KUC Traffic')
                kuc_traffic_list = ['TEST001']
                config_flag = 1
                 
                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    global_flag = 0
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
                
                    '''
                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]

                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
                        
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                    '''
                    
                    with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                        tgn_intf_dict = {}
                        for item in kuc_traffic_list:
                            tgn_intf_dict[item]={}
                            log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                            for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                                tgn_intf_dict[item][TGInt] = {}
                                args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                                ixia_traffic_config = configureL2StaticInterfaces(self,args,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                                if not ixia_traffic_config.status:
                                    log.error('Could not create Interfaces on Ixia')
                                    self.failed()
                                tgn_intf_dict[item][TGInt]['handle'] = ixia_traffic_config.interface_handle
                                tgn_intf_dict[item][TGInt]['status'] = ixia_traffic_config.status
                                tgn_intf_dict[item][TGInt]['lan_endpoints'] = ixia_traffic_config.lan_endpoints
                                
                        log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))

                    with steps.start('Creating Traffic Stream') as s:
                        new_traffic_dict = {}
                        for item in kuc_traffic_list:
                            emu_src_hdl_list = []
                            emu_dst_hdl_list = []
                            new_traffic_dict[item] = {}
                            log.info(banner('Creating Traffic on TGEN for Traffic Item :- {0}'.format(item)))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            dest_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            for port in source_port:
                                emu_src_hdl_list.append(tgn_intf_dict[item][port]['handle'])
                            for port in dest_port:
                                emu_dst_hdl_list.append(tgn_intf_dict[item][port]['handle'])                            

                            trf_cfg = configureIxNetworkTraffic(self, args,tg_hdl=tgn_hdl,emulation_src_handle=emu_src_hdl_list,emulation_dst_handle=emu_dst_hdl_list)
                            if not trf_cfg.status:
                                log.error('The Traffic Stream {0} could not be created.. '.format(item))
                                self.failed()
                            else:
                                new_traffic_dict[item]['source'] = source_port
                                new_traffic_dict[item]['destination'] = dest_port
                                new_traffic_dict[item]['stream_id'] = trf_cfg['stream_id']
                                new_traffic_dict[item]['status'] = trf_cfg['status']
                                new_traffic_dict[item]['traffic_item'] = trf_cfg['traffic_item']
                
                    with steps.start('Starting the KUC Traffic Stream one by one') as s:
                        log.info(banner('Starting the KUC Traffic Stream one by one'))
                        countDownTimer(30)
                        start_fail_stream = []
                        
                        for item in new_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_dict[item]['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(kuc_traffic_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))
                        stats_success_stream = []
                        stats_fail_stream = []
                        
                        for item in new_traffic_dict.keys():
                            ixia_stream = new_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(dest_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The KUC traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
                    
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in new_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(new_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(new_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            pass
                            '''
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(new_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_dict[item]['stream_id'])
                            '''
                    with steps.start('Starting All the Stream from the Global list ') as s:      
                        log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                        countDownTimer(30)
        
                        log.info('Starting all the other streams')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        
                        if not z:
                            log.error(banner('The Streams could not be started as expected '))
                            self.failed()
                
                    with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                        
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
        
                        out = trigger_obj.checkAllStreamStats(tgn_hdl)
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        
                        if not out:
                            log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            global_flag = 1
        
                        else:
                            log.info(banner('Cummulative Traffic flow is as expected.. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
                    with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                        if global_flag:
                            if stream_create_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                                self.failed()
                            elif stream_start_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                                self.failed()
                            elif stream_stat_fail_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                                self.failed()
                            elif stream_stop_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                                self.failed()
                            log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            countDownTimer(300)
                            self.failed()   

# Verify IPv6
class VxlanCloudSec_Func017(aetest.Testcase):

    """ Vxlan CloudSec - Func-017"""

    uid = 'VXLAN-CS-FUNC-017'

    @aetest.test
    def VxlanCloudSec_IPv6Traffic_Func017(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test17:- IPv6'))
        
        
        tgn_intf_dict = {}
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        stream_stop_flag = 0
        for TG in tgn_config_dict.keys():
            tgn_intf_dict[TG]= {}
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                
                traffic_list = ['TEST002','TEST003','TEST004','TEST005','TEST006']
                for item in traffic_list:
                    tgn_intf_dict[TG][item]= {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        tgn_intf_dict[TG][item][TGInt] = {}
                        ixia_intf_ip_list = []
                        ixia_intf_ipv6_list = []
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterfaceWithV6(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                            for b in ixia_interface_config['ipv6']:
                                log.info('The value of b is : {0}'.format(b))
                                ixia_intf_ipv6_list.append(b)
                                tgn_intf_dict[TG][item][TGInt][b]={}
                                tgn_intf_dict[TG][item][TGInt][b]['handle']=ixia_interface_config['ipv6'][b]

                        
                log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))
            
            with steps.start('Creating Traffic Streams for this test') as s:
                log.info('Creating Traffic Streams for this test')
                
                new_traffic_stream_dict = {}
                for item in traffic_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in tgn_intf_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][p]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][p][ipv6]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in tgn_intf_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][q]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][q][ipv6]['handle']
                                        dest_handle.append(handle)
                                        
                    i = sorted(src_handle)
                    j = sorted(dest_handle)
                        
                    log.info('The value of source_handle is : {0}'.format(i))
                    log.info('The value of dest_handle is : {0}'.format(j))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=i, emulation_dst_handle=j)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
        
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    pass
                    '''
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
                    '''
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify BUM Traffic -ShouldSecure
class VxlanCloudSec_Func018(aetest.Testcase):

    """ Vxlan CloudSec - Func-018"""

    uid = 'VXLAN-CS-FUNC-018'

    @aetest.test
    def VxlanCloudSec_BUMTraffic_ShouldSecure_Func018(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test18:- BUM Traffic -ShouldSecure'))
        
        config_flag = 0
        start_fail_stream = []
        stats_success_stream = []
        stats_fail_stream = []
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0

        
                
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                    
            with steps.start('Starting BUM Traffic') as s:
                log.info('Starting BUM Traffic')
                raw_traffic_list = [x for x in configured_stream if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list is : {0}'.format(raw_traffic_list))
                
                #raw_traffic_list = ['RAW004', 'RAW005', 'RAW003', 'RAW001', 'RAW002', 'RAW006']
                
                raw_traffic_list_from_cfgfile = [x for x in list(tgn_config_dict[TG].keys()) if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list_from_cfgfile is : {0}'.format(raw_traffic_list_from_cfgfile))
                           
                if len(raw_traffic_list) != len(raw_traffic_list_from_cfgfile):
                    for i in raw_traffic_list:
                        configured_stream.remove(i)
                        
                    config_flag = 1
                    
                else:
                    log.info('RAW Streams are already Created.')
                    
                    log.info(banner('Starting the Stream one by one...'))
                    
                    for item in raw_traffic_list:
                        log.info(banner('Starting the RAW Stream Created for this test . {0}'.format(item)))
                        x = tgn_hdl.traffic_control(action='run', handle = traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                        
                        if not x.status:
                            log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                            start_fail_stream.append(item)
                        
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                        
                    if start_fail_stream:
                        global_flag = 1
                        stream_start_flag = 1
                        
                        
                    log.info(banner('Measuring the Stats of Traffic Stream'))
                    for item in raw_traffic_list:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(15)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']  
                        exp_rx_traffic = res['tx'] * len(receiver_port)
                        log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                        
                        if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'], item)))
                            stats_fail_stream.append(item)
                    
                    if stats_fail_stream:
                        global_flag = 1
                        stream_stat_fail_flag = 1                        

                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
            

                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                        

            
                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
            
            
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
            
                    with steps.start('Configuring Raw Traffic -BUM') as s:
                        raw_traffic_dict = {}
                        raw_list  = []
                        fail_stream = []
                        for trf_item in tgn_config_dict[TG].keys():
                            if re.search('RAW', trf_item, re.IGNORECASE):
                                raw_list.append(trf_item)
                                
                        log.info(banner('The value of raw_list is : {0}'.format(raw_list)))
                                
                        for item in raw_list:
                            raw_traffic_dict[item] = {}
                            log.info('Creating Raw stream for traffic stream {0} as defined in Config File'.format(item))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            trf_args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            
                            src_port = [port_handle_dict[x] for x in source_port]
                            dst_port = [port_handle_dict[x] for x in receiver_port]
                            
                            raw_traffic_cfg = configureIxNetworkRawTrafficL2(self, trf_args, tg_hdl=tgn_hdl, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                            log.info('The value of ixia_traffic_config is : {0}'.format(raw_traffic_cfg))
        
                            if not raw_traffic_cfg.status:
                                log.error('The Raw stream {0} could not be generated'.format(item))
                                fail_stream.append(item)
                            else:
                                raw_traffic_dict[item]['source'] = source_port
                                raw_traffic_dict[item]['destination'] = receiver_port
                                raw_traffic_dict[item]['stream_id'] = raw_traffic_cfg['stream_id']
                                raw_traffic_dict[item]['status'] = raw_traffic_cfg['status']
                                raw_traffic_dict[item]['traffic_item'] = raw_traffic_cfg['traffic_item']
                        
                            if fail_stream:
                                global_flag  = 1
                                stream_create_flag  = 1

                
                    with steps.start('Starting the BUM Traffic Stream one by one') as s:
                        log.info(banner('Starting the BUM Traffic Stream one by one'))
                        countDownTimer(30)
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(raw_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))

                        
                        for item in raw_traffic_dict.keys():
                            ixia_stream = raw_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(receiver_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream RAW001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
                    
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(raw_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(raw_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(raw_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=raw_traffic_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
   
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify KUC-shouldSecure
class VxlanCloudSec_Func019(aetest.Testcase):

    """ Vxlan CloudSec - Func-019"""

    uid = 'VXLAN-CS-FUNC-019'

    @aetest.test
    def VxlanCloudSec_KUCTraffic_ShouldSecure_Func019(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test16:- KUC-shouldSecure'))
        
        config_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')
                    if re.search('Should', current_mode, re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                        
                    
            with steps.start('Starting KUC Traffic') as s:
                log.info('Starting KUC Traffic')
                kuc_traffic_list = ['TEST012']
                config_flag = 1
                 
                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 201
                    num_of_vlans = 100
                    vni_start = 100201
            
                    global_flag = 0
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
                
                    '''
                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]

                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
                        
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                    '''
                    
                    with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                        tgn_intf_dict = {}
                        for item in kuc_traffic_list:
                            tgn_intf_dict[item]={}
                            log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                            for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                                tgn_intf_dict[item][TGInt] = {}
                                args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                                ixia_traffic_config = configureL2StaticInterfaces(self,args,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                                if not ixia_traffic_config.status:
                                    log.error('Could not create Interfaces on Ixia')
                                    self.failed()
                                tgn_intf_dict[item][TGInt]['handle'] = ixia_traffic_config.interface_handle
                                tgn_intf_dict[item][TGInt]['status'] = ixia_traffic_config.status
                                tgn_intf_dict[item][TGInt]['lan_endpoints'] = ixia_traffic_config.lan_endpoints
                                
                        log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))

                    with steps.start('Creating Traffic Stream') as s:
                        new_traffic_dict = {}
                        for item in kuc_traffic_list:
                            emu_src_hdl_list = []
                            emu_dst_hdl_list = []
                            new_traffic_dict[item] = {}
                            log.info(banner('Creating Traffic on TGEN for Traffic Item :- {0}'.format(item)))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            dest_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            for port in source_port:
                                emu_src_hdl_list.append(tgn_intf_dict[item][port]['handle'])
                            for port in dest_port:
                                emu_dst_hdl_list.append(tgn_intf_dict[item][port]['handle'])                            

                            trf_cfg = configureIxNetworkTraffic(self, args,tg_hdl=tgn_hdl,emulation_src_handle=emu_src_hdl_list,emulation_dst_handle=emu_dst_hdl_list)
                            if not trf_cfg.status:
                                log.error('The Traffic Stream {0} could not be created.. '.format(item))
                                self.failed()
                            else:
                                new_traffic_dict[item]['source'] = source_port
                                new_traffic_dict[item]['destination'] = dest_port
                                new_traffic_dict[item]['stream_id'] = trf_cfg['stream_id']
                                new_traffic_dict[item]['status'] = trf_cfg['status']
                                new_traffic_dict[item]['traffic_item'] = trf_cfg['traffic_item']
                
                    with steps.start('Starting the KUC Traffic Stream one by one') as s:
                        log.info(banner('Starting the KUC Traffic Stream one by one'))
                        countDownTimer(30)
                        start_fail_stream = []
                        
                        for item in new_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_dict[item]['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(kuc_traffic_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))
                        stats_success_stream = []
                        stats_fail_stream = []
                        
                        for item in new_traffic_dict.keys():
                            ixia_stream = new_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(dest_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The KUC traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
                    
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in new_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(new_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(new_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            pass
                            '''
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(new_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_dict[item]['stream_id'])
                            '''
                    with steps.start('Starting All the Stream from the Global list ') as s:      
                        log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                        countDownTimer(30)
        
                        log.info('Starting all the other streams')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        
                        if not z:
                            log.error(banner('The Streams could not be started as expected '))
                            self.failed()
                
                    with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                        
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
        
                        out = trigger_obj.checkAllStreamStats(tgn_hdl)
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        
                        if not out:
                            log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            global_flag = 1
        
                        else:
                            log.info(banner('Cummulative Traffic flow is as expected.. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
                    with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                        if global_flag:
                            if stream_create_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                                self.failed()
                            elif stream_start_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                                self.failed()
                            elif stream_stat_fail_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                                self.failed()
                            elif stream_stop_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                                self.failed()
                            log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            countDownTimer(300)
                            self.failed()   

# Verify IPv6-Should SEcure
class VxlanCloudSec_Func020(aetest.Testcase):

    """ Vxlan CloudSec - Func-020-"""

    uid = 'VXLAN-CS-FUNC-020'

    @aetest.test
    def VxlanCloudSec_IPv6Traffic_ShouldSecure_Func020(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test20:- IPv6-Should SEcure'))
        
        
        tgn_intf_dict = {}
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        stream_stop_flag = 0
        for TG in tgn_config_dict.keys():
            tgn_intf_dict[TG]= {}
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')
                        
                    if re.search('Should', current_mode, re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))

            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                
                traffic_list = ['TEST007','TEST008','TEST009']
                for item in traffic_list:
                    tgn_intf_dict[TG][item]= {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        tgn_intf_dict[TG][item][TGInt] = {}
                        ixia_intf_ip_list = []
                        ixia_intf_ipv6_list = []
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterfaceWithV6(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                            for b in ixia_interface_config['ipv6']:
                                log.info('The value of b is : {0}'.format(b))
                                ixia_intf_ipv6_list.append(b)
                                tgn_intf_dict[TG][item][TGInt][b]={}
                                tgn_intf_dict[TG][item][TGInt][b]['handle']=ixia_interface_config['ipv6'][b]

                        
                log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))
            
            with steps.start('Creating Traffic Streams for this test') as s:
                log.info('Creating Traffic Streams for this test')
                
                new_traffic_stream_dict = {}
                for item in traffic_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in tgn_intf_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][p]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][p][ipv6]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in tgn_intf_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][q]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][q][ipv6]['handle']
                                        dest_handle.append(handle)
                                        
                    i = sorted(src_handle)
                    j = sorted(dest_handle)
                        
                    log.info('The value of source_handle is : {0}'.format(i))
                    log.info('The value of dest_handle is : {0}'.format(j))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=i, emulation_dst_handle=j)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
        
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    pass
                    '''
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
                    '''
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify BUM Traffic -ShouldSecure
class VxlanCloudSec_Func021(aetest.Testcase):

    """ Vxlan CloudSec - Func-021"""

    uid = 'VXLAN-CS-FUNC-021'

    @aetest.test
    def VxlanCloudSec_BUMTraffic_CS_Legacy_Func021(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test18:- BUM Traffic -ShouldSecure'))
        
        config_flag = 0
        start_fail_stream = []
        stats_success_stream = []
        stats_fail_stream = []
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        trigger_flag = 0
        trigger_fail_stream = []

        
                
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()            

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                    
            with steps.start('Starting BUM Traffic') as s:
                log.info('Starting BUM Traffic')
                raw_traffic_list = [x for x in configured_stream if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list is : {0}'.format(raw_traffic_list))
                
                #raw_traffic_list = ['RAW004', 'RAW005', 'RAW003', 'RAW001', 'RAW002', 'RAW006']
                
                raw_traffic_list_from_cfgfile = [x for x in list(tgn_config_dict[TG].keys()) if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list_from_cfgfile is : {0}'.format(raw_traffic_list_from_cfgfile))
                           
                if len(raw_traffic_list) != len(raw_traffic_list_from_cfgfile):
                    for i in raw_traffic_list:
                        configured_stream.remove(i)
                        
                    config_flag = 1
                    
                else:
                    log.info('RAW Streams are already Created.')
                    
                    log.info(banner('Starting the Stream one by one...'))
                    
                    for item in raw_traffic_list:
                        log.info(banner('Starting the RAW Stream Created for this test . {0}'.format(item)))
                        x = tgn_hdl.traffic_control(action='run', handle = traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                        
                        if not x.status:
                            log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                            start_fail_stream.append(item)
                        
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                        
                    if start_fail_stream:
                        global_flag = 1
                        stream_start_flag = 1
                        
                        
                    log.info(banner('Measuring the Stats of Traffic Stream'))
                    for item in raw_traffic_list:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(15)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']  
                        exp_rx_traffic = res['tx'] * len(receiver_port)
                        log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                        
                        if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'], item)))
                            stats_fail_stream.append(item)
                    
                    if stats_fail_stream:
                        global_flag = 1
                        stream_stat_fail_flag = 1                        

                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
            
                    '''
                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                        

            
                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
            
            
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                    
                    '''
            
                    with steps.start('Configuring Raw Traffic -BUM') as s:
                        raw_traffic_dict = {}
                        raw_list  = []
                        fail_stream = []
                        for trf_item in tgn_config_dict[TG].keys():
                            if re.search('RAW', trf_item, re.IGNORECASE):
                                raw_list.append(trf_item)
                                
                        log.info(banner('The value of raw_list is : {0}'.format(raw_list)))
                                
                                
                        #raw_list = ['RAW001']
                        for item in raw_list:
                            raw_traffic_dict[item] = {}
                            log.info('Creating Raw stream for traffic stream {0} as defined in Config File'.format(item))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            trf_args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            
                            src_port = [port_handle_dict[x] for x in source_port]
                            dst_port = [port_handle_dict[x] for x in receiver_port]
                            
                            raw_traffic_cfg = configureIxNetworkRawTrafficL2(self, trf_args, tg_hdl=tgn_hdl, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                            log.info('The value of ixia_traffic_config is : {0}'.format(raw_traffic_cfg))
        
                            if not raw_traffic_cfg.status:
                                log.error('The Raw stream {0} could not be generated'.format(item))
                                fail_stream.append(item)
                            else:
                                raw_traffic_dict[item]['source'] = source_port
                                raw_traffic_dict[item]['destination'] = receiver_port
                                raw_traffic_dict[item]['stream_id'] = raw_traffic_cfg['stream_id']
                                raw_traffic_dict[item]['status'] = raw_traffic_cfg['status']
                                raw_traffic_dict[item]['traffic_item'] = raw_traffic_cfg['traffic_item']
                        
                            if fail_stream:
                                global_flag  = 1
                                stream_create_flag  = 1

                
                    with steps.start('Starting the BUM Traffic Stream one by one') as s:
                        log.info(banner('Starting the BUM Traffic Stream one by one'))
                        countDownTimer(30)
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(raw_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))

                        
                        for item in raw_traffic_dict.keys():
                            ixia_stream = raw_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(receiver_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream RAW001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
   
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(raw_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(raw_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(raw_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=raw_traffic_dict[item]['stream_id'])
            

            with steps.start('Site1 - CloudSec - Site2 - Legacy') as s:
                log.info('Site1 - CloudSec - Site2 - Legacy')
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                site1_hdl.configure('tunnel-encryption must-secure-policy')
                out=bringup_lib.unconfigFeature(site2_hdl, log, '-feature tunnel-encryption' )
                if out.result=='fail':
                    log.error('Disable of Tunnel-Encrpytion failed on dut %s' % site2_dut)
                else:
                    log.info('Disable of Tunnel-Encrpytion passes on dut %s' % site2_dut)
                    
                log.info('Waiting for 30 seconds before Measureing the Traffic:')
                countDownTimer(30)
 

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                    
            with steps.start('Measuring stats on all Streams from the Global list ') as s:      
                log.info(banner('Waiting for 10 seconds before starting all the streams..'))
                countDownTimer(10)                        
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] !=0 and res['rx'] == 0:
                        log.info('Traffic Drop is as expected on stream {0}'.format(item))
                    elif res['tx'] ==0 and res['rx'] == 0:
                        log.info('Traffic was not sent on stream {0}'.format(item))
                    else:
                        log.error('Traffic drop was expected ')
                        trigger_fail_stream.append(item)
                        global_flag = 1
                        trigger_flag = 1

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()            
        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(60)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
   
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify CS-Legacy
class VxlanCloudSec_Func022(aetest.Testcase):

    """ Vxlan CloudSec - Func-022"""

    uid = 'VXLAN-CS-FUNC-022'

    @aetest.test
    def VxlanCloudSec_KUCTraffic_CS_Legacy_Func022(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test22:- CS-Legacy'))
        
        config_flag = 0
        trigger_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy')
                    
            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()            

            with steps.start('Starting KUC Traffic') as s:
                log.info('Starting KUC Traffic')
                kuc_traffic_list = ['TEST013']
                config_flag = 1
                 
                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    global_flag = 0
                    trigger_flag = 0
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
                
                    '''
                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]

                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
                        
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                    '''
                    
                    with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                        tgn_intf_dict = {}
                        for item in kuc_traffic_list:
                            tgn_intf_dict[item]={}
                            log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                            for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                                tgn_intf_dict[item][TGInt] = {}
                                args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                                ixia_traffic_config = configureL2StaticInterfaces(self,args,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                                if not ixia_traffic_config.status:
                                    log.error('Could not create Interfaces on Ixia')
                                    self.failed()
                                tgn_intf_dict[item][TGInt]['handle'] = ixia_traffic_config.interface_handle
                                tgn_intf_dict[item][TGInt]['status'] = ixia_traffic_config.status
                                tgn_intf_dict[item][TGInt]['lan_endpoints'] = ixia_traffic_config.lan_endpoints
                                
                        log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))

                    with steps.start('Creating Traffic Stream') as s:
                        new_traffic_dict = {}
                        for item in kuc_traffic_list:
                            emu_src_hdl_list = []
                            emu_dst_hdl_list = []
                            new_traffic_dict[item] = {}
                            log.info(banner('Creating Traffic on TGEN for Traffic Item :- {0}'.format(item)))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            dest_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            for port in source_port:
                                emu_src_hdl_list.append(tgn_intf_dict[item][port]['handle'])
                            for port in dest_port:
                                emu_dst_hdl_list.append(tgn_intf_dict[item][port]['handle'])                            

                            trf_cfg = configureIxNetworkTraffic(self, args,tg_hdl=tgn_hdl,emulation_src_handle=emu_src_hdl_list,emulation_dst_handle=emu_dst_hdl_list)
                            if not trf_cfg.status:
                                log.error('The Traffic Stream {0} could not be created.. '.format(item))
                                self.failed()
                            else:
                                new_traffic_dict[item]['source'] = source_port
                                new_traffic_dict[item]['destination'] = dest_port
                                new_traffic_dict[item]['stream_id'] = trf_cfg['stream_id']
                                new_traffic_dict[item]['status'] = trf_cfg['status']
                                new_traffic_dict[item]['traffic_item'] = trf_cfg['traffic_item']
                
                    with steps.start('Starting the KUC Traffic Stream one by one') as s:
                        log.info(banner('Starting the KUC Traffic Stream one by one'))
                        countDownTimer(30)
                        start_fail_stream = []
                        
                        for item in new_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_dict[item]['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(kuc_traffic_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))
                        stats_success_stream = []
                        stats_fail_stream = []
                        
                        for item in new_traffic_dict.keys():
                            ixia_stream = new_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(dest_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The KUC traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
                    
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in new_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(new_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(new_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            
                            
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(new_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_dict[item]['stream_id'])
                    
                    with steps.start('Site1 - CloudSec - Site2 - Legacy') as s:
                        log.info('Site1 - CloudSec - Site2 - Legacy')
                        
                        site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                        site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                        site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                        site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                        
                        site1_hdl.configure('tunnel-encryption must-secure-policy')
                        out=bringup_lib.unconfigFeature(site2_hdl, log, '-feature tunnel-encryption' )
                        if out.result=='fail':
                            log.error('Disable of Tunnel-Encrpytion failed on dut %s' % site2_dut)
                        else:
                            log.info('Disable of Tunnel-Encrpytion passes on dut %s' % site2_dut)
                            
                        log.info('Waiting for 30 seconds before Measureing the Traffic:')
                        countDownTimer(30)
                            
                            
                    with steps.start('Starting All the Stream from the Global list ') as s:      
                        log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                        countDownTimer(30)
        
                        log.info('Starting all the other streams')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        
                        if not z:
                            log.error(banner('The Streams could not be started as expected '))
                            self.failed()
                        
                    with steps.start('Measuring stats on all Streams from the Global list ') as s:      
                        log.info(banner('Waiting for 10 seconds before starting all the streams..'))
                        countDownTimer(10)                        
                        for item in configured_stream:
                            ixia_stream = traffic_stream_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            if res['tx'] !=0 and res['rx'] == 0:
                                log.info('Traffic Drop is as expected on stream {0}'.format(item))
                            else:
                                log.error('Traffic drop was expected ')
                                trigger_fail_stream.append(item)
                                global_flag = 1
                                trigger_flag = 1


                    with steps.start('Backup Configs - on BGWs') as s:
                        log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                        
                        for dut in bgw_dict.keys():
                            log.info(banner('Backing up config on dut : {0}'.format(dut)))
                            res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                            if not res:
                                log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                                self.failed()        
                   
                    with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                        
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
        
                        out = trigger_obj.checkAllStreamStats(tgn_hdl)
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        
                        if not out:
                            log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            global_flag = 1
        
                        else:
                            log.info(banner('Cummulative Traffic flow is as expected.. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
                    with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                        if global_flag:
                            if stream_create_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                                self.failed()
                            elif stream_start_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                                self.failed()
                            elif stream_stat_fail_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                                self.failed()
                            elif stream_stop_flag:
                                log.info('Starting all the streams from global list:')
                                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                                countDownTimer(30)
                                log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                                self.failed()
                            elif trigger_flag:
                                log.error('Traffic drop was expected but Traffic was seen')
                                log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                            log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            countDownTimer(300)
                            self.failed()   

# Verify IPv6-CS_MustSecure-Legacy
class VxlanCloudSec_Func023(aetest.Testcase):

    """ Vxlan CloudSec - Func-023-"""

    uid = 'VXLAN-CS-FUNC-023'

    @aetest.test
    def VxlanCloudSec_IPv6Traffic_CS_MustSecure_Legacy_Func023(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test20:- IPv6-CS_MustSecure-Legacy'))
        
        
        tgn_intf_dict = {}
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        stream_stop_flag = 0
        trigger_fail_stream = []
        trigger_flag = 0
        
        for TG in tgn_config_dict.keys():
            tgn_intf_dict[TG]= {}
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                        
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()                        
            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                
                traffic_list = ['TEST010']
                for item in traffic_list:
                    tgn_intf_dict[TG][item]= {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        tgn_intf_dict[TG][item][TGInt] = {}
                        ixia_intf_ip_list = []
                        ixia_intf_ipv6_list = []
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterfaceWithV6(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                            for b in ixia_interface_config['ipv6']:
                                log.info('The value of b is : {0}'.format(b))
                                ixia_intf_ipv6_list.append(b)
                                tgn_intf_dict[TG][item][TGInt][b]={}
                                tgn_intf_dict[TG][item][TGInt][b]['handle']=ixia_interface_config['ipv6'][b]

                        
                log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))
            
            with steps.start('Creating Traffic Streams for this test') as s:
                log.info('Creating Traffic Streams for this test')
                
                new_traffic_stream_dict = {}
                for item in traffic_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in tgn_intf_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][p]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][p][ipv6]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in tgn_intf_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][q]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][q][ipv6]['handle']
                                        dest_handle.append(handle)
                                        
                    i = sorted(src_handle)
                    j = sorted(dest_handle)
                        
                    log.info('The value of source_handle is : {0}'.format(i))
                    log.info('The value of dest_handle is : {0}'.format(j))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=i, emulation_dst_handle=j)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
        
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    
                    
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
                    
            with steps.start('Site1 - CloudSec - Site2 - Legacy') as s:
                log.info('Site1 - CloudSec - Site2 - Legacy')
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                site1_hdl.configure('tunnel-encryption must-secure-policy')
                out=bringup_lib.unconfigFeature(site2_hdl, log, '-feature tunnel-encryption' )
                if out.result=='fail':
                    log.error('Disable of Tunnel-Encrpytion failed on dut %s' % site2_dut)
                else:
                    log.info('Disable of Tunnel-Encrpytion passes on dut %s' % site2_dut)
                    
                log.info('Waiting for 30 seconds before Measureing the Traffic:')
                countDownTimer(30)
                
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
 
            with steps.start('Measuring stats on all Streams from the Global list ') as s:      
                log.info(banner('Waiting for 10 seconds before starting all the streams..'))
                countDownTimer(10)                        
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] !=0 and res['rx'] == 0:
                        log.info('Traffic Drop is as expected on stream {0}'.format(item))
                    else:
                        log.error('Traffic drop was expected ')
                        trigger_fail_stream.append(item)
                        global_flag = 1
                        trigger_flag = 1

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify BUM Traffic -ShouldSecure - Legacy
class VxlanCloudSec_Func024(aetest.Testcase):

    """ Vxlan CloudSec - Func-024"""

    uid = 'VXLAN-CS-FUNC-024'

    @aetest.test
    def VxlanCloudSec_BUMTraffic_CS_ShouldSecure_Legacy_Func021(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test24:- BUM Traffic -ShouldSecure - Legacy'))
        
        config_flag = 0
        start_fail_stream = []
        stats_success_stream = []
        stats_fail_stream = []
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        trigger_flag = 0
        trigger_fail_stream = []

        
                
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
    

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')
                        
                    if re.search('Should', current_mode, re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
                    
            with steps.start('Starting BUM Traffic') as s:
                log.info('Starting BUM Traffic')
                raw_traffic_list = [x for x in configured_stream if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list is : {0}'.format(raw_traffic_list))
                
                #raw_traffic_list = ['RAW004', 'RAW005', 'RAW003', 'RAW001', 'RAW002', 'RAW006']
                
                raw_traffic_list_from_cfgfile = [x for x in list(tgn_config_dict[TG].keys()) if re.search('RAW',x, re.I)]
                log.info('The value of raw_traffic_list_from_cfgfile is : {0}'.format(raw_traffic_list_from_cfgfile))
                           
                if len(raw_traffic_list) != len(raw_traffic_list_from_cfgfile):
                    for i in raw_traffic_list:
                        configured_stream.remove(i)
                        
                    config_flag = 1
                    
                else:
                    log.info('RAW Streams are already Created.')
                    
                    log.info(banner('Starting the Stream one by one...'))
                    
                    for item in raw_traffic_list:
                        log.info(banner('Starting the RAW Stream Created for this test . {0}'.format(item)))
                        x = tgn_hdl.traffic_control(action='run', handle = traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                        
                        if not x.status:
                            log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                            start_fail_stream.append(item)
                        
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                        
                    if start_fail_stream:
                        global_flag = 1
                        stream_start_flag = 1
                        
                        
                    log.info(banner('Measuring the Stats of Traffic Stream'))
                    for item in raw_traffic_list:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(15)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']  
                        exp_rx_traffic = res['tx'] * len(receiver_port)
                        log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                        
                        if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'], item)))
                            stats_fail_stream.append(item)
                    
                    if stats_fail_stream:
                        global_flag = 1
                        stream_stat_fail_flag = 1                        

                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
            
                    '''
                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                        

            
                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
            
            
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                    
                    '''
            
                    with steps.start('Configuring Raw Traffic -BUM') as s:
                        raw_traffic_dict = {}
                        raw_list  = []
                        fail_stream = []
                        for trf_item in tgn_config_dict[TG].keys():
                            if re.search('RAW', trf_item, re.IGNORECASE):
                                raw_list.append(trf_item)
                                
                        log.info(banner('The value of raw_list is : {0}'.format(raw_list)))
                                
                                
                        #raw_list = ['RAW001']
                        for item in raw_list:
                            raw_traffic_dict[item] = {}
                            log.info('Creating Raw stream for traffic stream {0} as defined in Config File'.format(item))
                            source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                            receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                            trf_args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                            
                            src_port = [port_handle_dict[x] for x in source_port]
                            dst_port = [port_handle_dict[x] for x in receiver_port]
                            
                            raw_traffic_cfg = configureIxNetworkRawTrafficL2(self, trf_args, tg_hdl=tgn_hdl, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                            log.info('The value of ixia_traffic_config is : {0}'.format(raw_traffic_cfg))
        
                            if not raw_traffic_cfg.status:
                                log.error('The Raw stream {0} could not be generated'.format(item))
                                fail_stream.append(item)
                            else:
                                raw_traffic_dict[item]['source'] = source_port
                                raw_traffic_dict[item]['destination'] = receiver_port
                                raw_traffic_dict[item]['stream_id'] = raw_traffic_cfg['stream_id']
                                raw_traffic_dict[item]['status'] = raw_traffic_cfg['status']
                                raw_traffic_dict[item]['traffic_item'] = raw_traffic_cfg['traffic_item']
                        
                            if fail_stream:
                                global_flag  = 1
                                stream_create_flag  = 1

                
                    with steps.start('Starting the BUM Traffic Stream one by one') as s:
                        log.info(banner('Starting the BUM Traffic Stream one by one'))
                        countDownTimer(30)
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                            x = tgn_hdl.traffic_control(action='run', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            
                            if not x.status:
                                log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                                start_fail_stream.append(item)
                            
                            if len(raw_list) > 1:
                                log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                                countDownTimer(10)
                            
                                
                        if start_fail_stream:
                            global_flag  = 1
                            stream_start_flag = 1
                
                    with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                        log.info(banner('Measuring Traffic Stats on Stream one by one'))

                        
                        for item in raw_traffic_dict.keys():
                            ixia_stream = raw_traffic_dict[item]['stream_id']
                            log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                            countDownTimer(15)
                            res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                            log.info(banner('The Value of res is: {0}'.format(res)))
                            
                            exp_rx_traffic = res['tx'] * len(receiver_port)
                            log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                            
                            if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                                log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                                stats_success_stream.append(item)
                            else:
                                log.error(banner('Traffic on Stream RAW001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                                stats_fail_stream.append(item)
                                
                        if stats_fail_stream:
                            log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                            global_flag = 1
                            stream_stat_fail_flag = 1
   
                    with steps.start('Stopping All the Newly Created streams: {0}'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        stop_fail_stream_list = []
                        
                        for item in raw_traffic_dict.keys():
                            log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(raw_traffic_dict[item]['stream_id'],item)))
                            x1 = tgn_hdl.traffic_control(action='stop', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                            log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                            countDownTimer(15)
                        
                            if not x1.status:
                                log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                                stop_fail_stream_list.append(item)
                        if stop_fail_stream_list:
                            log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                            global_flag = 1
                            stream_stop_flag = 1
            
                    with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(raw_traffic_dict.keys()))) as s:
                        
                        if stats_success_stream:
                            for item in stats_success_stream:
        
                                log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                                traffic_stream_dict.setdefault(item,{})
                                traffic_stream_dict[item].update(raw_traffic_dict[item])
                                log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                                log.info(banner('Adding the New stream to the configured stream list :'))
                                configured_stream.append(item)
                                log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                                testscript.parameters['configured_stream'] = configured_stream
                                testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                        elif stats_fail_stream:
                            for item in stats_fail_stream:
                                log.info('Removing the stream {0}:'.format(raw_traffic_dict[item]['stream_id']))
                                y = tgn_hdl.traffic_config(mode='remove',stream_id=raw_traffic_dict[item]['stream_id'])
            

            with steps.start('Site1 - CloudSec - Site2 - Legacy') as s:
                log.info('Site1 - CloudSec - Site2 - Legacy')
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                site1_hdl.configure('tunnel-encryption must-secure-policy')
                out=bringup_lib.unconfigFeature(site2_hdl, log, '-feature tunnel-encryption' )
                if out.result=='fail':
                    log.error('Disable of Tunnel-Encrpytion failed on dut %s' % site2_dut)
                else:
                    log.info('Disable of Tunnel-Encrpytion passes on dut %s' % site2_dut)
                    
                log.info('Waiting for 30 seconds before Measureing the Traffic:')
                countDownTimer(30)
 

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                    
            with steps.start('Measuring stats on all Streams from the Global list ') as s:      
                log.info(banner('Waiting for 10 seconds before starting all the streams..'))
                countDownTimer(10)                        
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] !=0 and res['rx'] == 0:
                        log.info('Traffic Drop is as expected on stream {0}'.format(item))
                    elif res['tx'] ==0 and res['rx'] == 0:
                        log.info('Traffic was not sent on stream {0}'.format(item))
                    else:
                        log.error('Traffic drop was expected ')
                        trigger_fail_stream.append(item)
                        global_flag = 1
                        trigger_flag = 1

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()            
        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(60)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
   
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify CS-ShouldSecure - Legacy
class VxlanCloudSec_Func025(aetest.Testcase):

    """ Vxlan CloudSec - Func-025"""

    uid = 'VXLAN-CS-FUNC-025'

    @aetest.test
    def VxlanCloudSec_KUCTraffic_CS_ShouldSecure_Legacy_Func025(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test25:- CS-ShouldSecure - Legacy'))
        
        config_flag = 0
        trigger_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy')
                    if re.search('Should', current_mode, re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    
            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()            

            with steps.start('Getting KUC Traffic') as s:
                log.info('Getting KUC Traffic')
                kuc_traffic_list = ['TEST014']
                config_flag = 1
                 
                if config_flag:
                    vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
                    vlan_start = 101
                    num_of_vlans = 100
                    vni_start = 100101
            
                    global_flag = 0
                    trigger_flag = 0
                    stream_create_flag = 0
                    stream_start_flag = 0
                    stream_stat_fail_flag = 0
                    stream_stop_flag = 0
                    log.info("Got the KUC Traffic details")
                else:
                    log.error(banner('Failed to get the KUC Traffic details'))
                    self.failed()            
                
                    '''
                    with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                        log.info('Configuring the vlans required for the tests in all VTEPs')
                    
                        log.info(banner('Configuring the Vlans on all VTEPs'))
                                        
                        args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                                 args = [log, vtep_dict[dut], args])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]

                        testscript.parameters['bridge_vlan_start'] = vlan_start
                        testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                        testscript.parameters['bridge_vni_start'] = vni_start
                        
                    with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                        
                        evpn_config_dict = {}
                        for dut in vtep_dict:
                            evpn_config_dict[dut]={}
                            evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)                
                        
                        log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                        
                        new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                        log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = evpn_lib.configEvpn,
                                                 args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                
                
                    with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                        log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                        args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_ir True -multisite_ir True'.format(num_of_vlans,vni_start) 
                        
                        threads = []
                        for dut in vtep_dict:
                            t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                                 args = [dut,node_dict['all_dut'][dut],args,log])
                            t.start()
                            threads.append(t)
                        [thread.join() for thread in threads]
                    '''
                    
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                tgn_intf_dict = {}
                for item in kuc_traffic_list:
                    tgn_intf_dict[item]={}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        tgn_intf_dict[item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        ixia_traffic_config = configureL2StaticInterfaces(self,args,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                        if not ixia_traffic_config.status:
                            log.error('Could not create Interfaces on Ixia')
                            self.failed()
                        tgn_intf_dict[item][TGInt]['handle'] = ixia_traffic_config.interface_handle
                        tgn_intf_dict[item][TGInt]['status'] = ixia_traffic_config.status
                        tgn_intf_dict[item][TGInt]['lan_endpoints'] = ixia_traffic_config.lan_endpoints
                        
                log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))

            with steps.start('Creating Traffic Stream') as s:
                new_traffic_dict = {}
                for item in kuc_traffic_list:
                    emu_src_hdl_list = []
                    emu_dst_hdl_list = []
                    new_traffic_dict[item] = {}
                    log.info(banner('Creating Traffic on TGEN for Traffic Item :- {0}'.format(item)))
                    source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    dest_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source_port:
                        emu_src_hdl_list.append(tgn_intf_dict[item][port]['handle'])
                    for port in dest_port:
                        emu_dst_hdl_list.append(tgn_intf_dict[item][port]['handle'])                            

                    trf_cfg = configureIxNetworkTraffic(self, args,tg_hdl=tgn_hdl,emulation_src_handle=emu_src_hdl_list,emulation_dst_handle=emu_dst_hdl_list)
                    if not trf_cfg.status:
                        log.error('The Traffic Stream {0} could not be created.. '.format(item))
                        self.failed()
                    else:
                        new_traffic_dict[item]['source'] = source_port
                        new_traffic_dict[item]['destination'] = dest_port
                        new_traffic_dict[item]['stream_id'] = trf_cfg['stream_id']
                        new_traffic_dict[item]['status'] = trf_cfg['status']
                        new_traffic_dict[item]['traffic_item'] = trf_cfg['traffic_item']
        
            with steps.start('Starting the KUC Traffic Stream one by one') as s:
                log.info(banner('Starting the KUC Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_dict[item]['stream_id'])))
                        start_fail_stream.append(item)
                    
                    if len(kuc_traffic_list) > 1:
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                    
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_dict.keys():
                    ixia_stream = new_traffic_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    exp_rx_traffic = res['tx'] * len(dest_port)
                    log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                    
                    if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                        log.info('The KUC traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
            
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(new_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
    
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    
                    
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_dict[item]['stream_id'])
            
            with steps.start('Site1 - CloudSec - Site2 - Legacy') as s:
                log.info('Site1 - CloudSec - Site2 - Legacy')
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                site1_hdl.configure('tunnel-encryption must-secure-policy')
                out=bringup_lib.unconfigFeature(site2_hdl, log, '-feature tunnel-encryption' )
                if out.result=='fail':
                    log.error('Disable of Tunnel-Encrpytion failed on dut %s' % site2_dut)
                else:
                    log.info('Disable of Tunnel-Encrpytion passes on dut %s' % site2_dut)
                    
                log.info('Waiting for 30 seconds before Measureing the Traffic:')
                countDownTimer(30)
                    
                    
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring stats on all Streams from the Global list ') as s:      
                log.info(banner('Waiting for 10 seconds before starting all the streams..'))
                countDownTimer(10)                        
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] !=0 and res['rx'] == 0:
                        log.info('Traffic Drop is as expected on stream {0}'.format(item))
                    else:
                        log.error('Traffic drop was expected ')
                        trigger_fail_stream.append(item)
                        global_flag = 1
                        trigger_flag = 1


            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 120 seconds for the traffic to Converge'))
                countDownTimer(120)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify IPv6-Should SEcure - Legacy
class VxlanCloudSec_Func026(aetest.Testcase):

    """ Vxlan CloudSec - Func-026-"""

    uid = 'VXLAN-CS-FUNC-026'

    @aetest.test
    def VxlanCloudSec_IPv6Traffic_ShouldSecure_Func026(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test26:- IPv6-Should SEcure - Legacy'))
        
        
        tgn_intf_dict = {}
        global_flag = 0
        stream_create_flag = 0
        stream_start_flag = 0
        stream_stat_fail_flag = 0
        stream_stop_flag = 0
        trigger_fail_stream = []
        trigger_flag = 0
        
        for TG in tgn_config_dict.keys():
            tgn_intf_dict[TG]= {}
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')
                        
                        
                    if re.search('Should', current_mode, re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()                        
            
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                
                traffic_list = ['TEST011']
                for item in traffic_list:
                    tgn_intf_dict[TG][item]= {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        tgn_intf_dict[TG][item][TGInt] = {}
                        ixia_intf_ip_list = []
                        ixia_intf_ipv6_list = []
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterfaceWithV6(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                            for b in ixia_interface_config['ipv6']:
                                log.info('The value of b is : {0}'.format(b))
                                ixia_intf_ipv6_list.append(b)
                                tgn_intf_dict[TG][item][TGInt][b]={}
                                tgn_intf_dict[TG][item][TGInt][b]['handle']=ixia_interface_config['ipv6'][b]

                        
                log.info('The value of tgn_intf_dict is : \n{0}'.format(yaml.dump(tgn_intf_dict)))
            
            with steps.start('Creating Traffic Streams for this test') as s:
                log.info('Creating Traffic Streams for this test')
                
                new_traffic_stream_dict = {}
                for item in traffic_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in tgn_intf_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][p]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][p][ipv6]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in tgn_intf_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}\:[a-f0-9]{1,4}$")
                                 for ipv6 in tgn_intf_dict[TG][item][q]:
                                    test = pat.match(ipv6)
                                    if test:
                                        handle = tgn_intf_dict[TG][item][q][ipv6]['handle']
                                        dest_handle.append(handle)
                                        
                    i = sorted(src_handle)
                    j = sorted(dest_handle)
                        
                    log.info('The value of source_handle is : {0}'.format(i))
                    log.info('The value of dest_handle is : {0}'.format(j))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=i, emulation_dst_handle=j)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
        
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(new_traffic_stream_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    
                    
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
                    
            with steps.start('Site1 - CloudSec - Site2 - Legacy') as s:
                log.info('Site1 - CloudSec - Site2 - Legacy')
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                site1_hdl.configure('tunnel-encryption must-secure-policy')
                out=bringup_lib.unconfigFeature(site2_hdl, log, '-feature tunnel-encryption' )
                if out.result=='fail':
                    log.error('Disable of Tunnel-Encrpytion failed on dut %s' % site2_dut)
                else:
                    log.info('Disable of Tunnel-Encrpytion passes on dut %s' % site2_dut)
                    
                log.info('Waiting for 30 seconds before Measureing the Traffic:')
                countDownTimer(30)
                
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
 
            with steps.start('Measuring stats on all Streams from the Global list ') as s:      
                log.info(banner('Waiting for 10 seconds before starting all the streams..'))
                countDownTimer(10)                        
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] !=0 and res['rx'] == 0:
                        log.info('Traffic Drop is as expected on stream {0}'.format(item))
                    else:
                        log.error('Traffic drop was expected ')
                        trigger_fail_stream.append(item)
                        global_flag = 1
                        trigger_flag = 1

            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Uplink Conversion - PO - Must Secure
class VxlanCloudSec_Func027(aetest.Testcase):

    """ Vxlan CloudSec - Func-027-"""

    uid = 'VXLAN-CS-FUNC-027'

    @aetest.test
    def VxlanCloudSec_DCIInterface_PortChannel_Func027(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test27:- Uplink Conversion - PO - Must Secure'))
        
        
        global_flag = 0
        stream_stat_fail_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        phy_conversion_flag = 0
        po_conversion_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-001']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Defaulting the interfaces on BGWs') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in bgw_dict.keys():
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in dci_boxes:
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
                            
            with steps.start('Defaulting the interfaces on DCI Cores') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in dci_boxes:
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in list(bgw_dict.keys()):
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
            
            with steps.start('Configuring Port-channel on all the boxes') as s:
                for dut in port_channel_dict:
                    log.info('the value of dut  inside scripts is : {0}'.format(dut))
                    hdl = node_dict['all_dut'][dut]
                    for intf in port_channel_dict[dut].keys():
                        log.info('the value of intf  inside scripts is : {0}'.format(intf))
                        args = port_channel_dict[dut][intf]
                        log.info('the value of args  inside scripts is : {0}'.format(args))
                        res = trigger_obj.configurePo(hdl,intf,args)
                        
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream_post_trigger.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream_post_trigger.append(item)
                        
                if stats_fail_stream_post_trigger:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    po_conversion_flag = 1
                    
            log.info(banner('Converting the Interface back to Physical Interface'))
            
 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 180 seconds before measuring the Traffic Convergence')
            countDownTimer(180)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    phy_conversion_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if po_conversion_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after PO Conversion'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if phy_conversion_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Physical Interface Conversion'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
            
# MustSecure To ShouldSecure
class VxlanCloudSec_Func028(aetest.Testcase):

    """ Vxlan CloudSec - Func-028"""

    uid = 'VXLAN-CS-FUNC-028'

    @aetest.test
    def VxlanCloudSec_DCIInterface_PO_ShouldSecure_Func028(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test29:- MustSecure To ShouldSecure'))
        
        
        global_flag = 0
        stream_stat_fail_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        phy_conversion_flag = 0
        po_conversion_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-001']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')                    
                    if re.search('Should', current_mode, re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Defaulting the interfaces on BGWs') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in bgw_dict.keys():
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in dci_boxes:
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
                            
            with steps.start('Defaulting the interfaces on DCI Cores') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in dci_boxes:
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in list(bgw_dict.keys()):
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
            
            with steps.start('Configuring Port-channel on all the boxes') as s:
                for dut in port_channel_dict:
                    log.info('the value of dut  inside scripts is : {0}'.format(dut))
                    hdl = node_dict['all_dut'][dut]
                    for intf in port_channel_dict[dut].keys():
                        log.info('the value of intf  inside scripts is : {0}'.format(intf))
                        args = port_channel_dict[dut][intf]
                        log.info('the value of args  inside scripts is : {0}'.format(args))
                        res = trigger_obj.configurePo(hdl,intf,args)
                        
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream_post_trigger.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream_post_trigger.append(item)
                        
                if stats_fail_stream_post_trigger:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    po_conversion_flag = 1
                    
            log.info(banner('Converting the Interface back to Physical Interface'))
            
 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 180 seconds before measuring the Traffic Convergence')
            countDownTimer(180)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    phy_conversion_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if po_conversion_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after PO Conversion'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if phy_conversion_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Physical Interface Conversion'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# MustSecure - Should Secure
class VxlanCloudSec_Func029(aetest.Testcase):

    """ Vxlan CloudSec - Func-029"""

    uid = 'VXLAN-CS-FUNC-029'

    @aetest.test
    def VxlanCloudSec_MustSecure_ShouldSecure(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test29:- MustSecure - Should Secure'))
        
        
        global_flag = 0
        trigger_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-001']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                                           
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ') 

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Site1 - MustSecure - Site2 - ShouldSecure') as s:
                log.info('Site1 - CloudSec - Site2 - Legacy')
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                site1_hdl.configure('tunnel-encryption must-secure-policy')
                site2_hdl.configure('no tunnel-encryption must-secure-policy')
                        
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream_post_trigger.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream_post_trigger.append(item)
                        
                if stats_fail_stream_post_trigger:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                    
            log.info(banner('Converting the Interface back to Physical Interface'))
            
 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if trigger_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if restore_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Must Secure - Key Expiry
class VxlanCloudSec_Func030(aetest.Testcase):

    """ Vxlan CloudSec - Func-030"""

    uid = 'VXLAN-CS-FUNC-030'

    @aetest.test
    def VxlanCloudSec_MustSecure_KeyExpiry(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test30: Must Secure - Key Expiry'))
        
        
        global_flag = 0
        trigger_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                                        
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ')   
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Modify the Key Lifetime on Site2') as s:
                key_flag = 0
                log.info('Modify the Key Lifetime on Site2')
                
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                out = site2_hdl.configure('sh run rpm | be "key chain"')
                start_capture = ''
                capture_flag = 0
                for line in out.splitlines():
                    log.info('the value of line is : {0}'.format(line))
                    if re.search('^key chain', line, re.I):
                        capture_flag = 1
                    if capture_flag:
                        start_capture += line + '\n'
                        if re.search('send-lifetime', line, re.I):
                            original_cmd = line
                            break
                log.info('the value of start_capture is : {0}'.format(start_capture))
                log.info('the value of original_cmd is : {0}'.format(original_cmd))
                
                start_capture += 'send-lifetime 00:00:00 Jan 01 2020 00:00:00 dec 31 2035'
                site2_hdl.configure(start_capture)
                
                out =  site2_hdl.configure('sh key chain  | xml')
                s = BeautifulSoup(out)
                try:
                    key_valid = s.find('send_valid').string
                    key_flag = 1
                except Exception as e:
                    log.error('Unable to find the send_valid tag on the keyChain')
                
                if key_flag:
                    if key_valid == 'false':
                        log.info('Key is No More valid as expected...')
                    else:
                        log.error('Key was expected to be invalid but looks like it is found Valid. Failing the test case.')
                        self.failed()

            log.info('Waiting for 30 seconds before measuring the Traffic Convergence')
            countDownTimer(30)

            with steps.start('Measuring stats on all Streams from the Global list ') as s:                          
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] !=0 and res['rx'] == 0:
                        log.info('Traffic Drop is as expected on stream {0}'.format(item))
                        stats_success_stream_post_trigger.append(item)
                    else:
                        log.error('Traffic drop was expected ')
                        stats_fail_stream_post_trigger.append(item)

                if stats_fail_stream_post_trigger:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if trigger_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if restore_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Should Secure - Key Expiry
class VxlanCloudSec_Func031(aetest.Testcase):

    """ Vxlan CloudSec - Func-031"""

    uid = 'VXLAN-CS-FUNC-031'

    @aetest.test
    def VxlanCloudSec_ShouldSecure_KeyExpiry(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test31: Should Secure - Key Expiry'))
        
        
        global_flag = 0
        trigger_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Change CS Policy to Should Secure') as s:
                log.info('Change CS Policy to Should Secure')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')                                  
                    if re.search('Should', current_mode, re.I):                    
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))

            with steps.start('Modify the Key Lifetime on Site2') as s:
                key_flag = 0
                log.info('Modify the Key Lifetime on Site2')
                
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                out = site2_hdl.configure('sh run rpm | be "key chain"')
                start_capture = ''
                capture_flag = 0
                for line in out.splitlines():
                    log.info('the value of line is : {0}'.format(line))
                    if re.search('^key chain', line, re.I):
                        capture_flag = 1
                    if capture_flag:
                        start_capture += line + '\n'
                        if re.search('send-lifetime', line, re.I):
                            original_cmd = line
                            break
                log.info('the value of start_capture is : {0}'.format(start_capture))
                log.info('the value of original_cmd is : {0}'.format(original_cmd))
                
                start_capture += 'send-lifetime 00:00:00 Jan 01 2020 00:00:00 dec 31 2020'
                site2_hdl.configure(start_capture)
                
                out =  site2_hdl.configure('sh key chain  | xml')
                s = BeautifulSoup(out)
                try:
                    key_valid = s.find('send_valid').string
                    key_flag = 1
                except Exception as e:
                    log.error('Unable to find the send_valid tag on the keyChain')
                
                if key_flag:
                    if key_valid == 'false':
                        log.info('Key is No More valid as expected...')
                    else:
                        log.error('Key was expected to be invalid but looks like it is found Valid. Failing the test case.')
                        self.failed()

            log.info('Waiting for 30 seconds before measuring the Traffic Convergence')
            countDownTimer(30)

            with steps.start('Measuring stats on all Streams from the Global list ') as s:                          
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('Traffic is as expected on stream {0}'.format(item))
                        stats_success_stream_post_trigger.append(item)
                    else:
                        log.error('Traffic drop was expected ')
                        stats_fail_stream_post_trigger.append(item)

                if stats_fail_stream_post_trigger:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if trigger_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if restore_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Rekey Functionality
class VxlanCloudSec_Func032(aetest.Testcase):

    """ Vxlan CloudSec - Func-032"""

    uid = 'VXLAN-CS-FUNC-032'

    @aetest.test
    def VxlanCloudSec_RekeyFunctionality(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test32: Rekey Functionality'))
        
        
        global_flag = 0
        trigger_flag = 0
        restore_flag = 0
        peer_ip_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Get Current Association Number from box') as s:
                log.info('Get Current Association Number from box')
                
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                out = site2_hdl.execute('sh tunnel-encryption session  | xml')
                s = BeautifulSoup(out)
                try:
                    peer_ip = s.find('peeraddr').string
                    peer_ip_flag = 1
                except Exception as e:
                    log.info('Peer_ip could not be found. Failing the test case....')
                    self.failed()
                if peer_ip_flag:
                    pat = '^SECURE \(AN\: (\d)\)$'
                    out1 = site2_hdl.execute('sh tunnel-encryption session peer-ip {0} | xml'.format(peer_ip))
                    s = BeautifulSoup(out1)
                    try:
                        an_rx = s.find('rxstatus').string
                        an_tx = s.find('txstatus').string
                    except Exception as e:
                        log.error('Unable to find the AN # for Either Rx or Tx. Hence failing the test case')
                        self.failed()
                    if an_rx:
                        match = re.search(pat,an_rx,re.I)
                        if match:
                            prev_an_rx_no = match.group(1)
                    if an_tx:
                        match = re.search(pat,an_tx,re.I)
                        if match:
                            prev_an_tx_no = match.group(1)
                    log.info('The Value of an_rx_no and an_tx_no is : {0} and {1}'.format(prev_an_rx_no, prev_an_tx_no))
                    
            log.info('Waiting for 5 mins to before applying the trigger for Rekey')
            countDownTimer(300)
            
            with steps.start('Removing and readding the Tunnel-encryption Loopback configs') as s:
                out1 = site2_hdl.configure('no int loopback 10')
                cfg = '''interface loopback10
                        ip address 77.77.77.77/32 tag 22222'''
                out2 = site2_hdl.configure(cfg)
                
                log.info('Waiting for 15 seconds before checking the Tunnel-Encrpytion status:')
                countDownTimer(15)
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()
                    
            with steps.start('Getting the Association Numbers') as s:
                out3 = site2_hdl.execute('sh tunnel-encryption session peer-ip {0} | xml'.format(peer_ip))
                s = BeautifulSoup(out3)
                try:
                    an_rx = s.find('rxstatus').string
                    an_tx = s.find('txstatus').string
                except Exception as e:
                    log.error('Unable to find the AN # for Either Rx or Tx. Hence failing the test case')
                    self.failed()
                if an_rx:
                    match = re.search(pat,an_rx,re.I)
                    if match:
                        curr_an_rx_no = match.group(1)
                if an_tx:
                    match = re.search(pat,an_tx,re.I)
                    if match:
                       curr_an_tx_no = match.group(1)
                
                log.info('The Value of an_rx_no and an_tx_no is : {0} and {1}'.format(curr_an_rx_no, curr_an_tx_no))
                
                if abs(int(curr_an_tx_no) - int(prev_an_tx_no)) >= 1 or abs(int(curr_an_rx_no) - int(prev_an_rx_no)) >= 1:
                    log.info('The Rekey has happened as expected. ')
                else:
                    log.error('The Rekey hasnot happened as expected.  Failing the test case')
                    self.failed()                        
                        
# Rekey Functionality - Should Secure
class VxlanCloudSec_Func033(aetest.Testcase):

    """ Vxlan CloudSec - Func-033"""

    uid = 'VXLAN-CS-FUNC-033'

    @aetest.test
    def VxlanCloudSec_RekeyFunctionality_ShouldSEcure(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test33: Rekey Functionality - Should Secure'))
        
        
        global_flag = 0
        trigger_flag = 0
        restore_flag = 0
        peer_ip_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')
                                                
                    if re.search('Should', current_mode, re.I):                    
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))      
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Get Current Association Number from box') as s:
                log.info('Get Current Association Number from box')
                
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                
                out = site2_hdl.execute('sh tunnel-encryption session  | xml')
                s = BeautifulSoup(out)
                try:
                    peer_ip = s.find('peeraddr').string
                    peer_ip_flag = 1
                except Exception as e:
                    log.info('Peer_ip could not be found. Failing the test case....')
                    self.failed()
                if peer_ip_flag:
                    pat = '^SECURE \(AN\: (\d)\)$'
                    out1 = site2_hdl.execute('sh tunnel-encryption session peer-ip {0} | xml'.format(peer_ip))
                    s = BeautifulSoup(out1)
                    try:
                        an_rx = s.find('rxstatus').string
                        an_tx = s.find('txstatus').string
                    except Exception as e:
                        log.error('Unable to find the AN # for Either Rx or Tx. Hence failing the test case')
                        self.failed()
                    if an_rx:
                        match = re.search(pat,an_rx,re.I)
                        if match:
                            prev_an_rx_no = match.group(1)
                    if an_tx:
                        match = re.search(pat,an_tx,re.I)
                        if match:
                            prev_an_tx_no = match.group(1)
                    log.info('The Value of an_rx_no and an_tx_no is : {0} and {1}'.format(prev_an_rx_no, prev_an_tx_no))
                    
            log.info('Waiting for 5 mins to before applying the trigger for Rekey')
            countDownTimer(300)
            
            with steps.start('Removing and readding the Tunnel-encryption Loopback configs') as s:
                out1 = site2_hdl.configure('no int loopback 10')
                cfg = '''interface loopback10
                        ip address 77.77.77.77/32 tag 22222'''
                out2 = site2_hdl.configure(cfg)
                
                log.info('Waiting for 15 seconds before checking the Tunnel-Encrpytion status:')
                countDownTimer(15)
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()
                    
            with steps.start('Getting the Association Numbers') as s:
                out3 = site2_hdl.execute('sh tunnel-encryption session peer-ip {0} | xml'.format(peer_ip))
                s = BeautifulSoup(out3)
                try:
                    an_rx = s.find('rxstatus').string
                    an_tx = s.find('txstatus').string
                except Exception as e:
                    log.error('Unable to find the AN # for Either Rx or Tx. Hence failing the test case')
                    self.failed()
                if an_rx:
                    match = re.search(pat,an_rx,re.I)
                    if match:
                        curr_an_rx_no = match.group(1)
                if an_tx:
                    match = re.search(pat,an_tx,re.I)
                    if match:
                       curr_an_tx_no = match.group(1)
                
                log.info('The Value of an_rx_no and an_tx_no is : {0} and {1}'.format(curr_an_rx_no, curr_an_tx_no))
                
                if abs(int(curr_an_tx_no) - int(prev_an_tx_no)) >= 1 or abs(int(curr_an_rx_no) - int(prev_an_rx_no)) >= 1:
                    log.info('The Rekey has happened as expected. ')
                else:
                    log.error('The Rekey hasnot happened as expected.  Failing the test case')
                    self.failed()                        

# CloudSec Stats
class VxlanCloudSec_Func034(aetest.Testcase):

    """ Vxlan CloudSec - Stats Func-034"""

    uid = 'VXLAN-CS-FUNC-034'

    @aetest.test
    def VxlanCloudSec_Stats(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test34: CloudSec Stats'))
        
        
        global_flag = 0
        success_flag = 0
        restore_flag = 0
        encrypted_counter_fail_flag = 0
        decrtpy_counter_fail_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        traffic_item = 'TRF001'
        counter_flag = 0
        
        total_old_rx_pkt_count = 0
        total_new_rx_pkt_count = 0
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
        
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Starting the Stream req for the test') as s:
                log.info(banner('Starting the Traffic Stream {0}'.format(traffic_item)))
                countDownTimer(30)
                start_fail_stream = []
                
                log.info(banner('Starting the Stream required for this test . {0}'.format(traffic_item)))
                x = tgn_hdl.traffic_control(action='run', handle = traffic_stream_dict[traffic_item]['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                    start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                    
            with steps.start('Measuring CloudSec Stats') as s:
                log.info(banner('Measuring CloudSec Stats - Traffic Item '.format(traffic_item)))
                countDownTimer(15)
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                peer_ip_find = site1_hdl.execute('sh tunnel-encryption session | xml')
                s = BeautifulSoup(peer_ip_find)
                log.info('The valule of s is : {0}'.format(s))
                try:
                    peer_ip = s.find('peeraddr').string
                    success_flag = 1
                except Exception as e:
                    log.error('Unable to find the peeraddr.. Hence Failing the tset case..')
                    self.failed()
                
                if success_flag:
                    site1_hdl.execute('clear tunnel-encryption statistics peer-ip {0}'.format(peer_ip))
                    
                    cmd = 'sh tunnel-encryption statistics peer-ip {0} | xml '.format(peer_ip)
                    out = site1_hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('out_pkts_encrypted_protected',line,re.I):
                            s = BeautifulSoup(line)
                            log.info('The value of s is : {0}'.format(s))
                            try:
                                old_tx_pkt_count = s.find('out_pkts_encrypted_protected').string   
                            except:
                                log.error('packet count could not be extracted.')
                                self.failed()
                        elif re.search('in_pkts_decrypted', line, re.I):
                            s = BeautifulSoup(line)
                            log.info('The value of s is : {0}'.format(s))
                            try:
                                old_rx_pkt_count = s.find('in_pkts_decrypted').string
                                total_old_rx_pkt_count += int(old_rx_pkt_count)
                            except Exception:
                                log.error('Packet cound could not be extracted')
                                self.failed()
                    
                    log.info('the value of tx_pkt_count and rx_pkt_count is : {0} and {1}'.format(old_tx_pkt_count,total_old_rx_pkt_count))
                    
                    log.info(banner('Waiting for 60 seconds before getting the packet Count'))
                    countDownTimer(60)
                    
                    out = site1_hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('out_pkts_encrypted_protected',line,re.I):
                            s = BeautifulSoup(line)
                            log.info('The value of s is : {0}'.format(s))
                            try:
                                new_tx_pkt_count = s.find('out_pkts_encrypted_protected').string
                            except:
                                log.error('packet count could not be extracted.')
                                self.failed()
                        elif re.search('in_pkts_decrypted', line, re.I):
                            s = BeautifulSoup(line)
                            log.info('The value of s is : {0}'.format(s))
                            try:
                                new_rx_pkt_count = s.find('in_pkts_decrypted').string
                                total_new_rx_pkt_count += int(new_rx_pkt_count)
                            except Exception:
                                log.error('Packet cound could not be extracted')
                                self.failed()
                
                
                    log.info('the value of tx_pkt_count and rx_pkt_count is : {0} and {1}'.format(new_tx_pkt_count,total_new_rx_pkt_count))   
                    
                    if (int(new_tx_pkt_count) - int(old_tx_pkt_count)) > 50 * (3000/2):
                        log.info('Encrypted Counter is Working as expected....')
                        if (total_new_rx_pkt_count - total_old_rx_pkt_count)> 50 * (3000/2):
                            log.info('Decrypt Counter is Working as expected....')
                            if abs(total_new_rx_pkt_count  - int(new_tx_pkt_count)) < 1000:
                                log.info('Tx and Rx stats match as expected')
                            else:
                                log.info('Counter Works but Tx and Rx stats match as expected')
                                log.info(banner('the value of Tx and Rx stats are : {0} and {1}'.format(new_tx_pkt_count,new_rx_pkt_count)))
                                counter_flag = 1
                                global_flag = 1
                        else:
                            log.info('Decrypt Counter is not as expected')
                            decrypt_counter_fail_flag = 1
                            global_flag = 1
                    else:
                        log.info('Encrypted Counter is not as expected')
                        encrypted_counter_fail_flag = 1
                        global_flag = 1


            with steps.start('Starting the Stream req for the test') as s:
                log.info(banner('Starting the Traffic Stream {0}'.format(traffic_item)))
                countDownTimer(30)
                stop_fail_stream = []
                
                log.info(banner('Starting the Stream required for this test . {0}'.format(traffic_item)))
                x = tgn_hdl.traffic_control(action='stop', handle = traffic_stream_dict[traffic_item]['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                    stop_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_stop_flag = 1

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
 
            log.info(banner('Waiting for 30 seconds before starting all the streams..'))
            countDownTimer(30)                   

            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)



            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if encrypted_counter_fail_flag:
                        log.error('Encrypted Counter does not seem to work as expected')
                    elif decrypt_counter_fail_flag:
                        log.error('Encrypted Counter does not seem to work as expected')
                    elif stream_start_flag:
                        log.error('The Stream {0} could not be started '.format(traffic_item))
                    elif counter_flag:
                        log.info('Counter Works but Tx and Rx stats match as expected')
                        log.info(banner('the value of Tx and Rx stats are : {0} and {1}'.format(new_tx_pkt_count,new_rx_pkt_count)))
                    self.failed()   

# CloudSec Stats - Clear
class VxlanCloudSec_Func035(aetest.Testcase):

    """ Vxlan CloudSec - Stats Func-035"""

    uid = 'VXLAN-CS-FUNC-035'

    @aetest.test
    def VxlanCloudSec_StatsClear(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test35: CloudSec Stats - Clear'))
        
        
        global_flag = 0
        success_flag = 0
        restore_flag = 0
        encrypted_counter_fail_flag = 0
        decrtpy_counter_fail_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        traffic_item = 'TRF001'
        clear_fail_flag = 0
        stream_stop_fail_flag = 0
        
        total_old_rx_pkt_count = 0
        total_new_rx_pkt_count = 0
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
        
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Starting the Stream req for the test') as s:
                log.info(banner('Starting the Traffic Stream {0}'.format(traffic_item)))
                countDownTimer(30)
                start_fail_stream = []
                
                log.info(banner('Starting the Stream required for this test . {0}'.format(traffic_item)))
                x = tgn_hdl.traffic_control(action='run', handle = traffic_stream_dict[traffic_item]['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                    start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                    
                    
            with steps.start('Measuring CloudSec Stats') as s:
                log.info(banner('Measuring CloudSec Stats - Traffic Item '.format(traffic_item)))
                countDownTimer(30)
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                peer_ip_find = site1_hdl.execute('sh tunnel-encryption session | xml')
                s = BeautifulSoup(peer_ip_find)
                log.info('The valule of s is : {0}'.format(s))
                try:
                    peer_ip = s.find('peeraddr').string
                    success_flag = 1
                except Exception as e:
                    log.error('Unable to find the peeraddr.. Hence Failing the tset case..')
                    self.failed()
                
                if success_flag:
                    cmd = 'sh tunnel-encryption statistics peer-ip {0} | xml '.format(peer_ip)
                    out = site1_hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('out_pkts_encrypted_protected',line,re.I):
                            s = BeautifulSoup(line)
                            log.info('The value of s is : {0}'.format(s))
                            try:
                                old_tx_pkt_count = s.find('out_pkts_encrypted_protected').string   
                            except:
                                log.error('packet count could not be extracted.')
                                self.failed()
                        elif re.search('in_pkts_decrypted', line, re.I):
                            s = BeautifulSoup(line)
                            log.info('The value of s is : {0}'.format(s))
                            try:
                                old_rx_pkt_count = s.find('in_pkts_decrypted').string
                                total_old_rx_pkt_count += int(old_rx_pkt_count)
                            except Exception:
                                log.error('Packet cound could not be extracted')
                                self.failed()
                    
                    log.info('the value of tx_pkt_count and rx_pkt_count is : {0} and {1}'.format(old_tx_pkt_count,total_old_rx_pkt_count))
                    
                    if (total_old_rx_pkt_count > 25 * (3000/2)) and (int(old_tx_pkt_count) > 25* (3000/2)):
                        log.info('Counter Works as expected....')
                    else:
                        log.error('Initial Counter is not working as expected')
                        self.failed()
                        
            with steps.start('Stopping the Stream req for the test') as s:

                stop_fail_stream = []
                
                log.info(banner('Starting the Stream required for this test . {0}'.format(traffic_item)))
                x = tgn_hdl.traffic_control(action='stop', handle = traffic_stream_dict[traffic_item]['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                    stop_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_stop_fail_flag = 1

            with steps.start('Clearing the Tunnel-Encryption Stats') as s:

                site1_hdl.execute('clear tunnel-encryption statistics')

            with steps.start('Measuring CloudSec Stats') as s:
                
                cmd = 'sh tunnel-encryption statistics peer-ip {0} | xml '.format(peer_ip)
                out = site1_hdl.execute(cmd)
                for line in out.splitlines():
                    if re.search('out_pkts_encrypted_protected',line,re.I):
                        s = BeautifulSoup(line)
                        log.info('The value of s is : {0}'.format(s))
                        try:
                            new_tx_pkt_count = s.find('out_pkts_encrypted_protected').string   
                        except:
                            log.error('packet count could not be extracted.')
                            self.failed()
                    elif re.search('in_pkts_decrypted', line, re.I):
                        s = BeautifulSoup(line)
                        log.info('The value of s is : {0}'.format(s))
                        try:
                            new_rx_pkt_count = s.find('in_pkts_decrypted').string
                            total_new_rx_pkt_count += int(new_rx_pkt_count)
                        except Exception:
                            log.error('Packet cound could not be extracted')
                            self.failed()
                
                log.info('the value of tx_pkt_count and rx_pkt_count is : {0} and {1}'.format(new_tx_pkt_count,total_new_rx_pkt_count))
                
                if (total_new_rx_pkt_count < 50 ) and (int(new_tx_pkt_count) < 50):
                    log.info('Counter Works as expected....')
                else:
                    log.error('Counter Clear did not work as expected')
                    clear_fail_flag = 1
                    
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
 
            log.info(banner('Waiting for 30 seconds before starting all the streams..'))
            countDownTimer(30)                   

            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)


            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if encrypted_counter_fail_flag:
                        log.error('Encrypted Counter does not seem to work as expected')
                    elif decrypt_counter_fail_flag:
                        log.error('Encrypted Counter does not seem to work as expected')
                    elif stream_start_flag:
                        log.error('The Stream {0} could not be started '.format(traffic_item))
                    elif stream_stop_fail_flag:
                        log.error('The stream {0} could not be stoopped'.format(traffic_item))
                    elif counter_flag:
                        log.info('Counters are not proper after clearing the counters')
                        log.info(banner('the value of Tx and Rx stats are : {0} and {1}'.format(new_tx_pkt_count,total_new_rx_pkt_count)))
                    self.failed()   

# SAK Key Installation
class VxlanCloudSec_Func036(aetest.Testcase):

    """ Vxlan CloudSec - Stats Func-036"""

    uid = 'VXLAN-CS-FUNC-036'

    @aetest.test
    def VxlanCloudSec_SAKKeyInstallation(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test36: SAK Key Installation'))
        
        
        global_flag = 0
        peer_ip_flag = 0
        restore_flag = 0
        encrypted_counter_fail_flag = 0
        decrtpy_counter_fail_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        stats_success_stream_post_trigger = []
        stats_fail_stream_post_trigger = []
        traffic_item = 'TRF001'
        clear_fail_flag = 0
        stream_stop_fail_flag = 0
        
        total_old_rx_pkt_count = 0
        total_new_rx_pkt_count = 0
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Get the Tunnel-Encryption peer') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                log.info('Getting the Tunnel-Encryption peer-IP from the dut : {0}'.format(site1_dut))
                out = site1_hdl.configure('sh tunnel-encryption session | xml')
                s = BeautifulSoup(out)
                try:
                    peer_ip = s.find('peeraddr').string
                    log.info('the value of peer_ip is : {0}'.format(peer_ip))
                except Exception as e:
                    log.error('Unable to find the peer_ip address. Failing the test case')
                    self.failed()

            with steps.start('Get the Current SAK Key') as s:
                log.info('Getting the SAK Key from the BGP CloudSec keys')

                out = site1_hdl.execute('sh bgp internal cloudsec-keys')
                pat1 = peer_ip + ' ' + 'AN'
                pat2 = 'wSAK:\s([A-Z0-9]{8}\s)+'
                for line in out.splitlines():
                    if re.search(pat1,line,re.I):
                        log.info('the complete line is : {0}'.format(line))
                        match = re.search(pat2,line,re.I)
                        if match:
                            old_sak_key = match.group()
                
                log.info('The value of old_sak_key is : {0}'.format(old_sak_key))
                
            log.info('Waiting for 300 seconds before Triggering the SAK Key')
            countDownTimer(300)
            
            with steps.start('Get the current CIpher Suite') as s:
                log.info('Getting the current cipher suite from the box {0}'.format(site1_dut))
                out1 = site1_hdl.execute('sh tunnel-encryption policy  | xml')
                policy_list = []
                for line in out1.splitlines():
                    if re.search('<name>',line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            policy = s.find('name').string
                            policy_list.append(policy)
                        except Exception as e:
                            log.error('some Error Occurred in getting the policy name')
                            self.failed()       
                        
                
                log.info('The value of policy_list  is : {0}'.format(policy_list))
                
                for item in policy_list:
                    if re.search('system-default-tunenc-policy', item, re.I):
                        policy_list.remove(item)
                        
                log.info('The value of policy Now is : {0}'.format(policy_list))
                
                cmd = 'sh tunnel-encryption policy {0} | xml'.format(policy_list[0])
                out2 = site1_hdl.execute(cmd)
                s = BeautifulSoup(out2)
                try:
                    cipher_suite = s.find('cipher_suite').string
                except Exception as e:
                    log.error('Unable to find the cipher Suite. Hence failing the test case')
                    self.failed()
                    
                if cipher_suite:
                    if re.search('128' , cipher_suite, re.I):
                        new_config = 'GCM-AES-XPN-256'
                    else:
                        new_config = 'GCM-AES-XPN-128'
                        
            with steps.start('Changing the Cipher Suite') as s:
                log.info('Changing the Cipher Suite to simulate new SAK')
                cfg = '''tunnel-encryption policy {0}
                         cipher-suite {1}'''.format(policy_list[0],new_config)
                site1_hdl.configure(cfg)
                
            with steps.start('Checking for the new SAK KEY and Deletion of old one') as s:
                out = site1_hdl.execute('sh bgp internal cloudsec-keys')
                for line in out.splitlines():
                    if re.search(pat1,line,re.I):
                        log.info('the complete line is : {0}'.format(line))
                        match = re.search(pat2,line,re.I)
                        if match:
                            new_sak_key = match.group()
                
                log.info('The value of new_sak_key is : {0}'.format(new_sak_key))
                
                if new_sak_key != old_sak_key:
                    log.info('New SAK key generation is as expected....')
                else:
                    log.error('Old sak Key is not deleted and the New SAK Key is not installed. Failing the test case')
                    self.failed()

# CAKKey-MinimalLength_CipherSuite128
class VxlanCloudSec_Func037(aetest.Testcase):

    """ Vxlan CloudSec - Stats Func-037"""

    uid = 'VXLAN-CS-FUNC-037'

    @aetest.test
    def VxlanCloudSec_CAKKey_MinimumLength_FUNC037(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test37: CAKKey-MinimalLength_CipherSuite128'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Finding the min Key-string Length from the configs.') as s:
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                min_length = []
                count = 1
                key_str = '1'
                while (count <= 128):
                    key_string = count * key_str
                    log.info('the value of key_string is : {0}'.format(key_string))
                    cfg = '''key chain TEST tunnel-encryption
                             key 12
                             key-octet-string {0} cryptographic-algorithm AES_128_CMAC'''.format(key_string)
                    out = site1_hdl.configure(cfg)
                    if re.search('invalid|exceed', out, re.I):
                        log.info('Key string  of length {0} is invalid'.format(len(key_string)))
                    else:
                        min_length.append(count)
                        cfg = '''key chain TEST tunnel-encryption
                                 key 12
                                 no key-octet-string {0} cryptographic-algorithm AES_128_CMAC'''.format(key_string)
                        out = site1_hdl.configure(cfg)
                        log.info('Minimal length of the key is : {0}'.format(min_length))
                    count+=1
                    
                log.info('The Value of min_length is : {0}'.format(min_length))
                
            with steps.start('Configuring the box with Min Key-string length') as s:
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                cfg = '''key chain TEST tunnel-encryption
                         key 12
                         key-octet-string {0} cryptographic-algorithm AES_128_CMAC'''.format(key_str*min_length[0])
                site1_hdl.configure(cfg)
                site2_hdl.configure(cfg)
                
                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut]
                    log.info('peer_ip is : {0}'.format(peer_ip))
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,node_dict['all_dut'][dut],peer_ip[0])
                    log.info('res value is : {0}'.format(res))
                    cfg1 = 'no tunnel-encryption peer-ip {0}'.format(peer_ip[0])
                    node_dict['all_dut'][dut].configure(cfg1)
                    cfg2 = '''tunnel-encryption peer-ip {0}
                              keychain {1} policy {2}'''.format(peer_ip[0],'TEST',res['policyname'])
                    node_dict['all_dut'][dut].configure(cfg2)
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}').format(stats_fail_stream)
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
            
# CAKKey-MinimalLength_CipherSuite256
class VxlanCloudSec_Func038(aetest.Testcase):

    """ Vxlan CloudSec - Stats Func-038"""

    uid = 'VXLAN-CS-FUNC-038'

    @aetest.test
    def VxlanCloudSec_CAKKey_MinimumLength_FUNC038(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test38: CAKKey-MinimalLength_CipherSuite256'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Finding the min Key-string Length from the configs.') as s:
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                min_length = []
                count = 1
                key_str = '1'
                while (count <= 128):
                    key_string = count * key_str
                    log.info('the value of key_string is : {0}'.format(key_string))
                    cfg = '''key chain TEST tunnel-encryption
                             key 12
                             key-octet-string {0} cryptographic-algorithm AES_256_CMAC'''.format(key_string)
                    out = site1_hdl.configure(cfg)
                    if re.search('invalid|exceed', out, re.I):
                        log.info('Key string  of length {0} is invalid'.format(len(key_string)))
                    else:
                        min_length.append(count)
                        cfg = '''key chain TEST tunnel-encryption
                                 key 12
                                 no key-octet-string {0} cryptographic-algorithm AES_256_CMAC'''.format(key_string)
                        out = site1_hdl.configure(cfg)
                        log.info('Minimal length of the key is : {0}'.format(min_length))
                    count+=1
                    
                log.info('The Value of min_length is : {0}'.format(min_length))
                
            with steps.start('Configuring the box with Min Key-string length') as s:
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                cfg = '''key chain TEST tunnel-encryption
                         key 12
                         key-octet-string {0} cryptographic-algorithm AES_256_CMAC'''.format(key_str*min_length[0])
                site1_hdl.configure(cfg)
                site2_hdl.configure(cfg)
                
                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut]
                    log.info('peer_ip is : {0}'.format(peer_ip))
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,node_dict['all_dut'][dut],peer_ip[0])
                    log.info('res value is : {0}'.format(res))
                    cfg1 = 'no tunnel-encryption peer-ip {0}'.format(peer_ip[0])
                    node_dict['all_dut'][dut].configure(cfg1)
                    cfg2 = '''tunnel-encryption peer-ip {0}
                              keychain {1} policy {2}'''.format(peer_ip[0],'TEST',res['policyname'])
                    node_dict['all_dut'][dut].configure(cfg2)
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# CKN-MinimumLength
class VxlanCloudSec_Func039(aetest.Testcase):

    """ Vxlan CloudSec - KEyId Length Func-039"""

    uid = 'VXLAN-CS-FUNC-039'

    @aetest.test
    def VxlanCloudSec_CKN_MinimumLength_FUNC039(self,log,testscript,testbed, steps):


        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 


        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 


        port_handle_dict = testscript.parameters['port_handle_dict']


        TGList_config_file = testscript.parameters['TGList']


        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test38: CKN-MinimumLength'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Finding the min Key-string Length from the configs.') as s:
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                min_length = []
                count = 1
                key_str = 'a'
                while (count <= 128):
                    key_id = count * key_str
                    log.info('the value of key_string is : {0}'.format(key_id))
                    cfg = '''key chain TEST tunnel-encryption
                             key {0}
                          '''.format(key_id)
                    out = site1_hdl.configure(cfg)
                    if re.search('invalid|exceed', out, re.I):
                        log.info('Key id of length {0} is invalid'.format(len(key_id)))
                    else:
                        min_length.append(key_id)
                        cfg = '''key chain TEST tunnel-encryption
                                 no key {0}
                                 '''.format(key_id)
                        out = site1_hdl.configure(cfg)
                        log.info('Minimal length of the key is : {0}'.format(min_length))
                    count+=1
                    
                log.info('The Value of min_length is : {0}'.format(min_length))
                res = [len(x) for x in min_length]
                log.info('the value of min_key_id_length is : {0}'.format(res[0]))
                log.info('the value of max_key_id_length is : {0}'.format(res[-1]))
                
            with steps.start('Configuring the box with Min Key-id length') as s:
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                cfg = '''key chain TEST tunnel-encryption
                         key {0}
                         key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC'''.format(min_length[0])
                site1_hdl.configure(cfg)
                site2_hdl.configure(cfg)
                
                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut]
                    log.info('peer_ip is : {0}'.format(peer_ip))
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,node_dict['all_dut'][dut],peer_ip[0])
                    log.info('res value is : {0}'.format(res))
                    cfg1 = 'no tunnel-encryption peer-ip {0}'.format(peer_ip[0])
                    node_dict['all_dut'][dut].configure(cfg1)
                    cfg2 = '''tunnel-encryption peer-ip {0}
                              keychain {1} policy {2}'''.format(peer_ip[0],'TEST',res['policyname'])
                    node_dict['all_dut'][dut].configure(cfg2)
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# CKN-Maxmimum Length
class VxlanCloudSec_Func040(aetest.Testcase):

    """ Vxlan CloudSec - KEyId Length Func-040"""

    uid = 'VXLAN-CS-FUNC-040'

    @aetest.test
    def VxlanCloudSec_CKN_MinimumLength_FUNC040(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test39: CKN-Maxmimum Length'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Finding the min Key-string Length from the configs.') as s:
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                min_length = []
                count = 1
                key_str = 'a'
                while (count <= 128):
                    key_id = count * key_str
                    log.info('the value of key_string is : {0}'.format(key_id))
                    cfg = '''key chain TEST tunnel-encryption
                             key {0}
                          '''.format(key_id)
                    out = site1_hdl.configure(cfg)
                    if re.search('invalid|exceed', out, re.I):
                        log.info('Key id of length {0} is invalid'.format(len(key_id)))
                    else:
                        min_length.append(key_id)
                        cfg = '''key chain TEST tunnel-encryption
                                 no key {0}
                                 '''.format(key_id)
                        out = site1_hdl.configure(cfg)
                        log.info('Minimal length of the key is : {0}'.format(min_length))
                    count+=1
                    
                log.info('The Value of min_length is : {0}'.format(min_length))
                res = [len(x) for x in min_length]
                log.info('the value of min_key_id_length is : {0}'.format(res[0]))
                log.info('the value of max_key_id_length is : {0}'.format(res[-1]))
                
            with steps.start('Configuring the box with Min Key-id length') as s:
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                cfg = '''key chain TEST tunnel-encryption
                         key {0}
                         key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC'''.format(min_length[-1])
                site1_hdl.configure(cfg)
                site2_hdl.configure(cfg)
                
                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut]
                    log.info('peer_ip is : {0}'.format(peer_ip))
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,node_dict['all_dut'][dut],peer_ip[0])
                    log.info('res value is : {0}'.format(res))
                    cfg1 = 'no tunnel-encryption peer-ip {0}'.format(peer_ip[0])
                    node_dict['all_dut'][dut].configure(cfg1)
                    cfg2 = '''tunnel-encryption peer-ip {0}
                              keychain {1} policy {2}'''.format(peer_ip[0],'TEST',res['policyname'])
                    node_dict['all_dut'][dut].configure(cfg2)
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# MustSecure - ShouldSecure - MustSecure Policy change
class VxlanCloudSec_Func041(aetest.Testcase):

    """ Vxlan CloudSec - Mode Change - Must Secure - Should secure and Vice versa"""

    uid = 'VXLAN-CS-FUNC-041'

    @aetest.test
    def VxlanCloudSec_Policychange_MS_SS_MS_FUNC041(self,log,testscript,testbed, steps):

        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test41: MustSecure - ShouldSecure - MustSecure Policy change'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        restore_stats_success_stream= []
        restore_stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Changing Policy from Must-Secure to Should-Secure') as s:

                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ') 
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))   
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Changing Policy from Should-Secure to Must-Secure') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        restore_stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        restore_stats_fail_stream.append(item)

                if restore_stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    restore_flag = 1
                    restore_stats_fail_flag = 1
                    
            with steps.start('Restore Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                        
                    if restore_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(restore_stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# ShouldSecure - Legacy - ShouldSecure Policy change
class VxlanCloudSec_Func042(aetest.Testcase):

    """ Vxlan CloudSec - Policy Change - Should Secure - Legacy and Vice versa"""

    uid = 'VXLAN-CS-FUNC-042'

    @aetest.test
    def VxlanCloudSec_Policychange_SS_Legacy_SS_FUNC042(self,log,testscript,testbed, steps):

        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test42: ShouldSecure - Legacy - ShouldSecure Policy change'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        restore_stats_success_stream= []
        restore_stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')                                 
                    if re.search('Should', current_mode, re.I):                    
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Changing Policy from  Should Secure - Legacy') as s:

                for dut in bgw_dict.keys():
                    log.info(banner('Removing feature Tunnel-Encrpytion on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature tunnel-encryption' )
                    if out.result=='fail':
                        log.error('Disable of Tunnel-Encrpytion failed on dut %s' % dut)
                    else:
                        log.info('Disable of Tunnel-Encrpytion passes on dut %s' % dut) 
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Changing Policy from Legacy to Should-Secure') as s:
                log.info('Get CloudSec Current mode')
                
                for dut in cloudsec_config_dict.keys():
                    obj_cs=MyLib.my_cloudsec_lib.configTunnelEncryption(cloudsec_config_dict,node_dict,alias_intf_mapping,log)
                    if not obj_cs.Nodes(dut,policy='Should-Secure'):
                        self.failed()
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        restore_stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        restore_stats_fail_stream.append(item)

                if restore_stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    restore_flag = 1
                    restore_stats_fail_flag = 1
                    
            with steps.start('Restore Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                        
                    if restore_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(restore_stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# MustSecure - Legacy - MustSecure Policy change
class VxlanCloudSec_Func043(aetest.Testcase):

    """ Vxlan CloudSec - Policy Change - Must Secure - Legacy and Vice versa"""

    uid = 'VXLAN-CS-FUNC-043'

    @aetest.test
    def VxlanCloudSec_Policychange_SS_Legacy_SS_FUNC043(self,log,testscript,testbed, steps):

        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test43: MustSecure - Legacy - MustSecure Policy change'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        restore_stats_success_stream= []
        restore_stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                           
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')  
                        
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Changing Policy from  Should Secure - Legacy') as s:

                for dut in bgw_dict.keys():
                    log.info(banner('Removing feature Tunnel-Encrpytion on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature tunnel-encryption' )
                    if out.result=='fail':
                        log.error('Disable of Tunnel-Encrpytion failed on dut %s' % dut)
                    else:
                        log.info('Disable of Tunnel-Encrpytion passes on dut %s' % dut) 
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
            with steps.start('Changing Policy from Legacy to Must-Secure') as s:
                log.info('Get CloudSec Current mode')
                
                for dut in cloudsec_config_dict.keys():
                    obj_cs=MyLib.my_cloudsec_lib.configTunnelEncryption(cloudsec_config_dict,node_dict,alias_intf_mapping,log)
                    if not obj_cs.Nodes(dut):
                        self.failed()
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer status')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        restore_stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        restore_stats_fail_stream.append(item)

                if restore_stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    restore_flag = 1
                    restore_stats_fail_flag = 1
                    
            with steps.start('Restore Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                        
                    if restore_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(restore_stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Modify Tunnel-Encrpytion policy Window Size
class VxlanCloudSec_Func044(aetest.Testcase):

    """ Vxlan CloudSec - Modify Window Size inside Tunnel-Encryption policy"""

    uid = 'VXLAN-CS-FUNC-044'

    @aetest.test
    def VxlanCloudSec_Policychange_Modify_Tunnel_Encryption_Policy_FUNC044(self,log,testscript,testbed, steps):

        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test44: Modify Tunnel-Encrpytion policy Window Size'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        restore_stats_success_stream= []
        restore_stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                           
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')  
                        
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Getting the Window Size from Tunnel-Encryption policy') as s:
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    peer_ip = cloudsec_peer_per_dut[dut][0]
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                    policy_name = res['policyname']
                    out = hdl.execute('sh tunnel-encryption policy {0} | xml'.format(policy_name))
                    s = BeautifulSoup(out)
                    try:
                        window_size = s.find('window_size').string
                    except Exception as e:
                        log.error('Unable to get the window size . Failing the Test case:')
                        self.failed()

                        
            with steps.start('Changing the Window size:') as s:
                new_window_size = int(window_size)+ 1000
                cfg = '''tunnel-encryption policy {0}
                         window-size {1}'''.format(policy_name,new_window_size)
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure(cfg)
                    
            log.info('Waiting for 30 seconds before measuring the Tunnel-Encryption peer stats')
            countDownTimer(60)
 
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    log.info(banner('Reverting back the configs:'))
                    tunnel_status_flag = 1 
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_stats_fail_flag = 1
                    
                    
            with steps.start('Restore Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                        
                    if restore_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(restore_stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Key ID Length mininum only
class VxlanCloudSec_Func045(aetest.Testcase):

    """ Vxlan CloudSec - KEyId Length - Even only Func-045"""

    uid = 'VXLAN-CS-FUNC-045'

    @aetest.test
    def VxlanCloudSec_CKN_MinimumLength_FUNC040(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test45: Key ID Length mininum only'))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Finding the min Key-string Length from the configs.') as s:
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                min_length = []
                count = 1
                key_str = 'a'
                while (count <= 128):
                    key_id = count * key_str
                    log.info('the value of key_string is : {0}'.format(key_id))
                    cfg = '''key chain TEST tunnel-encryption
                             key {0}
                          '''.format(key_id)
                    out = site1_hdl.configure(cfg)
                    if re.search('invalid|exceed', out, re.I):
                        log.info('Key id of length {0} is invalid'.format(len(key_id)))
                    else:
                        min_length.append(key_id)
                        cfg = '''key chain TEST tunnel-encryption
                                 no key {0}
                                 '''.format(key_id)
                        out = site1_hdl.configure(cfg)
                        log.info('Minimal length of the key is : {0}'.format(min_length))
                    count+=1
                    
                log.info('The Value of min_length is : {0}'.format(min_length))
                length_res = [len(x) for x in min_length]
                log.info('the value of min_key_id_length is : {0}'.format(length_res[0]))
                log.info('the value of max_key_id_length is : {0}'.format(length_res[-1]))
                
                odd_flag = 0
                for i in length_res:
                    if not i % 2 == 0:
                        globa_flag =1 
                        odd_flag = 1
                    
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        

            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')
                    if odd_flag:
                        log.error('A Key with odd values are accepted. The accepted lenghts are: {0}'.format(length_res))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# SAK Expiry Timer- Valid Values
class VxlanCloudSec_Func046(aetest.Testcase):

    """ Vxlan CloudSec - SAK Expiry timer Func-046"""

    uid = 'VXLAN-CS-FUNC-046'

    @aetest.test
    def VxlanCloudSec_SakExpiryTimer_FUNC046(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test46: SAK Expiry Timer- Valid Values '))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        timer_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Checking the SAK Expiry timer') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                peer_ip = cloudsec_peer_per_dut[site1_dut][0]
                res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,site1_dut,site1_hdl,peer_ip)
                
                cfg = '''tunnel-encryption policy {0}
                         sak-rekey-time ?'''.format(res['policyname'])
                
                unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
                # unicon_state.add_state_pattern(pattern_list='^%\\s*[Ii]ncomplete (command|input)')
                unicon_state.add_state_pattern(pattern_list='.*')
                out = site1_hdl.configure(cfg)
                unicon_state.restore_state_pattern()
                
                pat = '<(\d)+-(\d)+>'
                
                
                match = re.search(pat,out,re.I)
                if match:
                    log.info('The value of match is : {0}'.format(match))
                    lower_limit = match.group(1)
                    upper_limit = match.group(2)
                    
                    if not int(lower_limit) == 1800 or int(upper_limt) == 2592000:
                        timer_flag =1 
                        
            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')
                    if timer_flag:
                        log.error('The Lower and Upper time limits are {0} and {1}'.format(lower_limit, upper_limit))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# XML Validation
class VxlanCloudSec_Func047(aetest.Testcase):

    """ Vxlan CloudSec - XML Validation Func-047"""

    uid = 'VXLAN-CS-FUNC-047'

    @aetest.test
    def VxlanCloudSec_SakExpiryTimer_FUNC046(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test47: XML Validation '))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        timer_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        xml_fail_list = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Checking the XML output for Tunnel-Encrpytion CLIs') as s:
                
                cli_list = ['sh tunnel-encryption info global','sh tunnel-encryption policy', 'sh tunnel-encryption session' ,\
                            'sh tunnel-encryption statistics']
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                peer_ip = cloudsec_peer_per_dut[site1_dut][0]
                res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,site1_dut,site1_hdl,peer_ip)
                
                for cfg in cli_list:
                    if re.search('peer_ip', cfg, re.I):
                        cfg = cfg + peer_ip
                    cfg = cfg + ' | ' + 'xml'
                    if re.search('global', cfg, re.I):
                        out = site1_hdl.configure(cfg)
                        s = BeautifulSoup(out)
                        try:
                            policy_mode = s.find('policy_mode').string
                            log.info('the value of policy_mode is : {0}'.format(policy_mode))
                            if not re.search('Secure', policy_mode,re.I):
                                xml_fail_list.append(cfg)
                        except Exception:
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            xml_fail_list.append(cfg)
                    elif re.search('policy', cfg, re.I):
                        p_name = res['policyname']
                        out = site1_hdl.configure(cfg)
                        s = BeautifulSoup(out)
                        try:
                            policy_name = s.find('name').string
                            log.info('the value of policy_name is : {0}'.format(policy_name))
                            if not re.search(p_name,policy_name,re.I):
                                xml_fail_list.append(cfg) 
                        except Exception:
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            xml_fail_list.append(cfg)
                    elif re.search('session', cfg, re.I):
                        peer_ip = res['peer_ip']
                        out = site1_hdl.configure(cfg)
                        s = BeautifulSoup(out)
                        try:
                            pip = s.find('peeraddr').string
                            log.info('the value of pip is : {0}'.format(pip))
                            if not re.search(pip,peer_ip,re.I):
                                xml_fail_list.append(cfg) 
                        except Exception:
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            xml_fail_list.append(cfg)                    
                    elif re.search('statistics', cfg, re.I):
                        out = site1_hdl.configure(cfg)
                        s = BeautifulSoup(out)
                        try:
                            tx_count = s.find('out_pkts_encrypted_protected').string
                            log.info('the value of tx_count is : {0}'.format(tx_count))
                        except Exception:
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            xml_fail_list.append(cfg)                          
                    
                
            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')
                    if timer_flag:
                        log.error('The Lower and Upper time limits are {0} and {1}'.format(lower_limit, upper_limit))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# JSON Validation
class VxlanCloudSec_Func048(aetest.Testcase):

    """ Vxlan CloudSec - JSON Validation Func-048"""

    uid = 'VXLAN-CS-FUNC-048'

    @aetest.test
    def VxlanCloudSec_SakExpiryTimer_FUNC048(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test48: JSON Validation '))
        
        
        global_flag = 0
        restore_flag = 0
        trigger_stats_fail_flag = 0
        tunnel_status_flag = 0
        json_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        xml_fail_list = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()


            with steps.start('Checking the JSON output for Tunnel-Encrpytion CLIs') as s:
                
                cli_list = ['sh tunnel-encryption info global','sh tunnel-encryption policy', 'sh tunnel-encryption session' ,\
                            'sh tunnel-encryption statistics']
                
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
                
                peer_ip = cloudsec_peer_per_dut[site1_dut][0]
                res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,site1_dut,site1_hdl,peer_ip)
                
                for cfg in cli_list:
                    if re.search('peer_ip', cfg, re.I):
                        cfg = cfg + peer_ip
                    cfg = cfg + ' | ' + 'json'
                    if re.search('global', cfg, re.I):
                        out = site1_hdl.execute(cfg)
                        try:
                            json_out = json.loads(out)
                            secure_policy = json_out['TABLE_tem_info_global']['ROW_tem_info_global']['policy_mode']
                            log.info('The value of secure_policy is : {0}'.format(secure_policy))
                            if not re.search('Secure', secure_policy, re.I):
                                xml_fail_list.append(cfg)
                        except Exception as e:
                            log.error('Exception is : {0}'.format(e))
                            log.error('Some Error occured while parsing the Json output')
                            xml_fail_list.append(cfg)
                            json_flag = 1

                    elif re.search('policy', cfg, re.I):
                        p_name = res['policyname']
                        plist = []
                        out = site1_hdl.execute(cfg)
                        try:
                            json_out = json.loads(out)
                            log.info('The value of json_out is : {0}'.format(json_out))
                            #log.info('1. json_out_TABLE_tun_enc_policy is:{0}'.format(json_out['TABLE_tun_enc_policy']))
                            #log.info('1. json_out_TABLE_tun_enc_policy_ROW_tun_enc_policy is:{0}'.format(json_out['TABLE_tun_enc_policy']['ROW_tun_enc_policy']))
                            policy_list = json_out['TABLE_tun_enc_policy']['ROW_tun_enc_policy']
                            log.info('The value of policy_list is : {0}'.format(policy_list))
                            for item in policy_list:
                                log.info('The value and type of item is : {0}'.format(item, type(item)))
                                pname = item['name']
                                plist.append(pname)
                            log.info('The value of plist is : {0}'.format(plist))
                            if not p_name in plist:
                                xml_fail_list.append(cfg) 
                        except Exception as e:
                            log.error('Exception is : {0}'.format(e))
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            xml_fail_list.append(cfg) 
                            json_flag = 1
                    elif re.search('session', cfg, re.I):
                        peer_ip = res['peer_ip']
                        out = site1_hdl.execute(cfg)
                        try:
                            json_out = json.loads(out)
                            pip = json_out['TABLE_tem_session_detail']['ROW_tem_session_detail']['PeerAddr']
                            log.info('the value of pip is : {0}'.format(pip))
                            if not re.search(pip,peer_ip,re.I):
                                xml_fail_list.append(cfg) 
                        except Exception as e:
                            log.error('Exception is : {0}'.format(e))
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            xml_fail_list.append(cfg)
                            json_flag = 1
                            
                    elif re.search('statistics', cfg, re.I):
                        out = site1_hdl.execute(cfg)
                        try:
                            json_out = json.loads(out)
                            tx_count = json_out['TABLE_statistics']['ROW_statistics']['TABLE_tx_sa_an']['ROW_tx_sa_an']['out_pkts_encrypted_protected']
                            log.info('the value of tx_count is : {0}'.format(tx_count))
                        except Exception as e:
                            log.error('Exception is : {0}'.format(e))
                            log.error('xml output does not contain policy_mode.. Adding to the fail list...')
                            json_fail_list.append(cfg)
                            json_flag = 1
                            
                    
                
            log.info('Waiting for 60 seconds before measuring the Traffic status')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    restore_flag = 1
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_status_flag:
                        log.error('The Tunnel-Encrypttion Status is not as expected after changing the key')
                    if trigger_stats_fail_flag:
                        log.error('The traffic Stats was not as expected. failed stream were {0}'.format(stats_fail_stream))
                    if restore_flag:
                        log.error('The Traffic stats is not proper after restoring the configs.')
                    if json_flag:
                        log.error('The Json output failed for the following cfgs: {0}'.format(json_fail_list))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Traffic of Various Frame Szie : TEST-015-TEST020
class VxlanCloudSec_Func049(aetest.Testcase):

    """ Vxlan MS-CloudSec-VariousFrameSize- Func-049"""

    uid = 'VXLAN-CS-FUNC-049'

    @aetest.test
    def VxlanCS_VariousFrameSize_Func049(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test49:- Generating Traffic of Various Frame Szie : TEST-015-TEST020'))
        
        global_flag = 0
        restore_flag = 0
        trigger_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        stream_create_flag = 0
        new_tg_interface_hdl_dict= {}
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Changing Cipher Suite to GCM-AES-XPN-128') as s:
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut][0]
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                    cfg = '''tunnel-encryption policy {0}
                             cipher-suite GCM-AES-XPN-128'''.format(res['policyname'])
                    hdl.configure(cfg)
                
            with steps.start('Configuring System Jumbo on all boxes') as s:
                for dut in node_dict['all_dut'].keys():
                    if re.search('uut', dut, re.I):
                        hdl = node_dict['all_dut'][dut]
                        hdl.configure('system jumbomtu 9100')
                    
            with steps.start('Configuring MTU on all the interfaces on all dut') as s:
                for dut in node_dict['all_dut'].keys():
                    if re.search('uut',dut,re.I):
                        hdl = node_dict['all_dut'][dut]
                        for intf in alias_intf_mapping[dut].keys():
                            cfg = '''interface {0}
                                     mtu 9100'''.format(alias_intf_mapping[dut][intf])
                            hdl.configure(cfg)
            
            with steps.start('configuring the JumboQOS policy') as s:
                for dut in node_dict['all_dut'].keys():
                    if re.search('uut',dut,re.I):
                        hdl = node_dict['all_dut'][dut]
                        cfg = '''policy-map type network-qos jumboMTU
                                class type network-qos class-default
                                mtu 9100
                                system qos
                                service-policy type network-qos jumboMTU'''
                        hdl.configure(cfg)
                
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : TEST-015 to TEST-020')
                traffic_item_list = ['TEST015','TEST016','TEST017','TEST018','TEST019','TEST020']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : TEST015-TEST020')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
                if stats_fail_stream:
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Traffic of Various Frame Szie - Cipher Suite 256: TEST-015-TEST020
class VxlanCloudSec_Func050(aetest.Testcase):

    """ Vxlan MS-CloudSec-VariousFrameSize- Func-050"""

    uid = 'VXLAN-CS-FUNC-050'

    @aetest.test
    def VxlanCS_VariousFrameSize_Func050(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test50:- Generating Traffic of Various Frame Szie - Cipher Suite 256: TEST-015-TEST020'))
        
        global_flag = 0
        restore_flag = 0
        trigger_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        stream_create_flag = 0
        new_tg_interface_hdl_dict= {}
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Changing Cipher Suite to GCM-AES-XPN-256') as s:
                cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut][0]
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                    cfg = '''tunnel-encryption policy {0}
                             cipher-suite GCM-AES-XPN-256'''.format(res['policyname'])
                    hdl.configure(cfg)
                
            with steps.start('Configuring System Jumbo on all boxes') as s:
                for dut in node_dict['all_dut'].keys():
                    if re.search('uut', dut, re.I):
                        hdl = node_dict['all_dut'][dut]
                        hdl.configure('system jumbomtu 9100')
                    
            with steps.start('Configuring MTU on all the interfaces on all dut') as s:
                for dut in node_dict['all_dut'].keys():
                    if re.search('uut',dut,re.I):
                        hdl = node_dict['all_dut'][dut]
                        for intf in alias_intf_mapping[dut].keys():
                            cfg = '''interface {0}
                                     mtu 9100'''.format(alias_intf_mapping[dut][intf])
                            hdl.configure(cfg)
            
            with steps.start('configuring the JumboQOS policy') as s:
                for dut in node_dict['all_dut'].keys():
                    if re.search('uut',dut,re.I):
                        hdl = node_dict['all_dut'][dut]
                        cfg = '''policy-map type network-qos jumboMTU
                                class type network-qos class-default
                                mtu 9100
                                system qos
                                service-policy type network-qos jumboMTU'''
                        hdl.configure(cfg)
                
            with steps.start('Creating Ixia-Interfaces on TGEN - set 1') as s:
                log.info('Creating Ixia-Interfaces on TGEN : TEST-015 to TEST-020')
                traffic_item_list = ['TEST015','TEST016','TEST017','TEST018','TEST019','TEST020']     
                #traffic_item_list = ['TRF011']
                for item in traffic_item_list:
                    new_tg_interface_hdl_dict[TG][item] = {}
                    log.info(banner('Creating Interfaces on TGEN for Traffic Item :- {0}'.format(item)))
                    for TGInt in tgn_config_dict[TG][item]['tg_interface_config_dict'].keys():
                        ixia_intf_ip_list = []
                        new_tg_interface_hdl_dict[TG][item][TGInt] = {}
                        args = tgn_config_dict[TG][item]['tg_interface_config_dict'][TGInt]
                        intf_args = generateTrafficGenIntfConfigs(log, args)
                        for i,j in enumerate(intf_args):
                            a = intf_args[i]
                            ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=tgn_hdl,port_handle=port_handle_dict[TGInt])
                            for b in ixia_interface_config:
                                ixia_intf_ip_list.append(b)
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]={}
                                new_tg_interface_hdl_dict[TG][item][TGInt][b]['handle']=ixia_interface_config[b]
                            new_tg_interface_hdl_dict[TG][item][TGInt]['ip_list']=ixia_intf_ip_list
                            
            with steps.start('Creating Traffic Streams on TGEN - set 1') as s:
                log.info('Creating Traffic Streams on TGEN : TEST015-TEST020')
                
                new_traffic_stream_dict = {}
                for item in traffic_item_list:
                    src_handle = []
                    dest_handle = []
                    new_traffic_stream_dict[item] = {}
                    log.info(banner('Creating Traffic Streams on TGEN for Traffic Item {0}'.format(item)))
                    source = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    for port in source:
                        for p in new_tg_interface_hdl_dict[TG][item]:
                            if p == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][p]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][p][ip]['handle']
                                        src_handle.append(handle)
                    for port in receiver:
                        for q in new_tg_interface_hdl_dict[TG][item]:
                            if q == port:
                                 pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                 for ip in new_tg_interface_hdl_dict[TG][item][q]:
                                    test = pat.match(ip)
                                    if test:
                                        handle = new_tg_interface_hdl_dict[TG][item][q][ip]['handle']
                                        dest_handle.append(handle)                                 
                        
                    log.info('The value of source_handle is : {0}'.format(src_handle))
                    log.info('The value of dest_handle is : {0}'.format(dest_handle))
                    ixia_traffic_config = configureIxNetworkTraffic(self, args, tg_hdl=tgn_hdl, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                    new_traffic_stream_dict[item]['source'] = source
                    new_traffic_stream_dict[item]['destination'] = receiver
                    new_traffic_stream_dict[item]['stream_id'] = ixia_traffic_config.stream_id
                    new_traffic_stream_dict[item]['traffic_item'] = ixia_traffic_config.traffic_item
                    new_traffic_stream_dict[item]['status'] = ixia_traffic_config.status
                
            with steps.start('Starting the Created Traffic Stream one by one') as s:
                log.info(banner('Starting the Created Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_traffic_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in new_traffic_stream_dict.keys():
                    ixia_stream = new_traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in new_traffic_stream_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(new_traffic_stream_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_traffic_stream_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(new_traffic_stream_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
                if stats_fail_stream:
                    for item in stats_fail_stream:
                        log.info('Removing the stream {0}:'.format(new_traffic_stream_dict[item]['stream_id']))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=new_traffic_stream_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Generating Traffic of Various Frame Szie - Cipher Suite 256: TEST-015-TEST020
class VxlanCloudSec_Func051(aetest.Testcase):

    """ Vxlan MS-CloudSec-AddingNewKeyID- Func-051"""

    uid = 'VXLAN-CS-FUNC-051'

    @aetest.test
    def VxlanCS_AddNewKeyID_Func051(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test50:- Generating Traffic of Various Frame Szie - Cipher Suite 256: TEST-015-TEST020'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        stream_create_flag = 0
        key_validity_flag = 0
        new_tg_interface_hdl_dict= {}
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                    
                        new_mins = int(mins) + 5
                        if new_mins > 60:
                            new_mins = new_mins - 60
                            hour = int(hour) + 1
                            if hour > 24:
                                hour = hour - 24
                                date = int(date)+1
                        
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,new_mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 3 mins before adding a new key ')
                        countDownTimer(180)
                        
                        log.info('Adding a new Key when the old key is about to expire')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            new_mins1 = int(mins)+3
                            if new_mins1 > 60:
                                new_mins1 = new_mins1 - 60
                                hour = int(hour)  + 1
                                if hour > 24:
                                    hour = hour - 24
                                    date = int(date) + 1
                                    
                            
                            cfg2 = '''key chain KC0012 tunnel-encryption
                                     key 22
                                     key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                     send-lifetime {0}:{1}:{2} {3} {4} {5} infinite'''.format(hour,new_mins1,secs,mon,date,year)
                                     
                            hdl.configure(cfg2)
                            
                        log.info('waiting for 120 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(120)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if not res:
                            log.error('CloudSec Peer is not expected after configuring the New KC policy')
                            tunnel_flag = 1
                            global_flag = 1
                            
                        if not tunnel_flag:
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                out = hdl.execute('show key chain | json')
                                json_out = json.loads(out)
                                for item in json_out['TABLE_keychain']['ROW_keychain']:
                                    if re.search('KC00',item['chain_name'],re.I):
                                        for sub_item in item['TABLE_key']['ROW_key']:
                                            log.info('The value of sub_item is : {0}'.format(sub_item))
                                            if re.search('11',sub_item['key_id'],re.I):
                                                old_key_validity = sub_item['send_valid']
                                            if re.search('22',sub_item['key_id'],re.I):
                                                new_key_validity = sub_item['send_valid']
                                if old_key_validity == 'false' and new_key_validity == 'true':
                                    log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                    
                                    if not out:
                                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                        traffic_flag = 1
                                        global_flag = 1
                                else:
                                    log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                    key_validity_flag = 1
                                    global_flag = 1
                                            
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if key_validity_flag:
                            log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity.new_key_validity)))
                        if trigger_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if restore_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Add New KEy ID with same life time as the previous key ID
class VxlanCloudSec_Func052(aetest.Testcase):

    """ Vxlan MS-CloudSec-AddingNewKeyID- Func-052"""

    uid = 'VXLAN-CS-FUNC-052'

    @aetest.test
    def VxlanCS_AddNewKeyID_Func052(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test52:- Add New KEy ID with same life time as the previous key ID'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        stream_create_flag = 0
        key_validity_flag = 0
        new_tg_interface_hdl_dict= {}
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        year = int(year) + 1
                    

                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 3 mins before adding a new key ')
                        countDownTimer(180)
                        
                        log.info('Adding a new Key with the same lifetime as the previous key')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            cfg2 = '''key chain KC0012 tunnel-encryption
                                     key 22
                                     key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                     send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                                     
                            hdl.configure(cfg2)
                            
                        log.info('waiting for 120 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(120)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if not res:
                            log.error('CloudSec Peer is not expected after configuring the New KC policy')
                            tunnel_flag = 1
                            global_flag = 1
                            
                        if not tunnel_flag:
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                out = hdl.execute('show key chain | json')
                                json_out = json.loads(out)
                                for item in json_out['TABLE_keychain']['ROW_keychain']:
                                    if re.search('KC00',item['chain_name'],re.I):
                                        for sub_item in item['TABLE_key']['ROW_key']:
                                            log.info('The value of sub_item is : {0}'.format(sub_item))
                                            if re.search('11',sub_item['key_id'],re.I):
                                                old_key_validity = sub_item['send_valid']
                                            if re.search('22',sub_item['key_id'],re.I):
                                                new_key_validity = sub_item['send_valid']
                                if old_key_validity == 'true' and new_key_validity == 'true':
                                    log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                    
                                    if not out:
                                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                        traffic_flag = 1
                                        global_flag = 1
                                else:
                                    log.error(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                    key_validity_flag = 1
                                    global_flag = 1
                                            
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if key_validity_flag:
                            log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity.new_key_validity)))
                        if traffic_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if restore_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Deleting Active Key when New KEy is available
class VxlanCloudSec_Func053(aetest.Testcase):

    """ Vxlan MS-CloudSec-DeletingActiveKey When New KEy Available- Func-053"""

    uid = 'VXLAN-CS-FUNC-053'

    @aetest.test
    def VxlanCS_DeletingActiveKeyWhenNewKeyAvailable_Func052(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test53:- Deleting Active Key when New KEy is available.'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        stream_create_flag = 0
        key_validity_flag = 0
        new_tg_interface_hdl_dict= {}
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 3 mins before adding a new key ')
                        countDownTimer(180)
                        
                        log.info('Adding a new Key with the same lifetime as the previous key')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            year = int(year) + 1
                            cfg2 = '''key chain KC0012 tunnel-encryption
                                     key 22
                                     key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                     send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5} '''.format(hour,mins,secs,mon,date,year)
                                     
                            hdl.configure(cfg2)
                            
                        log.info('waiting for 120 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(120)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if not res:
                            log.error('CloudSec Peer is not expected after configuring the New KC policy')
                            tunnel_flag = 1
                            global_flag = 1
                            
                        if not tunnel_flag:
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                out = hdl.execute('show key chain | json')
                                json_out = json.loads(out)
                                for item in json_out['TABLE_keychain']['ROW_keychain']:
                                    if re.search('KC00',item['chain_name'],re.I):
                                        for sub_item in item['TABLE_key']['ROW_key']:
                                            log.info('The value of sub_item is : {0}'.format(sub_item))
                                            if re.search('11',sub_item['key_id'],re.I):
                                                old_key_validity = sub_item['send_valid']
                                            if re.search('22',sub_item['key_id'],re.I):
                                                new_key_validity = sub_item['send_valid']
                                if old_key_validity == 'true' and new_key_validity == 'true':
                                    log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                    
                                    if not out:
                                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                        traffic_flag = 1
                                        global_flag = 1
                                else:
                                    log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                    key_validity_flag = 1
                                    global_flag = 1
                            
                            log.info(banner('Deleting the previous active key on duts:'))
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                cfg = '''key chain KC0012 tunnel-encryption
                                         no key 11'''
                                hdl.configure(cfg)
                                
                            log.info(banner('Waiting for 30 seconds before checking CloudSec Session and stats:'))
                            
                            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile) 
                            
                            if not res:
                                log.error('CloudSec Peer is not expected after configuring the New KC policy')
                                tunnel_flag = 1
                                global_flag = 1
                            
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if not out:
                                log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_stat_fail_flag:
                        if key_validity_flag:
                            log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity.new_key_validity)))
                        if trigger_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                            self.failed()
                        if restore_flag:
                            log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                            self.failed()
                    elif trigger_flag:
                        log.error('Traffic drop was expected but Traffic was seen')
                        log.error('The folllwing stream had problems {0}'.format(trigger_fail_stream))
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Deleting Active Key when New KEy is NOT available
class VxlanCloudSec_Func054(aetest.Testcase):

    """ Vxlan MS-CloudSec-DeletingActiveKey When New KEy Not Available- Func-054"""

    uid = 'VXLAN-CS-FUNC-054'

    @aetest.test
    def VxlanCS_DeletingActiveKeyWhenNewKeyNotAvailable_Func054(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test54:- Deleting Active Key when New KEy is NOT available.'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        stream_start_flag = 0
        stream_stop_flag = 0
        stream_stat_fail_flag = 0
        stream_create_flag = 0
        key_validity_flag = 0
        new_tg_interface_hdl_dict= {}
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            
            new_tg_interface_hdl_dict[TG] = {}
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 30 secs before removing the key ')
                        countDownTimer(30)
                        
                        log.info('Deleting the KeyID from Newly Created KeyChain')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            year = int(year) + 1
                            cfg2 = '''key chain KC0012 tunnel-encryption
                                     no key 11'''
                                     
                            hdl.configure(cfg2)
                            
                        log.info('waiting for 30 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(30)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if res:
                            log.error('Tunnel-Session was expected to go down But does not seem to go. .. ')
                            tunnel_flag = 1
                            global_flag = 1

                        if not res:
                            log.info('Tunnel-Session is down as expected..Proceeding with traffic measurement.')
                                 
                            log.info(banner('Measuring the Traffic after removing the Key (or) Tunnel-Session went down.'))
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            log.info('The value of out is : {0}'.format(out))
                            #traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            #traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if out:
                                log.error(banner('Traffic Drop was expected. But still seen. .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                            else:
                                
                                log.info(banner('Adding the key back on the DUTS::'))
                                for dut in bgw_dict.keys():
                                    hdl = node_dict['all_dut'][dut]
                                    cfg1 = '''key chain KC0012 tunnel-encryption
                                             key 11
                                             key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                             send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                                    hdl.configure(cfg1)
                                
                            log.info(banner('Waiting for 30 seconds before checking CloudSec Session and stats:'))
                            countDownTimer(30)
                            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile) 
                            
                            if not res:
                                log.error('CloudSec Peer is not expected after configuring the New KC policy')
                                tunnel_flag = 1
                                global_flag = 1
                            
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if not out:
                                log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Change active key start time to future while next new key is available
class VxlanCloudSec_Func055(aetest.Testcase):

    """ Vxlan MS-CloudSec-Change active key start time to future while next new key is available- Func-055"""

    uid = 'VXLAN-CS-FUNC-055'

    @aetest.test
    def VxlanCS_ChangeActiveKeyWhenNewKeyAvailable_Func055(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test55:- Change active key start time to future while next new key is available'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 3 mins before adding a new key ')
                        countDownTimer(180)
                        
                        log.info('Adding a new Key with the same lifetime as the previous key')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            year = int(year) + 1
                            cfg2 = '''key chain KC0012 tunnel-encryption
                                     key 22
                                     key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                     send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5} '''.format(hour,mins,secs,mon,date,year)
                                     
                            hdl.configure(cfg2)
                            
                        log.info('waiting for 120 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(120)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if not res:
                            log.error('CloudSec Peer is not expected after configuring the New KC policy')
                            tunnel_flag = 1
                            global_flag = 1
                            
                        if not tunnel_flag:
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                out = hdl.execute('show key chain | json')
                                json_out = json.loads(out)
                                for item in json_out['TABLE_keychain']['ROW_keychain']:
                                    if re.search('KC00',item['chain_name'],re.I):
                                        for sub_item in item['TABLE_key']['ROW_key']:
                                            log.info('The value of sub_item is : {0}'.format(sub_item))
                                            if re.search('11',sub_item['key_id'],re.I):
                                                old_key_validity = sub_item['send_valid']
                                            if re.search('22',sub_item['key_id'],re.I):
                                                new_key_validity = sub_item['send_valid']
                                if old_key_validity == 'true' and new_key_validity == 'true':
                                    log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                    
                                    if not out:
                                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                        traffic_flag = 1
                                        global_flag = 1
                                else:
                                    log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                    key_validity_flag = 1
                                    global_flag = 1
                            
                            log.info(banner('Setting the first key to future start time:'))
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                cfg = '''key chain KC0012 tunnel-encryption
                                         key 11
                                         send-lifetime 00:00:00 Jan 01 2022 {0}:{1}:{2} {3} {4} {5} '''.format(hour,mins,secs,mon,date,year)
                                hdl.configure(cfg)
                                
                            log.info(banner('Waiting for 30 seconds before checking CloudSec Session and stats:'))
                            countDownTimer(30)
                            
                            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile) 
                            
                            if not res:
                                log.error('CloudSec Peer is not expected after configuring the New KC policy')
                                tunnel_flag = 1
                                global_flag = 1
                            
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if not out:
                                log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                            else:
                                for dut in bgw_dict.keys():
                                    hdl = node_dict['all_dut'][dut]
                                    log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                    out = hdl.execute('show key chain | json')
                                    json_out = json.loads(out)
                                    for item in json_out['TABLE_keychain']['ROW_keychain']:
                                        if re.search('KC00',item['chain_name'],re.I):
                                            for sub_item in item['TABLE_key']['ROW_key']:
                                                log.info('The value of sub_item is : {0}'.format(sub_item))
                                                if re.search('11',sub_item['key_id'],re.I):
                                                    old_key_validity = sub_item['send_valid']
                                                if re.search('22',sub_item['key_id'],re.I):
                                                    new_key_validity = sub_item['send_valid']
                                    if old_key_validity == 'false' and new_key_validity == 'true':
                                        log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    else:
                                        log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                        global_flag = 1
                                        key_validity_flag = 1
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if key_validity_flag:
                        log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                    if traffic_flag:
                        log.error('FAIL- Traffic Test Failed on streams {0} after Site1 : MustSecure Site2: ShouldSecure'.format(stats_fail_stream_post_trigger))
                        self.failed()
                    if restore_flag:
                        log.error('FAIL- Traffic Test Failed on streams {0} after restoring both sites as MustSecure'.format(stats_fail_stream))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Deleting Active Key when New KEy is NOT available
class VxlanCloudSec_Func056(aetest.Testcase):

    """ Vxlan MS-CloudSec-ChangingActiveKey StartTime to Future When New KEy Not Available- Func-056"""

    uid = 'VXLAN-CS-FUNC-056'

    @aetest.test
    def VxlanCS_ChangingActiveKeyToFutureWhenNewKeyNotAvailable_Func056(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test54:- Deleting Active Key when New KEy is NOT available.'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 30 secs before setting the Key Validity in Future ')
                        countDownTimer(30)
                        
                        log.info('Setting the Key Validity to future.')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            test_year = 2035
                            cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2030 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,test_year)
                                     
                            hdl.configure(cfg1)
                            
                        log.info('waiting for 30 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(30)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if res:
                            log.error('Tunnel-Session was expected to go down But does not seem to go. .. ')
                            tunnel_flag = 1
                            global_flag = 1

                        if not res:
                            log.info('Tunnel-Session is down as expected..Proceeding with traffic measurement.')
                                 
                            log.info(banner('Measuring the Traffic after removing the Key (or) Tunnel-Session went down.'))
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            log.info('The value of out is : {0}'.format(out))
                            #traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            #traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if out:
                                log.error(banner('Traffic Drop was expected. But still seen. .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                            else:
                                
                                log.info(banner('Adding the key back on the DUTS::'))
                                for dut in bgw_dict.keys():
                                    hdl = node_dict['all_dut'][dut]
                                    year = int(year) + 1
                                    cfg1 = '''key chain KC0012 tunnel-encryption
                                             key 11
                                             key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                             send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                                    hdl.configure(cfg1)
                                
                            log.info(banner('Waiting for 30 seconds before checking CloudSec Session and stats:'))
                            countDownTimer(30)
                            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile) 
                            
                            if not res:
                                log.error('CloudSec Peer is not expected after configuring the New KC policy')
                                tunnel_flag = 1
                                global_flag = 1
                            
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if not out:
                                log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Change active key start time to Past while next new key is available
class VxlanCloudSec_Func057(aetest.Testcase):

    """ Vxlan MS-CloudSec-Change active key start time to Past while next new key is available- Func-057"""

    uid = 'VXLAN-CS-FUNC-057'

    @aetest.test
    def VxlanCS_ChangeActiveKeyWhenNewKeyAvailable_Func055(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test55:- Change active key start time to Past while next new key is available'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 3 mins before adding a new key ')
                        countDownTimer(180)
                        
                        log.info('Adding a new Key with the same lifetime as the previous key')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            year = int(year) + 1
                            cfg2 = '''key chain KC0012 tunnel-encryption
                                     key 22
                                     key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                     send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5} '''.format(hour,mins,secs,mon,date,year)
                                     
                            hdl.configure(cfg2)
                            
                        log.info('waiting for 120 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(120)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if not res:
                            log.error('CloudSec Peer is not expected after configuring the New KC policy')
                            tunnel_flag = 1
                            global_flag = 1
                            
                        if not tunnel_flag:
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                out = hdl.execute('show key chain | json')
                                json_out = json.loads(out)
                                for item in json_out['TABLE_keychain']['ROW_keychain']:
                                    if re.search('KC00',item['chain_name'],re.I):
                                        for sub_item in item['TABLE_key']['ROW_key']:
                                            log.info('The value of sub_item is : {0}'.format(sub_item))
                                            if re.search('11',sub_item['key_id'],re.I):
                                                old_key_validity = sub_item['send_valid']
                                            if re.search('22',sub_item['key_id'],re.I):
                                                new_key_validity = sub_item['send_valid']
                                if old_key_validity == 'true' and new_key_validity == 'true':
                                    log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                    
                                    if not out:
                                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                        traffic_flag = 1
                                        global_flag = 1
                                else:
                                    log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                    key_validity_flag = 1
                                    global_flag = 1
                            
                            log.info(banner('Setting the first key to future start time:'))
                            for dut in bgw_dict.keys():
                                hdl = node_dict['all_dut'][dut]
                                cfg = '''key chain KC0012 tunnel-encryption
                                         key 11
                                         send-lifetime 00:00:00 Jan 01 2020 {0}:{1}:{2} {3} {4} 2020 '''.format(hour,mins,secs,mon,date)
                                hdl.configure(cfg)
                                
                            log.info(banner('Waiting for 30 seconds before checking CloudSec Session and stats:'))
                            countDownTimer(30)
                            
                            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile) 
                            
                            if not res:
                                log.error('CloudSec Peer is not expected after configuring the New KC policy')
                                tunnel_flag = 1
                                global_flag = 1
                            
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if not out:
                                log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                            else:
                                for dut in bgw_dict.keys():
                                    hdl = node_dict['all_dut'][dut]
                                    log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                                    out = hdl.execute('show key chain | json')
                                    json_out = json.loads(out)
                                    for item in json_out['TABLE_keychain']['ROW_keychain']:
                                        if re.search('KC00',item['chain_name'],re.I):
                                            for sub_item in item['TABLE_key']['ROW_key']:
                                                log.info('The value of sub_item is : {0}'.format(sub_item))
                                                if re.search('11',sub_item['key_id'],re.I):
                                                    old_key_validity = sub_item['send_valid']
                                                if re.search('22',sub_item['key_id'],re.I):
                                                    new_key_validity = sub_item['send_valid']
                                    if old_key_validity == 'false' and new_key_validity == 'true':
                                        log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                    else:
                                        log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                        global_flag = 1
                                        key_validity_flag = 1
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if key_validity_flag:
                        log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity.new_key_validity)))
                    if traffic_flag:
                        log.error('FAIL- Traffic Test Failed after Trigger. Refer Logs.')
                    if restore_flag:
                        log.error('FAIL- Traffic Test Failed  after restoring both sites as MustSecure')
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Chaning Active Key to Past when New KEy is NOT available
class VxlanCloudSec_Func058(aetest.Testcase):

    """ Vxlan MS-CloudSec-ChangingActiveKey StartTime to Past When New KEy Not Available- Func-056"""

    uid = 'VXLAN-CS-FUNC-058'

    @aetest.test
    def VxlanCS_ChangingActiveKeyToPastWhenNewKeyNotAvailable_Func056(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test54:- Chaning Active Key to Past when New KEy is NOT available.'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 30 secs before removing the key ')
                        countDownTimer(30)
                        
                        log.info('Setting the Key Validity to Past.')
                        
                        for dut in bgw_dict.keys():
                            hdl = node_dict['all_dut'][dut]
                            hdl.execute('show clock')
                            test_year = 2020
                            cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2019 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,test_year)
                                     
                            hdl.configure(cfg1)
                            
                        log.info('waiting for 30 seconds before checking the tunnel-encrytion session status:')
                        countDownTimer(30)
                        res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                        if res:
                            log.error('Tunnel-Session was expected to go down But does not seem to go. .. ')
                            tunnel_flag = 1
                            global_flag = 1

                        if not res:
                            log.info('Tunnel-Session is down as expected..Proceeding with traffic measurement.')
                                 
                            log.info(banner('Measuring the Traffic after removing the Key (or) Tunnel-Session went down.'))
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            log.info('The value of out is : {0}'.format(out))
                            #traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            #traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if out:
                                log.error(banner('Traffic Drop was expected. But still seen. .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                            else:
                                
                                log.info(banner('Adding the key back on the DUTS::'))
                                for dut in bgw_dict.keys():
                                    hdl = node_dict['all_dut'][dut]
                                    year = int(year) + 1
                                    cfg1 = '''key chain KC0012 tunnel-encryption
                                             key 11
                                             key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                             send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                                    hdl.configure(cfg1)
                                
                            log.info(banner('Waiting for 30 seconds before checking CloudSec Session and stats:'))
                            countDownTimer(30)
                            res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile) 
                            
                            if not res:
                                log.error('CloudSec Peer is not expected after configuring the New KC policy')
                                tunnel_flag = 1
                                global_flag = 1
                            
                            out = trigger_obj.checkAllStreamStats(tgn_hdl)
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            
                            if not out:
                                log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                                traffic_flag = 1
                                global_flag = 1
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Key Mask
class VxlanCloudSec_Func059(aetest.Testcase):

    """ Vxlan MS-CloudSec-Key is masked- Func-059"""

    uid = 'VXLAN-CS-FUNC-059'

    @aetest.test
    def VxlanCS_KeyMask_Func059(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test59:- Key Mask.'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        mask_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)

            with steps.start('Configuring cli key-chain tunnelencrypt-psk no-show on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'key-chain tunnelencrypt-psk no-show'
                    hdl.configure(cfg)                

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the New KeyChain') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1

            with steps.start('Verifying the Key String Value') as s:
                if not traffic_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the key ')
                    countDownTimer(30)
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    peer_ip = cloudsec_peer_per_dut[site1_dut][0]
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,site1_dut,site1_hdl,peer_ip)
                    
                    key_chain_name = res['keychainname']
  
                    cmd1 = 'sh run | sec "key chain {0} tunnel-encryption" '.format(key_chain_name)
                    cmd2 = 'sh run all | sec "key chain {0} tunnel-encryption" '.format(key_chain_name)
                    
                    
                    for cmd in [cmd1,cmd2]:
                    
                        log.info('The value of cmd is : {0}'.format(cmd))
                        
                        out = site1_hdl.execute(cmd)
                        pat = 'key-octet-string\s+\d\s+([*|a-f0-9]*)\scryptographic-algorithm\s+\w+'
                        match = re.search(pat,out,re.I)
                        if match:
                            key_string = match.group(1)
                            log.info('The value of Key_String is: {0}'.format(key_string))
                            if re.search('\*\*\*\*\*\*',key_string,re.I):
                                log.info('The key String is masked as expected.. The Value of key String is : {0}'.format(key_string))
                            else:
                                log.info('The Key string is not masked.. Key String is : {0}'.format(key_string))
                                mask_flag = 1
                                global_flag =1                        
          
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Removing KeyChain From active CloudSEc sesison
class VxlanCloudSec_Func060(aetest.Testcase):

    """ Vxlan MS-CloudSec-Remoivng Key chian associated with active tunnel-encryption session Func-060"""

    uid = 'VXLAN-CS-FUNC-060'

    @aetest.test
    def VxlanCS_RemovekeyChainFromActiveCS_Session_Func060(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test59:- Removing KeyChain From active CloudSEc sesison'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        keychain_remove_flag = 0
        mask_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        date = int(date) + 1
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,mon,date,year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the New KeyChain') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1

            with steps.start('Verifying the Key Chain Removal from active tunnel-Encryption session') as s:
                if not traffic_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the key ')
                    countDownTimer(30)
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    cmd = 'no key chain KC0012 tunnel-encryption'
                
                    out = site1_hdl.configure(cmd)
                    pat = 'Keychain is associated with Tunnel-encryption client'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info(banner('KeyChain removal is not allowed as expected'))
                        log.info(banner('Measuing Traffic just to be on safer side...'))
                        out = trigger_obj.checkAllStreamStats(tgn_hdl)
                        if not out:
                            log.error(banner('Traffic  Stream stats is not as expected after the end of the trigger .. Traffic status in Table format is: .. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            global_flag = 1
                            traffic_flag = 1
                    else:
                        log.info(banner('KeyChain removal Error msg is not seen..'))
                        cmd = 'show run | grep "key chain KC0012 tunnel-encryption"'
                        out = site1_hdl.execute(cmd)
                        if re.search('KC0012',out,re.I):
                            log.info(banner('ERROR CASE:- Keychain KC0012 is still found on Running config'))
                        global_flag = 1
                        keychain_remove_flag = 1
              
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if keychain_remove_flag:
                        log.error('KeyChain Removal Error message was not seen. Refer Logs. ')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# CVerify key id selection with overlapping key lifetime
class VxlanCloudSec_Func061(aetest.Testcase):

    """ Vxlan MS-CloudSec-Verify key id selection with overlapping key lifetime - Func-061"""

    uid = 'VXLAN-CS-FUNC-061'

    @aetest.test
    def VxlanCS_KeyIDSelectionWithOverlappingKeyLifetime_Func055(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test61:- CVerify key id selection with overlapping key lifetime'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic after changing the tunnel-Encrpytion keyChain') as s:     
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 30 secs before adding a new key ')
                        countDownTimer(30)
                        
            with steps.start('Adding new key with overlapping Key Life time') as s:
                if not traffic_flag:
                    log.info('Adding a new Key with the same lifetime as the previous key')
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        hdl.execute('show clock')
                        new_date = curr_date + timedelta(days = 7)
                        cfg2 = '''key chain KC0012 tunnel-encryption
                                 key 22
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5} '''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                                 
                        hdl.configure(cfg2)
                            
            log.info('waiting for 120 seconds before checking the tunnel-encrytion session status:')
            countDownTimer(120)
            
            with steps.start('Verify Tunnel-Encryption Session after adding a new Key ID') as s:
                if not traffic_flag:
                    res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                    if not res:
                        log.error('CloudSec Peer is not expected after configuring the New KC policy')
                        tunnel_flag = 1
                        global_flag = 1
                        
            with steps.start('Verify KeyID Validity:') as s:       
                if not tunnel_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                        out = hdl.execute('show key chain | json')
                        json_out = json.loads(out)
                        for item in json_out['TABLE_keychain']['ROW_keychain']:
                            if re.search('KC00',item['chain_name'],re.I):
                                for sub_item in item['TABLE_key']['ROW_key']:
                                    log.info('The value of sub_item is : {0}'.format(sub_item))
                                    if re.search('11',sub_item['key_id'],re.I):
                                        old_key_validity = sub_item['send_valid']
                                    if re.search('22',sub_item['key_id'],re.I):
                                        new_key_validity = sub_item['send_valid']
                        if old_key_validity == 'true' and new_key_validity == 'true':
                            log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                        else:
                            log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                            key_validity_flag = 1
                            global_flag = 1
            
            with steps.start('Verifying Traffic after adding the Overlapping Key') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        success_stream_list.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        fail_stream_list.append(item)
                        
                if fail_stream_list:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if key_validity_flag:
                        log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity.new_key_validity)))
                    if traffic_flag:
                        log.error('FAIL- Traffic Test Failed after Trigger. Refer Logs.')
                    if restore_flag:
                        log.error('FAIL- Traffic Test Failed  after restoring both sites as MustSecure')
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# CVerify key id selection with overlapping key lifetime
class VxlanCloudSec_Func062(aetest.Testcase):

    """ Vxlan MS-CloudSec-ChangeKeyLifeTime - Func-062"""

    uid = 'VXLAN-CS-FUNC-062'

    @aetest.test
    def VxlanCS_ChangeKeyLifeTime_Func062(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test62:- CVerify key id selection with overlapping key lifetime'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        key_validity_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg)
                
            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        log.info('the value of cfg is : {0}'.format(cfg1))
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res['peer_ip'],res['keychainname'],res['policyname'])
                                  
                        hdl.configure(cfg2)
                    
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic after changing the tunnel-Encrpytion keyChain') as s:     
                if not tunnel_flag:
                    log.info(banner('Waiting for 30 seconds before collecting the Traffic Stats'))
                    countDownTimer(30)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1
    
                    else:
                        log.info(banner('Cummulative Traffic flow is as expected.. '))
                        log.info('Waiting for 30 secs before adding a new key ')
                        countDownTimer(30)
                        
            with steps.start('Changing the Lifettime of Active key') as s:
                if not traffic_flag:
                    log.info('Adding a new Key with the same lifetime as the previous key')
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        hdl.execute('show clock')
                        new_date = curr_date + timedelta(days = 1)
                        cfg2 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5} '''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        hdl.configure(cfg2)
                            
            log.info('waiting for 60 seconds before checking the tunnel-encrytion session status:')
            countDownTimer(60)
            
            with steps.start('Verify Tunnel-Encryption Session after adding a new Key ID') as s:
                if not traffic_flag:
                    res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                    if not res:
                        log.error('CloudSec Peer is not expected after configuring the New KC policy')
                        tunnel_flag = 1
                        global_flag = 1
                        
            with steps.start('Verify KeyID Validity:') as s:       
                if not tunnel_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        log.info(banner('Checking the Key validity on dut : {0}'.format(dut)))
                        out = hdl.execute('show key chain | json')
                        json_out = json.loads(out)
                        if isinstance(json_out['TABLE_keychain']['ROW_keychain'],list):
                            for item in json_out['TABLE_keychain']['ROW_keychain']:
                                if re.search('KC00',item['chain_name'],re.I):
                                    log.info('The value of item is{0}'.format(item))
                                    log.info('The type of item is : {0}'.format(type(item)))
                                    if isinstance(item,list):
                                        for sub_item in item['TABLE_key']['ROW_key']:
                                            log.info('The value of sub_item is : {0}'.format(sub_item))
                                            if re.search('11',sub_item['key_id'],re.I):
                                                old_key_validity = sub_item['send_valid']
                                            if re.search('22',sub_item['key_id'],re.I):
                                                new_key_validity = sub_item['send_valid']
                                        if old_key_validity == 'true' and new_key_validity == 'true':
                                            log.info(banner('The Key validity is as expected..proceeding with traffic measurement... '))
                                        else:
                                            log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity,new_key_validity)))
                                            key_validity_flag = 1
                                            global_flag = 1
                                    else:
                                        key_validity = item['TABLE_key']['ROW_key']['send_valid']
                                        log.info('The value of key_validity is : {0}'.format(key_validity))
                                        if key_validity == 'true':
                                            log.info(banner('The key Validity is as expected.... proceeding wtih traffic measurement.'))
                                        else:
                                            log.info(banner('The key Validity is not as expected.. the value is : {0} '.format(key_validity)))
                                            global_flag = 1
                                            key_validity_flag = 1
            
            with steps.start('Verifying Traffic after adding the Overlapping Key') as s:
                if not key_validity_flag:
                    log.info(banner('Measuring Traffic Stats on Stream one by one'))
    
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        trigger_flag = 1
                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if key_validity_flag:
                        log.info(banner('The key Validity is not as expected.. the value is : {0} and {1}'.format(old_key_validity.new_key_validity)))
                    if traffic_flag:
                        log.error('FAIL- Traffic Test Failed after Trigger. Refer Logs.')
                    if restore_flag:
                        log.error('FAIL- Traffic Test Failed  after restoring both sites as MustSecure')
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Uplink Conversion - PO - Must Secure
class VxlanCloudSec_Func063(aetest.Testcase):

    """ Vxlan CloudSec - Adding MemberPort to Port-Channel Func-063-"""

    uid = 'VXLAN-CS-FUNC-063'

    @aetest.test
    def VxlanCloudSec_AddingMemberPort_PortChannel_Func063(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test27:- Uplink Conversion - PO - Must Secure'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        phy_conversion_flag = 0
        po_conversion_flag = 0
        add_memberport_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-002']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Defaulting the interfaces on BGWs') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in bgw_dict.keys():
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in dci_boxes:
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
                            
            with steps.start('Defaulting the interfaces on DCI Cores') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in dci_boxes:
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in list(bgw_dict.keys()):
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
            
            with steps.start('Configuring Port-channel on all the boxes') as s:
                for dut in port_channel_dict:
                    log.info('the value of dut  inside scripts is : {0}'.format(dut))
                    hdl = node_dict['all_dut'][dut]
                    for intf in port_channel_dict[dut].keys():
                        log.info('the value of intf  inside scripts is : {0}'.format(intf))
                        args = port_channel_dict[dut][intf]
                        log.info('the value of args  inside scripts is : {0}'.format(args))
                        res = trigger_obj.configurePo(hdl,intf,args)
                        
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    po_conversion_flag = 1
                    trigger_flag = 1
                    
            with steps.start('Adding Member Port to DCI port Channel on BGW') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                pat = 'port-channel(\d+)'
                for dut in bgw_dict.keys():
                    po_list = sorted(list(port_channel_dict[dut].keys())) # po101 po201
                    log.info('The value of Po_list is : {0}'.format(po_list)) 
                    hdl = node_dict['all_dut'][dut]
                    for link in alias_intf_mapping[dut].keys():
                        log.info('The value of link is : {0}'.format(link))
                        if link.split('_')[1] in dci_boxes:
                            if re.search("_2", link,re.I):  # uut2_uut5_2, uut2_uut6_2
                                dci_box = link.split('_')[1] # uut5
                                po_list_new = sorted(list(port_channel_dict[dci_box].keys())) # Po101, Po102
                                po_list_set = set(po_list)
                                common_po = po_list_set.intersection(po_list_new)
                                common_po_list = list(common_po)
                                match = re.search(pat,common_po_list[0],re.I)
                                if match:
                                    po_no = match.group(1)
                                    log.info('the value of Po_no is : {0}'.format(po_no))
                                log.info('the value of second link is : {0}'.format(link))
                                cfg = '''interface {0}
                                         no shutdown
                                         no switchport
                                         channel-group {1} force mode  active'''.format(alias_intf_mapping[dut][link],po_no)
                                hdl.configure(cfg)
                    
            with steps.start('Adding Member Port to DCI port Channel on DCI') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                pat = 'port-channel(\d+)'
                for dut in dci_boxes:
                    po_list = sorted(list(port_channel_dict[dut].keys())) # po101 po201
                    log.info('The value of Po_list is : {0}'.format(po_list)) 
                    hdl = node_dict['all_dut'][dut]
                    for link in alias_intf_mapping[dut].keys():
                        log.info('The value of link is : {0}'.format(link))
                        if link.split('_')[1] in list(bgw_dict.keys()):
                            if re.search("_2", link,re.I):  # uut2_uut5_2, uut2_uut6_2
                                dci_box = link.split('_')[1] # uut5
                                po_list_new = sorted(list(port_channel_dict[dci_box].keys())) # Po101, Po102
                                po_list_set = set(po_list)
                                common_po = po_list_set.intersection(po_list_new)
                                common_po_list = list(common_po)
                                match = re.search(pat,common_po_list[0],re.I)
                                if match:
                                    po_no = match.group(1)
                                    log.info('the value of Po_no is : {0}'.format(po_no))
                                log.info('the value of second link is : {0}'.format(link))
                                cfg = '''interface {0}
                                         no shutdown
                                         no switchport
                                         channel-group {1} force mode  active'''.format(alias_intf_mapping[dut][link],po_no)
                                hdl.configure(cfg)
                        
            log.info('Waiting for 60 seconds before measuring the traffic convergence')
            countDownTimer(60)
                    
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    add_memberport_flag = 1
                    traffic_flag = 1   
            
            log.info(banner('Converting the Interface back to Physical Interface'))
            
            
            
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 180 seconds before measuring the Traffic Convergence')
            countDownTimer(180)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    phy_conversion_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        if po_conversion_flag:
                            log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                        if add_memberport_flag:
                            log.error(banner('FAIL- Traffic Test Failed on streams after PO member Port Addition. Refer Logs for details'))
                        if phy_conversion_flag:
                            log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
            
# Removing Member port from PortChannel
class VxlanCloudSec_Func064(aetest.Testcase):

    """ Vxlan CloudSec - Removing Member port from Port-channel Func-064"""

    uid = 'VXLAN-CS-FUNC-064'

    @aetest.test
    def VxlanCloudSec_RemovingMemberPort_PortChannel_Func064(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test64:- Removing Member port from PortChannel'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        phy_conversion_flag = 0
        po_conversion_flag = 0
        add_memberport_flag = 0

        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Defaulting the interfaces on BGWs') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in bgw_dict.keys():
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in dci_boxes:
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
                            
            with steps.start('Defaulting the interfaces on DCI Cores') as s:
                dci_boxes = list(node_dict['DCI'].keys())
                for dut in dci_boxes:
                    for link in alias_intf_mapping[dut]:
                        if link.split('_')[1] in list(bgw_dict.keys()):
                            log.info('the value of link is : {0}'.format(link))
                            log.info('Default the interface {0}'.format(alias_intf_mapping[dut][link]))
                            res = MyLib.my_utils.defaultInterface(log,node_dict['all_dut'][dut],alias_intf_mapping[dut][link])
            
            with steps.start('Configuring Port-channel on all the boxes') as s:
                for dut in port_channel_dict:
                    log.info('the value of dut  inside scripts is : {0}'.format(dut))
                    hdl = node_dict['all_dut'][dut]
                    for intf in port_channel_dict[dut].keys():
                        log.info('the value of intf  inside scripts is : {0}'.format(intf))
                        args = port_channel_dict[dut][intf]
                        log.info('the value of args  inside scripts is : {0}'.format(args))
                        res = trigger_obj.configurePo(hdl,intf,args)
                        
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    po_conversion_flag = 1
                    traffic_flag = 1
                    
            with steps.start('Removing Member Port to DCI port Channel on BGW') as s:
                if not traffic_flag:
                    dci_boxes = list(node_dict['DCI'].keys())
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        for link in alias_intf_mapping[dut].keys():
                            log.info('The value of link is : {0}'.format(link))
                            if link.split('_')[1] in dci_boxes:
                                cfg = '''interface {0}
                                         no channel-group'''.format(alias_intf_mapping[dut][link])
                                hdl.configure(cfg)
                    
            with steps.start('Removing Member Port to DCI port Channel on DCI') as s:     
                if not traffic_flag:
                    dci_boxes = list(node_dict['DCI'].keys())
                    pat = 'port-channel(\d+)'
                    for dut in dci_boxes:
                        hdl = node_dict['all_dut'][dut]
                        for link in alias_intf_mapping[dut].keys():
                            log.info('The value of link is : {0}'.format(link))
                            if link.split('_')[1] in list(bgw_dict.keys()):
                                cfg = '''interface {0}
                                         no channel-group'''.format(alias_intf_mapping[dut][link])
                                hdl.configure(cfg)
                        
            log.info('Waiting for 60 seconds before measuring the traffic convergence')
            countDownTimer(60)
                    
            with steps.start('Configuring Port-channel on all the boxes') as s:
                if not traffic_flag:
                    for dut in port_channel_dict:
                        log.info('the value of dut  inside scripts is : {0}'.format(dut))
                        hdl = node_dict['all_dut'][dut]
                        for intf in port_channel_dict[dut].keys():
                            log.info('the value of intf  inside scripts is : {0}'.format(intf))
                            args = port_channel_dict[dut][intf]
                            log.info('the value of args  inside scripts is : {0}'.format(args))
                            res = trigger_obj.configurePo(hdl,intf,args)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 180 seconds before measuring the Traffic Convergence')
            countDownTimer(180)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Swapping DCI Fabric Link
class VxlanCloudSec_Func065(aetest.Testcase):

    """ Vxlan CloudSec - Moving Fabric link to DCI and vice versa Func-065"""

    uid = 'VXLAN-CS-FUNC-065'

    @aetest.test
    def VxlanCloudSec_SwappingDCIFabricLink_Func065(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test65:- Swapping DCI Fabric Link'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Interfaes from BGW:') as s:
                dci_int_dict = {}
                
                for dut in bgw_dict.keys():
                    dci_interface_list = []
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'show nve multisite dci-links | xml'
                    out = hdl.configure(cfg)
                    for line in out.splitlines():
                        log.info('line is --->{0}'.format(line))
                        if re.search('if-name', line, re.I):
                            s = BeautifulSoup(line)
                            try:
                                intf_name = s.find('if-name').string
                                dci_interface_list.append(intf_name)
                            except Exception as e:
                                log.info('The Exeception Occured is: {0}'.format(e))
                                log.error('Unable to get the Interface name')
                                dci_flag = 1
                    log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                    dci_int_dict[dut] = dci_interface_list
                    log.info('dci_int_dict is -----> {0}'.format(dci_int_dict))
                    

            with steps.start('Getting the Fabric Interfaes from BGW:') as s:
                fab_int_dict = {}
                
                for dut in bgw_dict.keys():
                    fabric_interface_list = []
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'show nve multisite fabric-links | xml'
                    out = hdl.configure(cfg)
                    for line in out.splitlines():
                        log.info('line is --->{0}'.format(line))
                        if re.search('if-name', line, re.I):
                            s = BeautifulSoup(line)
                            try:
                                intf_name = s.find('if-name').string
                                fabric_interface_list.append(intf_name)
                            except Exception as e:
                                log.info('The Exeception Occured is: {0}'.format(e))
                                log.error('Unable to get the Interface name')
                                fabric_flag = 1
                    log.info('fabric_interface_list is -----> {0}'.format(fabric_interface_list))
                    fab_int_dict[dut] = fabric_interface_list
                    
                    log.info('fab_int_dict is -----> {0}'.format(fab_int_dict))
                            
            with steps.start('Swapping the DCI and Fabric Links') as s:
                log.info('dci_flag is ----> {0} ... fabric_flag is : -----> {1}'.format(dci_flag, fabric_flag))
                if not dci_flag and not fabric_flag:
                    for dut in dci_int_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        for intf in dci_int_dict[dut]:
                            cfg = '''interface {0}
                                     evpn multisite fabric-tracking'''.format(intf)
                            hdl.configure(cfg)
                    for dut in fab_int_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        for intf in fab_int_dict[dut]:
                            cfg = '''interface {0}
                                     evpn multisite dci-tracking'''.format(intf)
                            hdl.configure(cfg)
                        
            log.info('Waiting for 60 seconds before measuring the Traffic Convergence')
            countDownTimer(60)
        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['tx'] == 0:
                        log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop is not as expected.. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting the DCI and Fabric Links') as s:
                if not dci_flag and not fabric_flag:
                    for dut in dci_int_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        for intf in dci_int_dict[dut]:
                            cfg = '''interface {0}
                                     evpn multisite dci-tracking'''.format(intf)
                            hdl.configure(cfg)
                    for dut in fab_int_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        for intf in fab_int_dict[dut]:
                            cfg = '''interface {0}
                                     evpn multisite fabric-tracking'''.format(intf)
                            hdl.configure(cfg)                    
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out  dci interface list.. REfer Logs'))
                    if dci_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out fabric interface list.. REfer Logs'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove/Add Multisite config
class VxlanCloudSec_Func066(aetest.Testcase):

    """ Vxlan CloudSec - Remove Add Multisite Config Func-066"""

    uid = 'VXLAN-CS-FUNC-066'

    @aetest.test
    def VxlanCloudSec_RemoveAddMultisiteConfig_Func065(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test66:- Remove/Add Multisite config'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            multisite_config_dict = configdict['multisite_config_dict']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the Multiste Configs from BGW') as s:
                
                for dut in bgw_dict.keys():
                    args = configdict['multisite_config_dict'][dut]['global']
                    ns = MyLib.my_multisite_lib.parseMultisiteConfigs(log,args)
                    log.info('the value of ns is {0}'.format(ns))
                    cfg = 'no evpn multisite border-gateway {0}'.format(ns.site_id)
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure(cfg)
                                            
            log.info('Waiting for 30 seconds before measuring the Traffic Convergence')
            countDownTimer(30)
        
            with steps.start('Adding the multisite configs back on dut') as s:

                for dut in multisite_config_dict.keys():
                    obj_ms=MyLib.my_multisite_lib.configMultisite(multisite_config_dict,node_dict,alias_intf_mapping,log)
                    if not obj_ms.Nodes(dut):
                        self.failed()                
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out  dci interface list.. REfer Logs'))
                    if dci_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out fabric interface list.. REfer Logs'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# add/remove advertise PIP
class VxlanCloudSec_Func067(aetest.Testcase):

    """ Vxlan CloudSec - Add / Remove advertise PIP"""

    uid = 'VXLAN-CS-FUNC-067'

    @aetest.test
    def VxlanCloudSec_RemoveAddMultisiteConfig_Func067(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test67:- add/remove advertise PIP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Adding the Multiste Configs from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = '''router bgp {0}
                             address-family l2vpn evpn
                             advertise-pip
                          '''.format(bgp_as_no[0])
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Removing the Multiste Configs from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = '''router bgp {0}
                             address-family l2vpn evpn
                             no advertise-pip
                          '''.format(bgp_as_no[0])
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After Removing Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out  dci interface list.. REfer Logs'))
                    if dci_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out fabric interface list.. REfer Logs'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# add/remove dci advertise PIP
class VxlanCloudSec_Func068(aetest.Testcase):

    """ Vxlan CloudSec - REmove add dci-advertise-pip -FUNC068"""

    uid = 'VXLAN-CS-FUNC-068'

    @aetest.test
    def VxlanCloudSec_RemoveAddMultisiteConfig_Func068(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test68:- add/remove dci advertise PIP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the dci-advertise-pip configs BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    args = configdict['multisite_config_dict'][dut]['global']
                    ns = MyLib.my_multisite_lib.parseMultisiteConfigs(log,args)
                    log.info('the value of ns is {0}'.format(ns))
                    cfg = '''evpn multisite border-gateway {0}
                             no dci-advertise-pip
                          '''.format(ns.site_id)
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < 100:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the dci-advertise-pip configs BGW') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        args = configdict['multisite_config_dict'][dut]['global']
                        ns = MyLib.my_multisite_lib.parseMultisiteConfigs(log,args)
                        log.info('the value of ns is {0}'.format(ns))
                        cfg = '''evpn multisite border-gateway {0}
                                 dci-advertise-pip
                              '''.format(ns.site_id)
                        hdl.configure(cfg)      
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove add CloudSec PeerIP configs
class VxlanCloudSec_Func069(aetest.Testcase):

    """ Vxlan CloudSec - REmove add CloudSec PeerIP configs -FUNC069"""

    uid = 'VXLAN-CS-FUNC-069'

    @aetest.test
    def VxlanCloudSec_CloudSecPeer_Func068(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test69:- REmove add CloudSec PeerIP configs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Configured KeyChain and PolicyName from BGW') as s:
                tunnel_session_dict = {}
                for dut in bgw_dict.keys():
                    peer_ip = cloudsec_peer_per_dut[dut]
                    res = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,node_dict['all_dut'][dut],peer_ip[0])
                    tunnel_session_dict[dut] = res
                
            with steps.start('Removing the Cloudsec Peer-ip configs BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    peer_ip = cloudsec_peer_per_dut[dut]
                    cfg = 'no tunnel-encryption peer-ip {0}'.format(peer_ip[0])
                    hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < 100:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the Cloudsec Peer-ip configs BGW') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        peer_ip = cloudsec_peer_per_dut[dut]
                        cfg = '''tunnel-encryption peer-ip {0}
                                 keychain {1} policy {2}
                              '''.format(peer_ip[0],tunnel_session_dict[dut]['keychainname'],tunnel_session_dict[dut]['policyname'])
                        hdl.configure(cfg)      
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove add Peer-Type-Fabric-External configs
class VxlanCloudSec_Func070(aetest.Testcase):

    """ Vxlan CloudSec - Remove Add peer-type-fabric-external -FUNC070"""

    uid = 'VXLAN-CS-FUNC-070'

    @aetest.test
    def VxlanCloudSec_RemoveAddPeerTypeFabricExternal_Func070(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test70:- REmove add Peer-Type-Fabric-External configs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the Peer-Type-Fabric-External-Configs from  BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    as_no = list(configdict['bgp_config_dict'][dut].keys())

                    cfg = '''router bgp {0}
                              template peer DCI-L2VPN
                              no peer-type fabric-external'''.format(as_no[0])
                    hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < 100:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the Peer-Type-Fabric-External-Configs on  BGW') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        as_no = list(configdict['bgp_config_dict'][dut].keys())
    
                        cfg = '''router bgp {0}
                                  template peer DCI-L2VPN
                                  peer-type fabric-external'''.format(as_no[0])
                        hdl.configure(cfg)   
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove add rewrite-evpn-rt-asn configs
class VxlanCloudSec_Func071(aetest.Testcase):

    """ Vxlan CloudSec - Remove Add rewrite-evpn-rt-asn -FUNC071"""

    uid = 'VXLAN-CS-FUNC-071'

    @aetest.test
    def VxlanCloudSec_RemoveAddRewriteEVPNRTASN_Func071(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test71:- REmove add rewrite-evpn-rt-asn configs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the Peer-Type-Fabric-External-Configs from  BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    as_no = list(configdict['bgp_config_dict'][dut].keys())

                    cfg = '''router bgp {0}
                              template peer DCI-L2VPN
                              address-family l2vpn evpn
                              no rewrite-evpn-rt-asn'''.format(as_no[0])
                    hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < 100:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the Peer-Type-Fabric-External-Configs on  BGW') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        as_no = list(configdict['bgp_config_dict'][dut].keys())
    
                        cfg = '''router bgp {0}
                                  template peer DCI-L2VPN
                                  address-family l2vpn evpn
                                  rewrite-evpn-rt-asn'''.format(as_no[0])
                        hdl.configure(cfg) 
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Multisite Loopback configs
class VxlanCloudSec_Func072(aetest.Testcase):

    """ Vxlan CloudSec - RemoveAdd MultisiteLoopback -FUNC072"""

    uid = 'VXLAN-CS-FUNC-072'

    @aetest.test
    def VxlanCloudSec_RemoveAddRMultiSiteLoopback_Func072(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test72:- Remove Add Multisite Loopback configs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show run interface loopback2'
                    cfg = cmd_str + ' > multisite_loopback_configs'
                    delete = 'delete bootflash:multisite* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing the Multisite Loopback from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''interface nve1
                             shutdown
                             no interface loopback2'''
                    hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < 100:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the Multisite Loopback Configs') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:multisite_loopback_configs running-config echo-commands'
                        hdl.configure(cfg1)
                        cfg2 = '''interface nve1
                                  no shutdown'''
                        hdl.configure(cfg2)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Primary Loopback configs
class VxlanCloudSec_Func073(aetest.Testcase):

    """ Vxlan CloudSec - RemoveAdd Primary Loopback -FUNC073"""

    uid = 'VXLAN-CS-FUNC-073'

    @aetest.test
    def VxlanCloudSec_RemoveAddRPrimaryLoopback_Func073(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test73:- Remove Add Primary Loopback configs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show run interface loopback1'
                    cfg = cmd_str + ' > primary_loopback_configs'
                    delete = 'delete bootflash:primary* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing the Primary Loopback from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''interface nve1
                             shutdown
                             no interface loopback1'''
                    hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < 100:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the Primary Loopback Configs') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:primary_loopback_configs running-config echo-commands'
                        hdl.configure(cfg1)
                        cfg2 = '''interface nve1
                                  no shutdown'''
                        hdl.configure(cfg2)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Changing Primary Loopback IP on Anyone BGW
class VxlanCloudSec_Func074(aetest.Testcase):

    """ Vxlan CloudSec - Changing the Primary Loopback IP on Anyone BGW -FUNC074"""

    uid = 'VXLAN-CS-FUNC-074'

    @aetest.test
    def VxlanCloudSec_ChangingPrimaryLoopbacKIPOnAnyoneBGW_Func074(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test74:- Changing Primary Loopback IP on Anyone BGW'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Primary Loopback Interface on Site1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                cmd_str = 'show run interface loopback1'
                cfg = cmd_str + ' > primary_loopback_configs'
                delete = 'delete bootflash:primary* no-prompt'
                site1_hdl.execute(delete)
                site1_hdl.execute(cfg)

            with steps.start('Collecting the cloudSec peer Detail on Site 2:') as s:
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                peer_ip = cloudsec_peer_per_dut[site2_dut]
                peer_details = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,node_dict['all_dut'][site2_dut],peer_ip[0])
            
            
            with steps.start('Changing the PIP on Site 1:') as s:
                cfg = '''interface nve 1
                         shutdown'''
                site1_hdl.configure(cfg)
                cfg2 = '''interface loopback1
                          ip address 130.130.130.130/32 tag 11111'''
                site1_hdl.configure(cfg2)
                cfg3 = '''interface nve 1
                         no shutdown'''
                site1_hdl.configure(cfg3)
                
            with steps.start('Adding the New Cloudsec peer on Site2') as s:
                cfg = '''tunnel-encryption peer-ip 130.130.130.130
                         keychain {0} policy {1}'''.format(peer_details['keychainname'],peer_details['policyname'])
                site2_hdl.configure(cfg)
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Changing PIP on Site1') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on Site 1 ') as s:
                
                if not traffic_flag:
                    site1_hdl.configure('interface nve 1 ; shutdown')
                    cfg1 = 'copy bootflash:primary_loopback_configs running-config echo-commands'
                    site1_hdl.configure(cfg1)
                    cfg2 = '''interface nve1
                              no shutdown'''
                    site1_hdl.configure(cfg2)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding DCI Advertise PIP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Changing Multisite Loopback IP on BGWs
class VxlanCloudSec_Func075(aetest.Testcase):

    """ Vxlan CloudSec - Changing the Multisite Loopback IPs on all Sites -FUNC075"""

    uid = 'VXLAN-CS-FUNC-075'

    @aetest.test
    def VxlanCloudSec_ChangingMultisiteLoopbackIP_Func075(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test75:- Changing Multisite Loopback IP on BGWs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show run interface loopback2'
                    cfg = cmd_str + ' > multisite_loopback_configs'
                    delete = 'delete bootflash:multisite* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Changing the Multisite IPs on BGW') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                for hdl in [site1_hdl,site2_hdl]:
                    hdl.configure('interface nve 1 ; shutdown')
                cfg1 = '''interface loopback2
                          ip address 133.133.133.133/32 tag 11111'''
                
                site1_hdl.configure(cfg1)
                
                cfg1 = '''interface loopback2
                          ip address 144.144.144.144/32 tag 22222'''
            
                site2_hdl.configure(cfg1)
                
                for hdl in [site1_hdl,site2_hdl]:
                    hdl.configure('interface nve 1 ; no shutdown')                
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Changing PIP on Site1') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        hdl.configure('interface nve 1 ; shutdown')
                        cfg1 = 'copy bootflash:multisite_loopback_configs running-config echo-commands'
                        hdl.configure(cfg1)
                        cfg2 = '''interface nve1
                                  no shutdown'''
                        hdl.configure(cfg2)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Changing Multisite Site IDs on BGWs
class VxlanCloudSec_Func076(aetest.Testcase):

    """ Vxlan CloudSec - Changing the Multisite Site ID -FUNC076"""

    uid = 'VXLAN-CS-FUNC-076'

    @aetest.test
    def VxlanCloudSec_ChangingMultisiteSiteID_Func076(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test76:- Changing Multisite Site IDs on BGWs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "evpn multisite border-gateway"'
                    cfg = cmd_str + ' > multisite_siteid_configs'
                    delete = 'delete bootflash:multisite* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Changing the Multisite SiteIDs on BGW') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                site2_dut = list(node_dict['Site2']['BGW'].keys())[0]
                site2_hdl = list(node_dict['Site2']['BGW'].values())[0]
                count = 100
                for hdl in [site1_hdl,site2_hdl]:
                    hdl.configure('evpn multisite border-gateway {0}'.format(count))
                    count = count + 100
                               
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Multiste Site ID on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:multisite_siteid_configs running-config echo-commands'
                        hdl.configure(cfg1)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Removing AFUnicastV4 on BGWs
class VxlanCloudSec_Func077(aetest.Testcase):

    """ Vxlan CloudSec - REmoving address-family v4 unicast -FUNC077"""

    uid = 'VXLAN-CS-FUNC-077'

    @aetest.test
    def VxlanCloudSec_RemovingAFUnicastV4_Func077(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test77:- REmoving AFUnicastV4 on BGWs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing AFUnicast V4 from DUTS') as s:
                for dut in bgw_dict.keys():
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''router bgp {0}
                             no template peer DCI-V4'''.format(bgp_as_no[0])
                    hdl.configure(cfg)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Removing AFUnicast V4 on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the V4Unicast Configs') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                        cfg = '''router bgp {0}
                                 template peer DCI-V4
                                 log-neighbor-changes
                                 address-family ipv4 unicast
                                 soft-reconfiguration inbound always'''.format(bgp_as_no[0])
                        hdl.configure(cfg)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# ConfigUnconfigBGP
class VxlanCloudSec_Func078(aetest.Testcase):

    """ Vxlan CloudSec - Config/Unconfig BGP -FUNC076"""

    uid = 'VXLAN-CS-FUNC-078'

    @aetest.test
    def VxlanCloudSec_ConfigUnconfigBGP_Func078(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test78:- ConfigUnconfigBGP '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show run bgp'
                    cfg = cmd_str + ' > bgp_configs'
                    delete = 'delete bootflash:bgp* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing BGP on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = 'no router bgp {0}'.format(bgp_as_no[0])
                    hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Multiste Site ID on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:bgp_configs running-config echo-commands'
                        hdl.configure(cfg1)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Removing AFL2VPN on BGWs
class VxlanCloudSec_Func079(aetest.Testcase):

    """ Vxlan CloudSec - REmoving address-family L2EVPN -FUNC079"""

    uid = 'VXLAN-CS-FUNC-079'

    @aetest.test
    def VxlanCloudSec_RemovingAFL2EVPN_Func079(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test79:- REmoving AFL2VPN on BGWs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing AFUnicast V4 from DUTS') as s:
                for dut in bgw_dict.keys():
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''router bgp {0}
                             no template peer DCI-L2VPN'''.format(bgp_as_no[0])
                    hdl.configure(cfg)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Multiste Site ID on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Adding the AFL2EVPN Configs') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                        hdl = node_dict['all_dut'][dut]
                        cfg = '''router bgp {0}
                                 template peer DCI-L2VPN
                                 log-neighbor-changes
                                 ebgp-multihop 10
                                 peer-type fabric-external
                                 address-family ipv4 mvpn
                                   send-community
                                   send-community extended
                                   rewrite-rt-asn
                                 address-family l2vpn evpn
                                   send-community
                                   send-community extended
                                   rewrite-evpn-rt-asn'''.format(bgp_as_no[0])
                        hdl.configure(cfg)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Feature nv overlay
class VxlanCloudSec_Func080(aetest.Testcase):

    """ Vxlan CloudSec - Remove / Add feature nv overlay -FUNC080"""

    uid = 'VXLAN-CS-FUNC-080'

    @aetest.test
    def VxlanCloudSec_ConfigUnconfigBGP_Func080(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test80:- Remove Add Feature nv overlay '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run nv overlay'
                    cfg = cmd_str + ' > nv_overlay_configs'
                    delete = 'delete bootflash:nv_overlay* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing Feature NV OVeraly on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]

                    log.info(banner('Removing feature NV overlay on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature nve' )
                    if out.result=='fail':
                        log.error('Disable of Tunnel-Encrpytion failed on dut %s' % dut)
                        global_flag = 1
                    else:
                        log.info('Disable of Tunnel-Encrpytion passes on dut %s' % dut)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Multiste Site ID on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:nv_overlay_configs running-config echo-commands'
                        hdl.configure(cfg1)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Feature CloudSEc
class VxlanCloudSec_Func081(aetest.Testcase):

    """ Vxlan CloudSec - Remove / Add feature Cloudsec -FUNC081"""

    uid = 'VXLAN-CS-FUNC-081'

    @aetest.test
    def VxlanCloudSec_ConfigUnconfigBGP_Func081(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test81:- Remove Add Feature CloudSEc '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run tunnel-encryption'
                    cfg = cmd_str + ' > cloudsec_configs'
                    delete = 'delete bootflash:cloudsec* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing Feature CloudSec on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]

                    log.info(banner('Removing feature tunnel-encryption on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature tunnel-encryption' )
                    if out.result=='fail':
                        log.error('Disable of Tunnel-Encrpytion failed on dut %s' % dut)
                        global_flag = 1
                    else:
                        log.info('Disable of Tunnel-Encrpytion passes on dut %s' % dut)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Removnig CloudSec Configs') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:cloudsec_configs running-config echo-commands'
                        hdl.configure(cfg1)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Feature vn-seg
class VxlanCloudSec_Func082(aetest.Testcase):

    """ Vxlan CloudSec - Remove / Add feature vn-segment -FUNC082"""

    uid = 'VXLAN-CS-FUNC-082'

    @aetest.test
    def VxlanCloudSec_FeatureNoFeatureVNSegment_Func082(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test82:- Remove Add Feature vn-seg '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run nv overlay'
                    cfg1 = cmd_str + ' > nv_overlay_configs'
                    cfg2 = 'show run vlan > vlan_configs'
                    delete = 'delete bootflash:nv_overlay* no-prompt'
                    hdl.execute(delete)
                    delete = 'delete bootflash:vlan_configs* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg1)
                    hdl.execute(cfg2)
                    
            with steps.start('Removing Feature NV OVeraly  and Vn-Segment-vlan-Based on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]

                    log.info(banner('Removing feature NV overlay, VN-Segment on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature nve,vn-segment-vlan-based')
                    if out.result=='fail':
                        log.error('Disable of Nv Overlay, VN-seg failed on dut %s' % dut)
                        global_flag = 1
                    else:
                        log.info('Disable of Nv Overlay, VN-seg failed  passes on dut %s' % dut)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Multiste Site ID on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:nv_overlay_configs running-config echo-commands'
                        hdl.configure(cfg1)
                        cfg2 = 'copy bootflash:vlan_configs running-config echo-commands'
                        hdl.configure('feature vn-segment-vlan-based')
                        hdl.configure(cfg2)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Feature BGP
class VxlanCloudSec_Func083(aetest.Testcase):

    """ Vxlan CloudSec - Remove / Add feature BGP -FUNC082"""

    uid = 'VXLAN-CS-FUNC-083'

    @aetest.test
    def VxlanCloudSec_FeatureNoFeatureBGP_Func083(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test83:- Remove Add Feature BGP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Multisite Loopback Interface on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run bgp'
                    cfg1 = cmd_str + ' > bgp_config'
                    delete = 'delete bootflash:bgp* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg1)
                    
            with steps.start('Removing Feature BGP on BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]

                    log.info(banner('Removing feature BGP on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature bgp')
                    if out.result=='fail':
                        log.error('Disable of  BGP failed on dut %s' % dut)
                        global_flag = 1
                    else:
                        log.info('Disable of BGP failed  passes on dut %s' % dut)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Multiste Site ID on BGWs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on both BGWs ') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:bgp_config running-config echo-commands'
                        hdl.configure(cfg1)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After Replacing the Old Multisite Loopback Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove Add Feature InterfaceVlan
class VxlanCloudSec_Func084(aetest.Testcase):

    """ Vxlan CloudSec - Remove / Add feature Interface Vlan -FUNC084"""

    uid = 'VXLAN-CS-FUNC-084'

    @aetest.test
    def VxlanCloudSec_FeatureNoFeatureInterfaceVlan_Func084(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test84:- Remove Add Feature InterfaceVlan'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in vtep_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of SVI Cofnigs on VTEPs') as s:
                for dut in vtep_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "interface Vlan"'
                    cfg1 = cmd_str + ' > interface_vlan_configs'
                    delete = 'delete bootflash:interface* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg1)
                    
            with steps.start('Removing Feature Interface-VLan on VTEPs') as s:
                for dut in vtep_dict.keys():
                    hdl = node_dict['all_dut'][dut]

                    log.info(banner('Removing feature Interface-vlan on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature interface-vlan')
                    if out.result=='fail':
                        log.error('Disable of  Interface-Vlan failed on dut %s' % dut)
                        global_flag = 1
                    else:
                        log.info('Disable of Interface-Vlan failed  passes on dut %s' % dut)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected....:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Reverting back the configs on all the VTEPs ') as s:
                
                if not traffic_flag:
                    for dut in vtep_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:interface_vlan_configs running-config echo-commands'
                        hdl.configure(cfg1)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in vtep_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping one of the DCI link
class VxlanCloudSec_Func085(aetest.Testcase):

    """ Vxlan CloudSec - Flapping one of the DCI link - FUNC085"""

    uid = 'VXLAN-CS-FUNC-085'

    @aetest.test
    def VxlanCloudSec_FlappingOneofDCILink_Func085(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test85:- Flapping one of the DCI link'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('Flapping one of the DCI links:') as s:
                if not dci_interface_list:
                    cfg = '''interface {0}
                             shutdown'''.format(dci_interface_list[0])
                    site1_hdl.configure(cfg)
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Unshutting the DCI Interface...') as s:
                if not traffic_flag and not dci_interface_list:
                    cfg = '''interface {0}
                             no shutdown'''.format(dci_interface_list[0])
                    site1_hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping one of the Fabric link
class VxlanCloudSec_Func086(aetest.Testcase):

    """ Vxlan CloudSec - Flapping one of the Fabric link - FUNC086"""

    uid = 'VXLAN-CS-FUNC-086'

    @aetest.test
    def VxlanCloudSec_FlappingOneofFabricLink_Func085(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test86:- Flapping one of the Fabric link'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Fabric Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                fabric_interface_list = []
                cfg = 'show nve multisite fabric-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            fabric_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            fabric_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(fabric_interface_list))
                
            with steps.start('Flapping one of the Fabric links:') as s:
                if not fabric_interface_list:
                    cfg = '''interface {0}
                             shutdown'''.format(fabric_interface_list[0])
                    site1_hdl.configure(cfg)
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not fabric_interface_list:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Unshutting the Fabirc Interface...') as s:
                if not traffic_flag and not fabric_interface_list:
                    cfg = '''interface {0}
                             no shutdown'''.format(fabric_interface_list[0])
                    site1_hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL - Unable to get the Fabric interface'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping All the DCI link
class VxlanCloudSec_Func087(aetest.Testcase):

    """ Vxlan CloudSec - Flapping all the DCI links - FUNC087"""

    uid = 'VXLAN-CS-FUNC-087'

    @aetest.test
    def VxlanCloudSec_FlappingAllDCILink_Func085(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test87:- Flapping All the DCI link'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('Flapping one of the DCI links:') as s:
                if not dci_interface_list:
                    for intf in dci_interface_list:
                        cfg = '''interface {0}
                                 shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... .:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Unshutting the DCI Interface...') as s:
                if not traffic_flag and not dci_interface_list:
                    for intf in dci_interface_list:

                        cfg = '''interface {0}
                                 no shutdown'''.format(dci_interface_list[0])
                        site1_hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting all the DCI Links') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping all Fabric link
class VxlanCloudSec_Func088(aetest.Testcase):

    """ Vxlan CloudSec - Flapping allFabric link - FUNC088"""

    uid = 'VXLAN-CS-FUNC-088'

    @aetest.test
    def VxlanCloudSec_FlappingAllFabricLink_Func085(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test88:- Flapping all Fabric link'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Fabric Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                fabric_interface_list = []
                cfg = 'show nve multisite fabric-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            fabric_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            fabric_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(fabric_interface_list))
                
            with steps.start('Flapping one of the Fabric links:') as s:
                if not fabric_interface_list:
                    for intf in fabric_interface_list:
                        cfg = '''interface {0}
                                 shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Fabric Links') as s:
                if not fabric_interface_list:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Unshutting the Fabirc Interface...') as s:
                if not traffic_flag and not fabric_interface_list:
                    for intf in fabric_interface_list:

                        cfg = '''interface {0}
                                 no shutdown'''.format(intf)
                        site1_hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Fabric Links') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL - Unable to get the Fabric interface'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping Nve Interface
class VxlanCloudSec_Func089(aetest.Testcase):

    """ Vxlan CloudSec - Flapping Nve Interface - FUNC089"""

    uid = 'VXLAN-CS-FUNC-089'

    @aetest.test
    def VxlanCloudSec_FlappingNveInterface_Func089(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test89:- Flapping Nve Interface'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Nve Interface on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                site1_hdl.configure('interface nve 1 ; shutdown')
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Nve Interface') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Unshutting the Nve Interface...') as s:
                
                site1_hdl.configure('interface nve 1 ; no shutdown')

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Fabric Links') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()

# Flapping Nve Interface on both BGW
class VxlanCloudSec_Func090(aetest.Testcase):

    """ Vxlan CloudSec - Flapping Nve Interface on BGWs- FUNC090"""

    uid = 'VXLAN-CS-FUNC-090'

    @aetest.test
    def VxlanCloudSec_FlappingNveInterfaceOnBothBGW_Func090(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test90:- Flapping Nve Interface on both BGW'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Flapping the Nve Interface on Both BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure('interface nve 1 ; shutdown')
                
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Nve Interface on both BGWs') as s:
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Flapping the Nve Interface on Both BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure('interface nve 1 ; no shutdown')

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Nve Interface on both BGWs') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping Nve Loopback Interface
class VxlanCloudSec_Func091(aetest.Testcase):

    """ Vxlan CloudSec - Flapping Nve Loopback - FUNC091"""

    uid = 'VXLAN-CS-FUNC-091'

    @aetest.test
    def VxlanCloudSec_FlappingNveInterface_Func091(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test91:- Flapping Nve Loopback Interface'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Nve Interface on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                site1_hdl.configure('interface loopback 1 ; shutdown')
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Fabric Links') as s:
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Unshutting the Nve loopback Interface...') as s:
                
                site1_hdl.configure('interface loopback 1 ; no shutdown')

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Fabric Links') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:

                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()

# Flapping Nve Loopback Interface on both BGW
class VxlanCloudSec_Func092(aetest.Testcase):

    """ Vxlan CloudSec - Flapping Nve Interface on BGWs- FUNC092"""

    uid = 'VXLAN-CS-FUNC-092'

    @aetest.test
    def VxlanCloudSec_FlappingNveLoopbackInterfaceOnBothBGW_Func092(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test92:- Flapping Nve Loopback Interface on both BGW'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Flapping the Nve Interface on Both BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure('interface loopback 1 ; shutdown')
                
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Nve Interface on both BGWs') as s:
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Flapping the Nve Interface on Both BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure('interface loopback 1 ; no shutdown')

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Nve Interface on both BGWs') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping Multisite Loopback Interface
class VxlanCloudSec_Func093(aetest.Testcase):

    """ Vxlan CloudSec - Flapping Multisite Loopback - FUNC093"""

    uid = 'VXLAN-CS-FUNC-093'

    @aetest.test
    def VxlanCloudSec_FlappingMultisiteLoopbackInterface_Func091(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test93:- Flapping Multisite Loopback Interface'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Nve Interface on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                site1_hdl.configure('interface loopback 2 ; shutdown')
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Fabric Links') as s:
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Unshutting the Multisite loopback Interface...') as s:
                
                site1_hdl.configure('interface loopback 2 ; no shutdown')

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Multisite Loopback Interface') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Flapping Multisite Loopback Interface on both BGW
class VxlanCloudSec_Func094(aetest.Testcase):

    """ Vxlan CloudSec - Flapping Multisite Interface on BGWs- FUNC094"""

    uid = 'VXLAN-CS-FUNC-094'

    @aetest.test
    def VxlanCloudSec_FlappingNveLoopbackInterfaceOnBothBGW_Func094(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test94:- Flapping Multisite Loopback Interface on both BGW'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Flapping the Nve Interface on Both BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure('interface loopback 2 ; shutdown')
                
                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting the Multisite Interface on both BGWs') as s:
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1

            with steps.start('Flapping the Multisite Interface on Both BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    hdl.configure('interface loopback 2 ; no shutdown')

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Nve Interface on both BGWs') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL - Unable to get the Fabric interface'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# BGP Shut / Unshut
class VxlanCloudSec_Func095(aetest.Testcase):

    """ Vxlan CloudSec - BGP Shut / No Shut - FUNC-095"""

    uid = 'VXLAN-CS-FUNC-095'

    @aetest.test
    def VxlanCloudSec_BGPShutUnshut_Func095(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test95:- BGP Shut / Unshut'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Shutting the BGP on Both BGWs') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = '''router bgp {0}
                             shutdown
                          '''.format(bgp_as_no[0])
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting Down BGP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... :')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Unshutting the BGP on both the BGWs') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = '''router bgp {0}
                             no shutdown
                          '''.format(bgp_as_no[0])
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After unshutting BGP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()

# Tenant SVI Shut / Unshut
class VxlanCloudSec_Func096(aetest.Testcase):

    """ Vxlan CloudSec - Tenant SVI Shut/unshut - FUNC-096"""

    uid = 'VXLAN-CS-FUNC-096'

    @aetest.test
    def VxlanCloudSec_TenantSVIShutUnshut_Func096(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test96:- Tenant SVI Shut / Unshut'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))

            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(leaf_dict.keys()))))
                
                for dut in leaf_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Shut the Tenent VRF on both the LEafs') as s:
                
                for dut in leaf_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    args = configdict['scale_config_dict'][dut]['interface']['svi']
                    ns = MyLib.my_config_utils.parseScaleSVIParams(log,args)
                    for i in range(ns.l2_vni_svi_start,ns.l2_vni_svi_start+ns.no_of_l2_vni_svi):
                        interface = 'Vlan{0}'.format(i)
                        res = MyLib.my_utils.shutDownInterface(log,hdl,interface,dut)
                        if not res:
                            log.error(banner('Shutdown of Interface failed'))
                            self.failed()
                    
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting Down BGP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... :')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Unshutting the Tenant SVIs on both the Leafs') as s:
                
                for dut in leaf_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    args = configdict['scale_config_dict'][dut]['interface']['svi']
                    ns = MyLib.my_config_utils.parseScaleSVIParams(log,args)
                    for i in range(ns.l2_vni_svi_start,ns.l2_vni_svi_start+ns.no_of_l2_vni_svi):
                        interface = 'Vlan{0}'.format(i)
                        res = MyLib.my_utils.unshutDownInterface(log,hdl,interface,dut)
                        if not res:
                            log.error(banner('Shutdown of Interface failed'))
                            self.failed()       
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting Tenant SVI') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(leaf_dict.keys()))))
                
                for dut in leaf_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()

# L3VNI SVI Shut / Unshut
class VxlanCloudSec_Func097(aetest.Testcase):

    """ Vxlan CloudSec - Tenant SVI Shut/unshut - FUNC-097"""

    uid = 'VXLAN-CS-FUNC-097'

    @aetest.test
    def VxlanCloudSec_L3VNISVIShutUnshut_Func097(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test97:- L3VNI SVI Shut / Unshut'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))

                
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(vtep_dict.keys()))))
                
                for dut in vtep_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Shut the Tenent VRF on both the LEafs') as s:
                
                for dut in leaf_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    args = configdict['scale_config_dict'][dut]['interface']['svi']
                    ns = MyLib.my_config_utils.parseScaleSVIParams(log,args)
                    for i in range(ns.l3_vni_svi_start,ns.l3_vni_svi_start+ns.no_of_l3_vni_svi):
                        interface = 'Vlan{0}'.format(i)
                        res = MyLib.my_utils.shutDownInterface(log,hdl,interface,dut)
                        if not res:
                            log.error(banner('Shutdown of Interface failed'))
                            self.failed()
                    
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Shutting Down L3 VNI SVIs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... :')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Unshutting the L3VNI SVIs on both the Leafs') as s:
                
                for dut in leaf_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    args = configdict['scale_config_dict'][dut]['interface']['svi']
                    ns = MyLib.my_config_utils.parseScaleSVIParams(log,args)
                    for i in range(ns.l3_vni_svi_start,ns.l3_vni_svi_start+ns.no_of_l3_vni_svi):
                        interface = 'Vlan{0}'.format(i)
                        res = MyLib.my_utils.unshutDownInterface(log,hdl,interface,dut)
                        if not res:
                            log.error(banner('Shutdown of Interface failed'))
                            self.failed()       
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting BGP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(vtep_dict.keys()))))
                
                for dut in vtep_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()

# DCI ECMP-ECMP
class VxlanCloudSec_Func098(aetest.Testcase):

    """ Vxlan CloudSec - DCI ECMP-ECMP - FUNC098"""

    uid = 'VXLAN-CS-FUNC-098'

    @aetest.test
    def VxlanCloudSec_FlappingOneofDCILink_Func098(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test98:- DCI ECMP-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        pre_condition_flag = 0
        dci_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('ECMP-ECMP DCI Interface Shut') as s:
                if not dci_interface_list:
                    if len(dci_interface_list) > 2:
                        random_intf = random.sample(dci_interface_list,1)
                        cfg = '''interface {0}
                                 shutdown'''.format(random_intf)
                        site1_hdl.configure(cfg)
                    else:
                        log.error('Initial condition is not met... Skipping the test case...')
                        global_flag = 1
                        pre_condition_flag = 1
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Unshutting the DCI Interface...') as s:
                if not traffic_flag and not dci_interface_list and not pre_condition_flag:
                    cfg = '''interface {0}
                             no shutdown'''.format(random_intf)
                    site1_hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))
                    if pre_condition_flag:
                        log.error(banner('FAIL - Precondition Failed - Unable to get DCI link as ECMP'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# DCI ECMP-Non-ECMP
class VxlanCloudSec_Func099(aetest.Testcase):

    """ Vxlan CloudSec - DCI ECMP-Non-ECMP - FUNC099"""

    uid = 'VXLAN-CS-FUNC-099'

    @aetest.test
    def VxlanCloudSec_FlappingDCIECMP_To_NONECMP_Func099(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test99:- DCI ECMP-Non-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        pre_condition_flag = 0
        dci_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('ECMP-ECMP DCI Interface Shut') as s:
                if not dci_interface_list:
                    total_dci_links = len(dci_interface_list)  # 4
                    if total_dci_links > 1:
                        random_intf_list = random.sample(dci_interface_list,total_dci_links-1)
                        for intf in random_intf_list:
                            cfg = '''interface {0}
                                     shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                    else:
                        log.error('Initial condition is not met... Skipping the test case...')
                        global_flag = 1
                        pre_condition_flag = 1
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()     

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
             
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))
                    if pre_condition_flag:
                        log.error(banner('FAIL - Precondition Failed - Unable to get DCI link as ECMP'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# DCI NONECMP-ECMP
class VxlanCloudSec_Func100(aetest.Testcase):

    """ Vxlan CloudSec - DCI NOn ECMP-ECMP - FUNC100"""

    uid = 'VXLAN-CS-FUNC-100'

    @aetest.test
    def VxlanCloudSec_FlappingDCINonECMP_To_ECMP_Func100(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test100:- DCI NONECMP-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        pre_condition_flag = 0
        dci_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('ECMP-ECMP DCI Interface Shut') as s:
                if not dci_interface_list:
                    total_dci_links = len(dci_interface_list)  # 4
                    if total_dci_links > 1:
                        random_intf_list = random.sample(dci_interface_list,total_dci_links-1)
                        for intf in random_intf_list:
                            cfg = '''interface {0}
                                     shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                    else:
                        log.error('Initial condition is not met... Skipping the test case...')
                        global_flag = 1
                        pre_condition_flag = 1
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            
            with steps.start('NOnCMP-ECMP DCI Interface unShut') as s:
                if not dci_interface_list and not traffic_flag and not pre_condition_flag:
                    for intf in dci_interface_list:
                        cfg = '''interface {0}
                                 no shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                    
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list and not traffic_flag and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1            
            
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()     

            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))
                    if pre_condition_flag:
                        log.error(banner('FAIL - Precondition Failed - Unable to get DCI link as ECMP'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Fabric Link ECMP-ECMP
class VxlanCloudSec_Func0101(aetest.Testcase):

    """ Vxlan CloudSec - Fabric Link ECMP-ECMP - FUNC101"""

    uid = 'VXLAN-CS-FUNC-101'

    @aetest.test
    def VxlanCloudSec_FabricLinkECMP_To_ECMP_Func101(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test98:- Fabric Link ECMP-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        pre_condition_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Fabric Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                fabric_interface_list = []
                cfg = 'show nve multisite fabric-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            fabric_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            fabric_flag = 1
                log.info('fabric_interface_list is -----> {0}'.format(fabric_interface_list))
                
            with steps.start('ECMP-ECMP Fabfic Interface Shut') as s:
                if not fabric_interface_list:
                    if len(fabric_interface_list) > 2:
                        random_intf = random.sample(fabric_interface_list,1)
                        cfg = '''interface {0}
                                 shutdown'''.format(random_intf)
                        site1_hdl.configure(cfg)
                    else:
                        log.error('Initial condition is not met... Skipping the test case...')
                        global_flag = 1
                        pre_condition_flag = 1
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling convering Fabric link ECMP-ECMP') as s:
                if not fabric_interface_list and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Unshutting the Fabric Interface...') as s:
                if not traffic_flag and not fabric_interface_list and not pre_condition_flag:
                    cfg = '''interface {0}
                             no shutdown'''.format(random_intf)
                    site1_hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After unshutting the Fabric link ECMP-ECMP') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))
                    if pre_condition_flag:
                        log.error(banner('FAIL - Precondition Failed - Unable to get DCI link as ECMP'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Fabric ECMP-Non-ECMP
class VxlanCloudSec_Func102(aetest.Testcase):

    """ Vxlan CloudSec - Fabric ECMP-Non-ECMP - FUNC102"""

    uid = 'VXLAN-CS-FUNC-102'

    @aetest.test
    def VxlanCloudSec_FlappingFabricECMP_To_NONECMP_Func102(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test102:- Fabric ECMP-Non-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        pre_condition_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Fabric Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                fabric_interface_list = []
                cfg = 'show nve multisite fabric-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            fabric_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            fabric_flag = 1
                log.info('fabric_interface_list is -----> {0}'.format(fabric_interface_list))
                
            with steps.start('ECMP-ECMP Fabric Interface Shut') as s:
                if not fabric_interface_list:
                    total_fabric_links = len(fabric_interface_list)  # 4
                    if total_fabric_links > 1:
                        random_intf_list = random.sample(fabric_interface_list,total_fabric_links-1)
                        for intf in random_intf_list:
                            cfg = '''interface {0}
                                     shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                    else:
                        log.error('Initial condition is not met... Skipping the test case...')
                        global_flag = 1
                        pre_condition_flag = 1
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not fabric_interface_list and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()     

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
             
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))
                    if pre_condition_flag:
                        log.error(banner('FAIL - Precondition Failed - Unable to get DCI link as ECMP'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Fabric NONECMP-ECMP
class VxlanCloudSec_Func103(aetest.Testcase):

    """ Vxlan CloudSec - Fabric NOn ECMP-ECMP - FUNC100"""

    uid = 'VXLAN-CS-FUNC-103'

    @aetest.test
    def VxlanCloudSec_FlappinFabricNonECMP_To_ECMP_Func103(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test103:- Fabric NONECMP-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        pre_condition_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the Fabric Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                fabric_interface_list = []
                cfg = 'show nve multisite fabric-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            fabric_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            fabric_flag = 1
                log.info('fabric_interface_list is -----> {0}'.format(fabric_interface_list))
                
            with steps.start('ECMP-ECMP Fabric Interface Shut') as s:
                if not fabric_interface_list:
                    total_fabric_links = len(fabric_interface_list)  # 4
                    if total_fabric_links > 1:
                        random_intf_list = random.sample(fabric_interface_list,total_fabric_links-1)
                        for intf in random_intf_list:
                            cfg = '''interface {0}
                                     shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                    else:
                        log.error('Initial condition is not met... Skipping the test case...')
                        global_flag = 1
                        pre_condition_flag = 1
                                
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not fabric_interface_list and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            
            with steps.start('NOnCMP-ECMP Fabric Interface unShut') as s:
                if not fabric_interface_list and not traffic_flag and not pre_condition_flag:
                    for intf in fabric_interface_list:
                        cfg = '''interface {0}
                                 no shutdown'''.format(intf)
                        site1_hdl.configure(cfg)
                    
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not fabric_interface_list and not traffic_flag and not pre_condition_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            stats_success_stream.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1            
            
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()     

            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))
                    if pre_condition_flag:
                        log.error(banner('FAIL - Precondition Failed - Unable to get DCI link as ECMP'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Modify BGP multipath from ECMP to Non-ECMP
class VxlanCloudSec_Func104(aetest.Testcase):

    """ Vxlan CloudSec - Modify BGP multipath from ECMP to Non-ECMP"""

    uid = 'VXLAN-CS-FUNC-104'

    @aetest.test
    def VxlanCloudSec_RemoveAddMultisiteConfig_Func104(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test104:- Modify BGP multipath from ECMP to Non-ECMP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        fabric_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Adding the Multiste Configs from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = '''router bgp {0}
                             address-family ipv4 unicast
                             no maximum-paths 64
                             no maximum-paths ibgp 64
                             address-family l2vpn evpn
                             no maximum-paths 64
                             no maximum-paths ibgp 64
                          '''.format(bgp_as_no[0])
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Adding Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Removing the Multiste Configs from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    bgp_as_no = list(configdict['bgp_config_dict'][dut].keys())
                    cfg = '''router bgp {0}
                             address-family ipv4 unicast
                             maximum-paths 64
                             maximum-paths ibgp 64
                             address-family l2vpn evpn
                             maximum-paths 64
                             maximum-paths ibgp 64
                          '''.format(bgp_as_no[0])
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After Removing Advertise PIP') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if fabric_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out  dci interface list.. REfer Logs'))
                    if dci_flag:
                        log.error(banner('FAIL- Some exception occured while pulling out fabric interface list.. REfer Logs'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Add / Remove Multisite Loopback config from NVE
class VxlanCloudSec_Func105(aetest.Testcase):

    """ Vxlan CloudSec - Add / Remove Multisite Loopback config from NVE-FUNC105"""

    uid = 'VXLAN-CS-FUNC-105'

    @aetest.test
    def VxlanCloudSec_RemoveAddMultisiteLoopbackConfig_Func105(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test67:- add/remove advertise PIP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the Multiste loopback Configs from Nve Intf on BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''interface nve 1
                             no multisite border-gateway interface loopback2
                          '''
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Multisite Loopback config from Nve ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Adding  the Multiste LoopbackConfigs on Nve from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''interface nve 1
                             multisite border-gateway interface loopback2
                          '''
                    hdl.configure(cfg)          
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding the Multisite Loopback configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add Multisite ingress replication under interface nve
class VxlanCloudSec_Func106(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add Multisite ingress replication under interface nve-FUNC106"""

    uid = 'VXLAN-CS-FUNC-106'

    @aetest.test
    def VxlanCloudSec_RemoveAddMultisiteIRConfig_Func105(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test106:- add/remove advertise PIP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the Multisite IR Configs from Nve Intf on BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'sh run int nve 1 | grep "member vni 1"'
                    out = hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('^\s+member vni', line, re.I):
                            cfg = '''interface nve 1
                                     {0}
                                     no multisite ingress-replication'''.format(line)
                            hdl.configure(cfg)
                    
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Multisite Loopback config from Nve ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Adding  the Multiste IR Configs on Nve from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'sh run int nve 1 | grep "member vni 1"'
                    out = hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('^\s+member vni', line, re.I):
                            cfg = '''interface nve 1
                                     {0}
                                     multisite ingress-replication'''.format(line)
                            hdl.configure(cfg)   
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding the Multisite Loopback configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add ingress replication config under interface nve
class VxlanCloudSec_Func107(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add ingress replication config under interface nve-FUNC106"""

    uid = 'VXLAN-CS-FUNC-107'

    @aetest.test
    def VxlanCloudSec_RemoveAddIRConfig_Func107(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test107:- Remove and add ingress replication config under interface nve'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Removing the Multisite IR Configs from Nve Intf on BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'sh run int nve 1 | grep "member vni 1"'
                    out = hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('^\s+member vni', line, re.I):
                            cfg = '''interface nve 1
                                     {0}
                                     no ingress-replication protocol bgp'''.format(line)
                            hdl.configure(cfg)
                    
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Multisite Loopback config from Nve ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Adding  the Multiste IR Configs on Nve from BGW') as s:
                
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'sh run int nve 1 | grep "member vni 1"'
                    out = hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('^\s+member vni', line, re.I):
                            cfg = '''interface nve 1
                                     {0}
                                     ingress-replication protocol bgp'''.format(line)
                            hdl.configure(cfg)   
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding the Multisite Loopback configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    traffic_flag = 1
                    restore_flag = 1
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add L2VNI config from Nve
class VxlanCloudSec_Func108(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add L2VNI config from Nve -FUNC108"""

    uid = 'VXLAN-CS-FUNC-108'

    @aetest.test
    def VxlanCloudSec_RemoveAddIRConfig_Func108(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test108:- Remove and add L2VNI config from Nve'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Nve Interface Config') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show running-config interface nve1'
                    cfg = cmd_str + ' > nve_interface_configs'
                    delete = 'delete bootflash:nve_interface* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing the L2VNI Config from Nve Intf on all VTEPs') as s:
                
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'sh run int nve 1 | grep "member vni 1"'
                    out = hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('^\s+member vni', line, re.I):
                            cfg = '''interface nve 1
                                     no {0}'''.format(line)
                            hdl.configure(cfg,timeout=600)              
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Multisite Loopback config from Nve ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Adding  the L2VNI configs on Nve on all VTEPs') as s:
                
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg1 = 'copy bootflash:nve_interface_configs running-config echo-commands'
                    hdl.configure(cfg1,timeout=600)
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding the Multisite Loopback configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add L3VNI config from Nve
class VxlanCloudSec_Func109(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add L3VNI config from Nve -FUNC109"""

    uid = 'VXLAN-CS-FUNC-109'

    @aetest.test
    def VxlanCloudSec_RemoveAddL3VNI_Func109(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test109:- Remove and add L3VNI config from Nve'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Nve Interface Config') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show running-config interface nve1'
                    cfg = cmd_str + ' > nve_interface_configs'
                    delete = 'delete bootflash:nve_interface* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing the L2VNI Config from Nve Intf on all VTEPs') as s:
                
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'sh run int nve 1 | grep "member vni 2"'
                    out = hdl.execute(cmd)
                    for line in out.splitlines():
                        if re.search('^\s+member vni', line, re.I):
                            cfg = '''interface nve 1
                                     no {0}'''.format(line)
                            hdl.configure(cfg,timeout=600)              
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Multisite Loopback config from Nve ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1

            with steps.start('Adding  the L2VNI configs on Nve on all VTEPs') as s:
                
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg1 = 'copy bootflash:nve_interface_configs running-config echo-commands'
                    hdl.configure(cfg1,timeout=600)

            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)

            with steps.start('Measuring Traffic Stats After adding the Multisite Loopback configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add Vn-segment from VLan
class VxlanCloudSec_Func110(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add Vn-segment from VLan -FUNC110"""

    uid = 'VXLAN-CS-FUNC-110'

    @aetest.test
    def VxlanCloudSec_RemoveAddVNSegment_Func110(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test110:- Remove and add Vn-segment from VLan'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Vlan Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show running-config vlan'
                    cfg = cmd_str + ' > vlan_configs'
                    delete = 'delete bootflash:vlan_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)


            with steps.start('Getting the Vlans from each box...') as s:
                vlan_dict = {}
                pat = '^(\d+)\s+VLAN(\d)+'
                for dut in all_boxes.keys():
                    vlan_list = []
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('sh vlan')
                    for line in out.splitlines():
                        match = re.search(pat,line,re.I)
                        if match:
                            vlan = match.group(1)
                            vlan_list.append('Vlan '+ str(vlan))
                    vlan_dict[dut]=vlan_list
                    
                log.info('The value of vlan_dict is ----->>> {0}'.format(vlan_dict))

            with steps.start('Removing the VN-Segement from the Vlans') as s:
                
                for dut in vlan_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    if vlan_dict[dut]:
                        for vlan in vlan_dict[dut]:
                            cfg = '''{0}
                                     no vn-segment'''.format(vlan)
                            hdl.configure(cfg, timeout = 600)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Putting back the Vlan configs on all the VTEPs') as s:

                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg1 = 'copy bootflash:vlan_configs running-config echo-commands'
                    hdl.configure(cfg1, timeout = 600)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the Vlan configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add Vlan from VTEPs
class VxlanCloudSec_Func111(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add Vlan from VTEPs-FUNC111"""

    uid = 'VXLAN-CS-FUNC-111'

    @aetest.test
    def VxlanCloudSec_RemoveAddVlan_Func111(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test111:- Remove and add Vlan from VTEPs'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of Vlan Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'show running-config vlan'
                    cfg = cmd_str + ' > vlan_configs'
                    delete = 'delete bootflash:vlan_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)


            with steps.start('Getting the Vlans from each box...') as s:
                vlan_dict = {}
                pat = '^(\d+)\s+VLAN(\d)+'
                for dut in all_boxes.keys():
                    vlan_list = []
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('sh vlan')
                    for line in out.splitlines():
                        match = re.search(pat,line,re.I)
                        if match:
                            vlan = match.group(1)
                            vlan_list.append('Vlan '+ str(vlan))
                    vlan_dict[dut]=vlan_list
                    
                log.info('The value of vlan_dict is ----->>> {0}'.format(vlan_dict))

            with steps.start('Removing the VN-Segement from the Vlans') as s:
                
                for dut in vlan_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    if vlan_dict[dut]:
                        for vlan in vlan_dict[dut]:
                            cfg = 'no {0}'.format(vlan)
                            hdl.configure(cfg, timeout=600)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Putting back the Vlan configs on all the VTEPs') as s:

                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg1 = 'copy bootflash:vlan_configs running-config echo-commands'
                    hdl.configure(cfg1, timeout=600)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the Vlan configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add VRFs SVI
class VxlanCloudSec_Func112(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add VRFs SVI-FUNC112"""

    uid = 'VXLAN-CS-FUNC-112'

    @aetest.test
    def VxlanCloudSec_RemoveAddVRFsSVI_Func112(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test112:- Remove and add VRFs SVI'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of svi Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "interface Vlan"'
                    cfg = cmd_str + ' > svi_configs'
                    delete = 'delete bootflash:svi_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg,timeout=600)

            with steps.start('Getting the SVI Vlans from each box...') as s:
                svi_dict = {}
                pat = '^interface\s+Vlan(\d+)'
                for dut in all_boxes.keys():
                    svi_list = []
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('sh run | grep "interface Vlan"')
                    for line in out.splitlines():
                        match = re.search(pat,line,re.I)
                        if match:
                            vlan = match.group(1)
                            svi_list.append('Vlan'+ str(vlan))
                    svi_dict[dut]=svi_list
                    
                log.info('The value of svi_dict is ----->>> {0}'.format(svi_dict))

            with steps.start('Removing the SVIs from the VTEPs') as s:
                
                for dut in svi_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    if svi_dict[dut]:
                        for vlan in svi_dict[dut]:
                            cfg = 'no interface {0}'.format(vlan)
                            hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Putting back the Vlan configs on all the VTEPs') as s:

                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg1 = 'copy bootflash:svi_configs running-config echo-commands'
                    hdl.configure(cfg1, timeout=600)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the SVI configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add VNIs on VRF
class VxlanCloudSec_Func113(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add VNIs on VRF -FUNC113"""

    uid = 'VXLAN-CS-FUNC-113'

    @aetest.test
    def VxlanCloudSec_RemoveAddVNIOnVRF_Func113(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test113:- Remove and add VNIs on VRF'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of svi Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "vrf context"'
                    cfg = cmd_str + ' > vrf_configs'
                    delete = 'delete bootflash:vrf_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing the VNIs from the VTEPs') as s:
                
                for dut in all_boxes.keys():
                    args = configdict['scale_config_dict'][dut]['global']['vrf']
                    ns = MyLib.my_config_utils.parseScaleVRFParams(log,args)
                    vrf_list = MyLib.my_config_utils.generateVRFlist(ns.vrf_start,ns.no_of_vrf)
                    hdl = node_dict['all_dut'][dut]
                    for vrf in vrf_list:
                        cfg = '''vrf context {0}
                                 no vni'''.format(vrf)
                        hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Putting back the VNI configs on VRF in all the VTEPs') as s:

                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    vni_start = ns.vrf_vni_start
                    for i, vrf in enumerate(vrf_list):
                        cfg = '''vrf context {0}
                                 vni {1}'''.format(vrf,vni_start+i)
                        hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the SVI configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# VRF shut / Unshut
class VxlanCloudSec_Func114(aetest.Testcase):

    """ Vxlan CloudSec - VRF Shut / Unshut -FUNC114"""

    uid = 'VXLAN-CS-FUNC-114'

    @aetest.test
    def VxlanCloudSec_RemoveAddVNIOnVRF_Func114(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test114:- VRF shut / Unshut '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of svi Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "vrf context"'
                    cfg = cmd_str + ' > vrf_configs'
                    delete = 'delete bootflash:vrf_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Shutting the VRF on all the VTEPs') as s:
                
                for dut in all_boxes.keys():
                    args = configdict['scale_config_dict'][dut]['global']['vrf']
                    ns = MyLib.my_config_utils.parseScaleVRFParams(log,args)
                    vrf_list = MyLib.my_config_utils.generateVRFlist(ns.vrf_start,ns.no_of_vrf)
                    hdl = node_dict['all_dut'][dut]
                    for vrf in vrf_list:
                        cfg = '''vrf context {0}
                                 shutdown'''.format(vrf)
                        hdl.configure(cfg)
            
            log.info('Waiting for 300 seconds before measuring the traffic stats.')
            countDownTimer(300)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Unshuttting the VRF in all the VTEPs') as s:

                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    vni_start = ns.vrf_vni_start
                    for vrf in vrf_list:
                        cfg = '''vrf context {0}
                                 no shutdown'''.format(vrf)
                        hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the SVI configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# VRF removal and addition
class VxlanCloudSec_Func115(aetest.Testcase):

    """ Vxlan CloudSec - REmove and Add VRF -FUNC115"""

    uid = 'VXLAN-CS-FUNC-115'

    @aetest.test
    def VxlanCloudSec_RemoveAddVRF_Func115(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test115:- VRF removal and addition '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of svi Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "vrf context"'
                    cfg = cmd_str + ' > vrf_configs'
                    delete = 'delete bootflash:vrf_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg)

            with steps.start('Removing the VRF on all the VTEPs') as s:
                
                for dut in all_boxes.keys():
                    args = configdict['scale_config_dict'][dut]['global']['vrf']
                    ns = MyLib.my_config_utils.parseScaleVRFParams(log,args)
                    vrf_list = MyLib.my_config_utils.generateVRFlist(ns.vrf_start,ns.no_of_vrf)
                    hdl = node_dict['all_dut'][dut]
                    for vrf in vrf_list:
                        cfg = 'no vrf context {0}'.format(vrf)
                        hdl.configure(cfg)
            
            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Adding the Multisite Loopback Configs') as s:
                
                if not traffic_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cfg1 = 'copy bootflash:vrf_configs running-config echo-commands'
                        hdl.configure(cfg1)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the SVI configs') as s:

                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remoivng policy associated with active tunnel-encryption session
class VxlanCloudSec_Func116(aetest.Testcase):

    """ Vxlan MS-CloudSec-Remoivng policy associated with active tunnel-encryption session Func-116"""

    uid = 'VXLAN-CS-FUNC-116'

    @aetest.test
    def VxlanCS_RemovePolicyFromActiveCS_Session_Func16(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test116:- Remoivng policy associated with active tunnel-encryption session'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        policy_remove_flag = 0
        mask_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res1 = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res1['peer_ip'],res1['keychainname'],res1['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the New KeyChain') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1

            with steps.start('Verifying the policy Removal from active tunnel-Encryption session') as s:
                if not traffic_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the key ')
                    countDownTimer(30)
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    cmd = 'no tunnel-encryption policy {0}'.format(res1['policyname'])
                
                    out = site1_hdl.configure(cmd)
                    pat = 'Cannot delete tunnel-encryption policy'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info(banner('Policy removal is not allowed as expected'))
                        log.info(banner('Measuing Traffic just to be on safer side...'))
                        out = trigger_obj.checkAllStreamStats(tgn_hdl)
                        if not out:
                            log.error(banner('Traffic  Stream stats is not as expected after the end of the trigger .. Traffic status in Table format is: .. '))
                            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                            global_flag = 1
                            traffic_flag = 1
                    else:
                        log.info(banner('Policy  removal Error msg is not seen..'))
                        cmd = 'show run | grep "tunnel-encryption policy {0}"'.fomraT(res1['policy_name'])
                        out = site1_hdl.execute(cmd)
                        if re.search('KC0012',out,re.I):
                            log.info(banner('ERROR CASE:- Policy is still found on Running config'))
                        global_flag = 1
                        policy_remove_flag = 1
              
                                                           
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if policy_remove_flag:
                        log.error('KeyChain Removal Error message was not seen. Refer Logs. ')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Remove Add Tunnel-Encryption peer
class VxlanCloudSec_Func117(aetest.Testcase):

    """ Vxlan MS-CloudSec-Remove Add Tunnel-Encryption Peer Func-117"""

    uid = 'VXLAN-CS-FUNC-117'

    @aetest.test
    def VxlanCS_RemovePolicyFromActiveCS_Session_Func117(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test117:- Remove Add Tunnel-Encryption peer'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        policy_remove_flag = 0
        mask_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res1 = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res1['peer_ip'],res1['keychainname'],res1['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the New KeyChain') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1

            with steps.start('Remove the Tunnel-Encrpytion peer') as s:
                if not traffic_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the key ')
                    countDownTimer(30)
                    
                    for dut in cloudsec_peer_per_dut.keys():
                        peer_ip = cloudsec_peer_per_dut[dut]
                        hdl = node_dict['all_dut'][dut]
                        cmd = 'no tunnel-encryption peer-ip {0}'.format(peer_ip[0])
                        hdl.configure(cmd)
                    

            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not traffic_flag:
                    stats_success_stream = []
                    stats_fail_stream = []

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the Tunnel-Encrpytion peer Configs') as s:
                if not traffic_flag:
                    
                    for dut in cloudsec_peer_per_dut.keys():
                        peer_ip = cloudsec_peer_per_dut[dut]
                        hdl = node_dict['all_dut'][dut]
                        cfg = '''tunnel-encryption peer-ip {0}
                                 keychain KC0012 policy {1}'''.format(peer_ip[0],res1['policyname'])
                        hdl.configure(cfg)

            with steps.start('Verify Tunnel-Encryption Session after adding the Tunnel-Encryption peer') as s:

                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the CloudSec peer') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 45 seconds before collecting the Traffic Stats'))
                    countDownTimer(45)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1          
                                 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Remove Add CAK KEY
class VxlanCloudSec_Func118(aetest.Testcase):

    """ Vxlan MS-CloudSec-Remove Add CAK KEY Func-118"""

    uid = 'VXLAN-CS-FUNC-118'

    @aetest.test
    def VxlanCS_RemoveAddCAKKey_Func118(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test118:- Remove Add CAK KEY'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        policy_remove_flag = 0
        mask_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res1 = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res1['peer_ip'],res1['keychainname'],res1['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the New KeyChain') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1

            with steps.start('Removing the CAK Key from the active Session:') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the CAK key ')
                    countDownTimer(30)
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    cfg = '''key chain KC0012 tunnel-encryption
                             key 11
                            no key-octet-string'''
                    
                    site1_hdl.configure(cfg)

            with steps.start('Verify Tunnel-Encryption Session after removing CAK KEY') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                    countDownTimer(30)
                    log.info('Verify CloudSec Session across dut: ')
                    
                    res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                    if res:
                        log.error('CloudSec Peer is still seen when exepceted to go down.')
                        tunnel_flag = 1
                        global_flag = 1                    

            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not traffic_flag and not tunnel_flag:
                    stats_success_stream = []
                    stats_fail_stream = []

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the Key String ') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the CAK key ')
                    countDownTimer(30)

                    
                    cfg = '''key chain KC0012 tunnel-encryption
                             key 11
                             key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                    
                    site1_hdl.configure(cfg)

            with steps.start('Verify Tunnel-Encryption Session after adding the Tunnel-Encryption peer') as s:

                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the CloudSec peer') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 45 seconds before collecting the Traffic Stats'))
                    countDownTimer(45)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1          
                                 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Remove Add CKN KEY
class VxlanCloudSec_Func119(aetest.Testcase):

    """ Vxlan MS-CloudSec-Remove Add CKN KEY Func-119"""

    uid = 'VXLAN-CS-FUNC-119'

    @aetest.test
    def VxlanCS_RemoveAddCKNKey_Func119(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test119:- Remove Add CKN KEY'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        policy_remove_flag = 0
        mask_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res1 = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res1['peer_ip'],res1['keychainname'],res1['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the New KeyChain') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 10 seconds before collecting the Traffic Stats'))
                    countDownTimer(10)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1

            with steps.start('Removing the CKN Key from the active Session:') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the CAK key ')
                    countDownTimer(30)
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    cfg = '''key chain KC0012 tunnel-encryption
                             no key 11
                            '''
                    
                    site1_hdl.configure(cfg)

            with steps.start('Verify Tunnel-Encryption Session after removing CAK KEY') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                    countDownTimer(30)
                    log.info('Verify CloudSec Session across dut: ')
                    
                    res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                    if res:
                        log.error('CloudSec Peer is still seen when exepceted to go down.')
                        tunnel_flag = 1
                        global_flag = 1                    

            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not traffic_flag and not tunnel_flag:
                    stats_success_stream = []
                    stats_fail_stream = []

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the CKN ') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info(banner('Cummulative Traffic flow was as expected.. '))
                    log.info('Waiting for 30 secs before removing the CAK key ')
                    countDownTimer(30)

                    
                    cfg = '''key chain KC0012 tunnel-encryption
                             key 11
                             key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year)
                    
                    site1_hdl.configure(cfg)

            with steps.start('Verify Tunnel-Encryption Session after adding the Tunnel-Encryption peer') as s:

                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected after configuring the New KC policy')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying Traffic with the CloudSec peer') as s:
                if not tunnel_flag:
                    log.info(banner('Waiting for 45 seconds before collecting the Traffic Stats'))
                    countDownTimer(45)
                    log.info(banner('Measuring The Traffic stats:'))
                    out = trigger_obj.checkAllStreamStats(tgn_hdl)
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    
                    if not out:
                        log.error(banner('Traffic  Stream stats is not as expected after configuring New Key Chain .. Traffic status in Table format is: .. '))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        traffic_flag = 1
                        global_flag = 1          
                                 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# CKN Mismatch - Must Secure
class VxlanCloudSec_Func120(aetest.Testcase):

    """ Vxlan MS-CloudSec-CKN Mismatch - Must Secure Func-120"""

    uid = 'VXLAN-CS-FUNC-120'

    @aetest.test
    def VxlanCS_RemoveAddCKNKey_Func120(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test120:- CKN Mismatch - Must Secure'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        error_flag = 0
        xml_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))                              
                    if re.search('Should', current_mode, re.I):                    
                        hdl.configure('tunnel-encryption must-secure-policy ') 
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for i, dut in enumerate(bgw_dict.keys()):
                    key = i + 10
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key {6}
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year,key)
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res1 = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res1['peer_ip'],res1['keychainname'],res1['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if res:
                    log.error('CloudSec Peer is formed when not supposed to')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying CKN Mismatch Error:') as s:
                if not tunnel_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cmd = '''interface nve 1
                                 shutdown
                                 no shutdown'''
                        hdl.configure(cmd)
                    log.info(banner('Waiting for 30 seconds before checking the CKN Mismatch Error'))
                    countDownTimer(30)
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    cmd = 'sh tunnel-encryption session detail | xml'
                    out = site1_hdl.execute(cmd)
                    
                    s = BeautifulSoup(out)
                    try:
                        status = s.find('txstatus').string
                        if re.search('CKN-mismatch', status, re.I):
                            log.info(banner('CKN Mismatch Error is seen as expected.. '))
                        else:
                            log.error('CKN Mismatch Error is not seen.')
                            error_flag = 1
                    except Exception as e:
                        log.info('Exception Occured is {0}'.format(e))
                        log.error('Unable to find thte txstatus ')
                        xml_flag = 1
                        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not xml_flag and not error_flag and not tunnel_flag:
                    stats_success_stream = []
                    stats_fail_stream = []

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the proper CKN Key on both BGW') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''key chain KC0012 tunnel-encryption
                             no key 10
                             no key 11'''
                    hdl.configure(cfg)
                    cfg1 = '''key chain KC0012 tunnel-encryption
                              key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year,key)
                    hdl.configure(cfg1)

            with steps.start('Verify Tunnel-Encryption Session after removing CAK KEY') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                    countDownTimer(30)
                    log.info('Verify CloudSec Session across dut: ')
                    
                    res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                    if res:
                        log.error('CloudSec Peer is still seen when exepceted to go down.')
                        tunnel_flag = 1
                        global_flag = 1                    

            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not traffic_flag and not tunnel_flag:

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1
                                 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# CKN Mismatch - Should Secure
class VxlanCloudSec_Func121(aetest.Testcase):

    """ Vxlan MS-CloudSec-CKN Mismatch - Should Secure Func-121"""

    uid = 'VXLAN-CS-FUNC-121'

    @aetest.test
    def VxlanCS_RemoveAddCKNKey_Func121(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test121:- CKN Mismatch - Should Secure'))
        
        global_flag = 0
        tunnel_flag = 0
        restore_flag = 0
        traffic_flag = 0
        error_flag = 0
        xml_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))

            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        hdl.configure('no tunnel-encryption must-secure-policy ')
                                                      
                    if re.search('Should', current_mode, re.I):                    
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Configuring NTP on both the BGWs') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = 'ntp server 10.64.58.51 use-vrf management'
                    hdl.configure(cfg) 

            with steps.start('Configuring New KeyChain on both BGW with Timer') as s:
                for i, dut in enumerate(bgw_dict.keys()):
                    key = i + 10
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('show clock')
                    pat = '^(\d{2})\:(\d{2})\:(\d{2})\.(\d+)\s+UTC\s+[A-Za-z]{3}\s+([A-Za-z]{3})\s+(\d+)\s(\d{4})'
                    match = re.search(pat,out,re.I)
                    if match:
                        log.info('the value of match is : {0}'.format(match))
                        hour = match.group(1)
                        mins = match.group(2)
                        secs = match.group(3)
                        sub_sec = match.group(4)
                        mon = match.group(5)
                        date = match.group(6)
                        year = match.group(7)
                        
                        s = '{0} {1} {2}'.format(mon,date,year)
                        curr_date = datetime.strptime(s,"%b %d %Y")
                        new_date = curr_date + timedelta(days = 15)
                        cfg1 = '''key chain KC0012 tunnel-encryption
                                 key {6}
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year,key)
                        
                        hdl.configure(cfg1)
                        
                        peer_ip = cloudsec_peer_per_dut[dut][0]
                        res1 = MyLib.my_cloudsec_lib.getCloudSecPeerstatus(log,dut,hdl,peer_ip)
                        
                        cfg2 = '''tunnel-encryption peer-ip {0}
                                  no keychain {1} policy {2}
                                  keychain KC0012 policy {2}'''.format(res1['peer_ip'],res1['keychainname'],res1['policyname'])
                                  
                        hdl.configure(cfg2)
                    
                    
            with steps.start('Verify Tunnel-Encryption Session with New KeyChain') as s:
                log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                countDownTimer(30)
                log.info('Verify CloudSec Session across dut: ')
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if res:
                    log.error('CloudSec Peer is formed when not supposed to')
                    tunnel_flag = 1
                    global_flag = 1
                    
            with steps.start('Verifying CKN Mismatch Error:') as s:
                if not tunnel_flag:
                    for dut in bgw_dict.keys():
                        hdl = node_dict['all_dut'][dut]
                        cmd = '''interface nve 1
                                 shutdown
                                 no shutdown'''
                        hdl.configure(cmd)
                    log.info(banner('Waiting for 30 seconds before checking the CKN Mismatch Error'))
                    countDownTimer(30)
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    cmd = 'sh tunnel-encryption session detail | xml'
                    out = site1_hdl.execute(cmd)
                    
                    s = BeautifulSoup(out)
                    try:
                        status = s.find('txstatus')
                        if re.search('CKN-mismatch', status, re.I):
                            log.info(banner('CKN Mismatch Error is seen as expected.. '))
                        else:
                            log.error('CKN Mismatch Error is not seen.')
                            error_flag = 1
                    except Exception as e:
                        log.info('Exception Occured is {0}'.format(e))
                        log.error('Unable to find thte txstatus ')
                        xml_flag = 1
                        
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not xml_flag and not error_flag and not tunnel_flag:
                    stats_success_stream = []
                    stats_fail_stream = []

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the proper CKN Key on both BGW') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cfg = '''key chain KC0012 tunnel-encryption
                             no key 10
                             no key 11'''
                    hdl.configure(cfg)
                    cfg1 = '''key chain KC0012 tunnel-encryption
                              key 11
                                 key-octet-string 11111111111111111111111111111111 cryptographic-algorithm AES_128_CMAC
                                 send-lifetime 00:00:00 Jan 01 2021 {0}:{1}:{2} {3} {4} {5}'''.format(hour,mins,secs,new_date.strftime("%b"),\
                                                                                                      new_date.day,new_date.year,key)
                    hdl.configure(cfg1)

            with steps.start('Verify Tunnel-Encryption Session after removing CAK KEY') as s:
                if not traffic_flag and not tunnel_flag:
                    log.info('Waiting for 30 seconds before checking the tunnel-encryption session')
                    countDownTimer(30)
                    log.info('Verify CloudSec Session across dut: ')
                    
                    res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                    if res:
                        log.error('CloudSec Peer is still seen when exepceted to go down.')
                        tunnel_flag = 1
                        global_flag = 1                    

            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                if not traffic_flag and not tunnel_flag:
                    stats_success_stream = []
                    stats_fail_stream = []

                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic drop is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            stats_fail_stream.append(item)
                            
                    if stats_fail_stream:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                        global_flag = 1
                        traffic_flag = 1
                                 
            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1
                    restore_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if xml_flag:
                        log.error('FAIL : - XML Extraction failed.')
                    if error_flag:
                        log.error('FAIL: - The CKN Mismatch error was not seen.')
                    if tunnel_flag:
                        log.error('CloudSEc session was not expected in one of the setup. pls debug')
                    if traffic_flag:
                        log.error('Traffic stats was not as expected in one of the setup. Pls debug.')
                    if restore_flag:
                        log.error('Traffic stats was not as expected after restoring the configs. ')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

# Removing Tunnel-Encryption CLI
class VxlanCloudSec_Func122(aetest.Testcase):

    """ Vxlan CloudSec - Removing Tunnel-Encryption CLI on Interface- FUNC122"""

    uid = 'VXLAN-CS-FUNC-122'

    @aetest.test
    def VxlanCloudSec_RemovingTunnelEncryptionCLI_Func122(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test122:- Removing Tunnel-Encryption CLI'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('Removing Tunnel-Encryption CLI on the DCI links:') as s:
                if dci_interface_list:
                    for link in dci_interface_list:
                        cmd = '''interface {0}
                                 no tunnel-encryption'''.format(link)
                        site1_hdl.configure(cmd)

            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if res:
                    log.error('CloudSec Peer is not expected to be formed here.')
                    tunnel_flag = 1
                    global_flag = 1

                    
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list and not tunnel_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the Tunnel-Encryption Configs the DCI Interface...') as s:
                if not traffic_flag and not dci_interface_list and not tunnel_flag:
                    for link in dci_interface_list:
                        cmd = '''interface {0}
                                 tunnel-encryption'''.format(link)
                        site1_hdl.configure(cmd)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Removing/Adding DCI Tracking
class VxlanCloudSec_Func123(aetest.Testcase):

    """ Vxlan CloudSec - Removing  / Adding DCI tracking - FUNC123"""

    uid = 'VXLAN-CS-FUNC-123'

    @aetest.test
    def VxlanCloudSec_RemovingAddingDCITRacking_Func123(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test122:- Removing/Adding DCI Tracking'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                
            with steps.start('Removing DCI tracking CLI on  DCI links:') as s:
                if dci_interface_list:
                    for link in dci_interface_list:
                        cmd = '''interface {0}
                                 no evpn multisite dci-tracking'''.format(link)
                        site1_hdl.configure(cmd)

                    
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not dci_interface_list and not tunnel_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the Tunnel-Encryption Configs the DCI Interface...') as s:
                if not traffic_flag and not dci_interface_list and not tunnel_flag:
                    for link in dci_interface_list:
                        cmd = '''interface {0}
                                 evpn multisite dci-tracking'''.format(link)
                        site1_hdl.configure(cmd)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Removing/Adding Fabric Tracking
class VxlanCloudSec_Func124(aetest.Testcase):

    """ Vxlan CloudSec - Removing  / Adding Fabric tracking - FUNC124"""

    uid = 'VXLAN-CS-FUNC-124'

    @aetest.test
    def VxlanCloudSec_RemovingAddingFabricTRacking_Func124(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test122:- Removing/Adding Fabric Tracking'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        success_stream_list = []
        fail_stream_list = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,dci_core]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                fabric_interface_list = []
                cfg = 'show nve multisite fabric-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            fabric_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('fabric_interface_list is -----> {0}'.format(fabric_interface_list))
                
            with steps.start('Removing Fabric tracking CLI on  Fabric links:') as s:
                if fabric_interface_list:
                    for link in fabric_interface_list:
                        cmd = '''interface {0}
                                 no evpn multisite fabric-tracking'''.format(link)
                        site1_hdl.configure(cmd)

                    
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After Disabling the Interface-vLan on all VTEPs') as s:
                if not fabric_interface_list and not tunnel_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and res['rx'] < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic drop on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1

            with steps.start('Adding the Tunnel-Encryption Configs the DCI Interface...') as s:
                if not traffic_flag and not fabric_interface_list and not tunnel_flag:
                    for link in fabirc_interface_list:
                        cmd = '''interface {0}
                                 evpn multisite fabric-tracking'''.format(link)
                        site1_hdl.configure(cmd)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After putting back the Interface-Vlan Config') as s:
                
                if not traffic_flag:
                    for item in configured_stream:
                        ixia_stream = traffic_stream_dict[item]['stream_id']
                        log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                        countDownTimer(5)
                        res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                        log.info(banner('The Value of res is: {0}'.format(res)))
                        
                        if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                            log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                            success_stream_list.append(item)
                        else:
                            log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                            fail_stream_list.append(item)
                            
                    if fail_stream_list:
                        log.error('Stream Pass Criteria Failed for streams {0}'.format(fail_stream_list))
                        global_flag = 1
                        traffic_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
                    
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error(banner('FAIL - Unable to get the DCI interfaces... Refer Logs for details'))
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Remove and add VRFs SVI
class VxlanCloudSec_Func125(aetest.Testcase):

    """ Vxlan CloudSec - Remove and add fabric forwarding under svi-FUNC125"""

    uid = 'VXLAN-CS-FUNC-125'

    @aetest.test
    def VxlanCloudSec_RemoveAddFabricForwarding_Func125(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test125:- Remove and add VRFs SVI'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Taking a snapshot of svi Config on all VTEPs') as s:
                for dut in all_boxes.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd_str = 'sh run | sec "interface Vlan"'
                    cfg = cmd_str + ' > svi_configs'
                    delete = 'delete bootflash:svi_config* no-prompt'
                    hdl.execute(delete)
                    hdl.execute(cfg,timeout=600)

            with steps.start('Getting the SVI Vlans from each box...') as s:
                svi_dict = {}
                pat = '^interface\s+Vlan(\d+)'
                for dut in leaf_dict.keys():
                    svi_list = []
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.execute('sh run | grep "interface Vlan"')
                    for line in out.splitlines():
                        match = re.search(pat,line,re.I)
                        if match:
                            vlan = match.group(1)
                            svi_list.append('Vlan'+ str(vlan))
                    svi_dict[dut]=svi_list
                    
                log.info('The value of svi_dict is ----->>> {0}'.format(svi_dict))

            with steps.start('Removing the Fabric forwarding CLIs on all  VTEPs') as s:
                
                for dut in svi_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    if svi_dict[dut]:
                        for vlan in svi_dict[dut]:
                            cfg = '''interface {0}
                                     no fabric forwarding mode anycast-gateway'''.format(vlan)               
                            hdl.configure(cfg)
            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and res['rx'] < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                
            with steps.start('Adding the Fabric forwarding CLIs on all  VTEPs') as s:
                
                for dut in svi_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    if svi_dict[dut]:
                        for vlan in svi_dict[dut]:
                            cfg = '''interface {0}
                                     fabric forwarding mode anycast-gateway'''.format(vlan)               
                            hdl.configure(cfg)

            log.info('Waiting for 120 seconds before measuring the traffic stats.')
            countDownTimer(120)

            with steps.start('Measuring Traffic Stats After adding the SVI fabric forwarding configs') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Process Restart Nve
class VxlanCloudSec_Func126(aetest.Testcase):

    """ Vxlan CloudSec - Process Restart - nve -FUNC126"""

    uid = 'VXLAN-CS-FUNC-126'

    @aetest.test
    def VxlanCloudSec_ProcessRestartNve_Func126(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test126:- Process Restart Nve'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Restart Nve') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_utils.verifyProcessRestart(log,hdl,'nve')
                    if not res:
                        log.error('Process restart failed.. ')
                        self.failed()

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and  abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Process Restart L2RIB
class VxlanCloudSec_Func127(aetest.Testcase):

    """ Vxlan CloudSec - Process Restart - L2RIB -FUNC127"""

    uid = 'VXLAN-CS-FUNC-127'

    @aetest.test
    def VxlanCloudSec_ProcessRestartL2Rib_Func127(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test127:- Process Restart L2RIB'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Restart L2RIB') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_utils.verifyProcessRestart(log,hdl,'l2rib')
                    if not res:
                        log.error('Process restart failed.. ')
                        self.failed()

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and  abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Process Restart BGP
class VxlanCloudSec_Func128(aetest.Testcase):

    """ Vxlan CloudSec - Process Restart - BGP -FUNC128"""

    uid = 'VXLAN-CS-FUNC-128'

    @aetest.test
    def VxlanCloudSec_ProcessRestartbgp_Func128(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test126:- Process Restart BGP'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Restart BGP') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_utils.verifyProcessRestart(log,hdl,'nve')
                    if not res:
                        log.error('Process restart failed.. ')
                        self.failed()

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and  abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Process Restart UFDM
class VxlanCloudSec_Func129(aetest.Testcase):

    """ Vxlan CloudSec - Process Restart - UFDM -FUNC129"""

    uid = 'VXLAN-CS-FUNC-129'

    @aetest.test
    def VxlanCloudSec_ProcessRestartUFDM_Func129(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test129:- Process Restart UFDM'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Restart UDFM') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_utils.verifyProcessRestart(log,hdl,'ufdm')
                    if not res:
                        log.error('Process restart failed.. ')
                        self.failed()

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and  abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Process Restart Tunnel Encryption
class VxlanCloudSec_Func130(aetest.Testcase):

    """ Vxlan CloudSec - Process Restart - Tunnel_Encryption -FUNC130"""

    uid = 'VXLAN-CS-FUNC-130'

    @aetest.test
    def VxlanCloudSec_ProcessRestartTunnelEncryption_Func126(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test130:- Process Restart Tunnel Encryption'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Restart Tunnel-Encrpytion') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    res = MyLib.my_utils.verifyProcessRestart(log,hdl,'tun_enc_mgr')
                    if not res:
                        log.error('Process restart failed.. ')
                        self.failed()

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# CLear BGP Neighbor
class VxlanCloudSec_Func131(aetest.Testcase):

    """ Vxlan CloudSec - Clear commands - clear IPBGP NEighbor -FUNC131"""

    uid = 'VXLAN-CS-FUNC-131'

    @aetest.test
    def VxlanCloudSec_ClearBGPNEighbor_Func131(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test131:- CLear BGP Neighbor'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Clear BGP *') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'clear bgp all * vrf all'
                    hdl.configure(cmd)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# CLear ip route *
class VxlanCloudSec_Func132(aetest.Testcase):

    """ Vxlan CloudSec - Clear command - clear ip route * -FUNC131"""

    uid = 'VXLAN-CS-FUNC-132'

    @aetest.test
    def VxlanCloudSec_ClearIPRoute_Func132(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test132:- CLear ip route *'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Clear ip route vrf all *') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'clear ip route vrf all *'
                    hdl.configure(cmd)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Clear ipv6 route *
class VxlanCloudSec_Func133(aetest.Testcase):

    """ Vxlan CloudSec - Clear commands - clear ipv6 route * -FUNC131"""

    uid = 'VXLAN-CS-FUNC-133'

    @aetest.test
    def VxlanCloudSec_ClearIPV6Route_Func133(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test133:- CLear ipv6 route *'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Clear ipv6 route vrf all *') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'clear ipv6 route vrf all *'
                    hdl.configure(cmd)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic drop is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Clear ip arp *
class VxlanCloudSec_Func134(aetest.Testcase):

    """ Vxlan CloudSec - Clear Commands - clear ip arp * -FUNC134"""

    uid = 'VXLAN-CS-FUNC-134'

    @aetest.test
    def VxlanCloudSec_ClearIPARP_Func134(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test134:- CLear ip arp *'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Clear ip arp vrf all force-delete') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'clear ip arp vrf all force-delete'
                    hdl.configure(cmd)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Clear mac address dynamic
class VxlanCloudSec_Func135(aetest.Testcase):

    """ Vxlan CloudSec - clear commands- clear mac address-table dynamic -FUNC135"""

    uid = 'VXLAN-CS-FUNC-135'

    @aetest.test
    def VxlanCloudSec_ClearMacAddress_Func135(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test135:- Clear mac address dynamic '))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
                
            log.info('the value of all_boxes is : {0}'.format(all_boxes))
            port_channel_dict = configdict['trigger_dict']['TRIG-003']['portchannel']
            
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Process - Clear Mac addresd table dynamic. *') as s:
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    cmd = 'clear mac address-table dynamic'
                    hdl.configure(cmd)

            
            log.info('Waiting for 60 seconds before measuring the traffic stats.')
            countDownTimer(60)
            
            with steps.start('Measuring Traffic Stats After removing the Vlan cnofigs ') as s:
                stats_success_stream = []
                stats_fail_stream = []
                for item in configured_stream:
                    ixia_stream = traffic_stream_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(5)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] > 200 and abs(res['tx'] - res['rx']) < threshold:
                        log.info('The traffic  is as expected.... ')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream {2} is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'],item)))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    trigger_flag = 1
                 
            with steps.start('Restoring Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()        
            
            log.info('Waiting for 120 seconds before measuring the Traffic Convergence')
            countDownTimer(120)
            
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if traffic_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after PO Conversion. Refer Logs for details'))
                    if restore_flag:
                        log.error(banner('FAIL- Traffic Test Failed on streams after Physical Interface Conversion'))

                        log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                        traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                        traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                        countDownTimer(300)
                    self.failed()

# Verify rewrite qos priority on the dci interface *
class VxlanCloudSec_Func136(aetest.Testcase):

    """ Vxlan CloudSec - Verify rewrite qos priority on the dci interface-FUNC135"""

    uid = 'VXLAN-CS-FUNC-136'

    @aetest.test
    def VxlanCloudSec_VerifyingRewriteQOSPriority_Func136(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test136:- Verify rewrite qos priority on the dci interface *'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        af_flag = 0
        stream_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Creating Ixia Interfaces required for the test') as s:
                source_port = testscript.parameters['configdict']['TG'][TG]['TEST-021']['traffic_config_dict']['source']
                receiver_port = testscript.parameters['configdict']['TG'][TG]['TEST-021']['traffic_config_dict']['receivers']
                traffic_args=testscript.parameters['configdict']['TG'][TG]['TEST-021']['traffic_config_dict']['params']
                src_port = [port_handle_dict[x] for x in source_port]
                dst_port = [port_handle_dict[x] for x in receiver_port]
                
                log.info(banner('Creating an Host Interface on Ixia:'))
                intf_params = traffic_args['host_params']
                ixia_intf_conf = configureIxNetworkInterface(self,intf_params,tg_hdl = tgn_hdl,port_handle = port_handle_dict[receiver_port[0]])
                
                traffic_gen_object = MyLib.my_config_utils.IxiaRawTrafficGeneration(log,tgn_hdl,configdict,port_handle_dict)
                
                end_point_args = traffic_args['Traffic_End_points']
                log.info(banner('The value of end_point_args is : {0}'.format(end_point_args)))
                
                vxlan_traffic_config = traffic_gen_object.configureTrafficEndPoints(end_point_args,emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                log.info('The value of ixia_traffic_config is : {0}'.format(vxlan_traffic_config))
                
                if vxlan_traffic_config['status'] == 1:
                    log.info(banner('Traffic End points is configured as expected.. configuring the STream params'))
                    trf_hdl = vxlan_traffic_config['traffic_item']
                    traffic_stream_args  = traffic_args['StreamParameters']
                    vxlan_traffic_config1 = traffic_gen_object.configureTrafficStreamParameters(trf_hdl,traffic_stream_args)
                    if vxlan_traffic_config1['status'] == 1:
                        log.info(banner('Configuring the Ethernet Header -- Stack 1 '))
                        ethernet1_header_args = traffic_args['EthernetHeader1']
                        vxlan_traffic_config2 = traffic_gen_object.configureEthernetHeader(trf_hdl,ethernet1_header_args)
                        if vxlan_traffic_config2['status'] == 1:
                            log.info(banner('Configuring the Vlan Header -- Stack 2 '))
                            vlan_header_args = traffic_args['VlanHeader']
                            vxlan_traffic_config3 = traffic_gen_object.configureVlanHeader(trf_hdl,vlan_header_args)
                            if vxlan_traffic_config3['status'] == 1:
                                log.info(banner('Configuring the IPv4 Header with DSCP-- Stack 3'))
                                ip1_header_args = traffic_args['IPHeader1']
                                vxlan_traffic_config4 = traffic_gen_object.configureIPv4ProtocolHeader(trf_hdl,ip1_header_args)
                                
            with steps.start('Ping the host from Leaf2 to simulate ARP entry and EVPN Route Propogation') as s:
                for dut, hdl in node_dict['Site2']['LEAF'].items(): pass
                out = hdl.execute('ping 142.100.1.123 vrf V-001 count 20')
                pat = '(\d+)\s+packets transmitted.\s+(\d+)\s+packets received,\s+(\d+.\d+)%\s+packet loss'
                match = re.search(pat,out,re.M)
                if match:
                    pass_percent = match.group(3)
                    if float(pass_percent) < 10.0:
                        log.info('Ping to Host is successful as expected..')
                    else:
                        log.error('Ping to host is unsuccessful.')
                        self.failed()
                else:
                    log.error('Could not fetch the Ping results Failing the test cases.')
                    self.failed()
                    
            with steps.start('Staring the Newly Created Stream for this test') as s:
                log.info(banner('Waiting for 20 seconds before collecting the stats'))
                countDownTimer(20)
                b = tgn_hdl.traffic_control(action='run', handle = trf_hdl, max_wait_timer=60)
                if not b['status']:
                    stream_flag = 1
            
            with steps.start('Measuring the Traffic stats for this stream') as s:
                stream_dict = {}
                stream_dict.setdefault('TEST-021',{})
                stream_dict['TEST-021']['stream_id'] = vxlan_traffic_config['stream_id']
                
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,stream_dict,'TEST-021')
                
                if abs(res['tx']-res['rx']) < threshold:
                    log.info('Traffic flow is as expected..The value of tx and Rx is : {0} and {1}'.format(res['tx'],res['rx']))
                else:
                    log.error('Traffic Flow is not as expected. The value of tx and Rx is : {0} and {1}'.format(res['tx'],res['rx']))
                    traffic_flag = 1
                    global_flag = 1
                    
            with steps.start('Applying the QOS policy on the Nve Interface:') as s:
                if not traffic_flag:
                    cfg = '''class-map type qos match-all dscp-20
                             match dscp 20
                             policy-map type qos dscp-policy
                              class dscp-20
                               set dscp 22
                             int nve 1
                             service-policy type qos input dscp-policy'''
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    site1_hdl.configure(cfg)
                    
            with steps.start('Configuring the Monitor Session') as s:
                if not traffic_flag:
                    cfg = '''monitor session 1
                             source interface Ethernet1/13 tx
                             destination interface sup-eth0
                             no shut'''
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    site1_hdl.configure(cfg)
                    
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                    
            with steps.start('Configuring the Monitor session on the BGW') as s:
                if not traffic_flag:
                    if dci_interface_list:
                        for item in dci_interface_list:
                            cfg = '''monitor session 1
                                     source interface {0} tx
                                     destination interface sup-eth0
                                     no shut'''.format(item)
                            
                            site1_hdl.configure(cfg)
                    else:
                        log.error('Unable to retrive the dci_interface list')
                        global_flag = 1
                        dci_flag = 1
                            
            with steps.start('Verifying the DSCP value after applying the QOS policy') as s:
                if not traffic_flag:
                    out = site1_hdl.execute('ethanalyzer local interface inband display-filter "ip.src==141.100.1.123" limit-captured-frames 10 detail | i DSCP')
                    pat = 'Differentiated\s+Services\s+Field\:\s+0x\d+\s+\(DSCP\:\s+([A-F0-9]+),\s+ECN'
                    af_23_count = 0
                    af_22_count = 0
                    for line in out.splitlines():
                        match = re.search(pat,line,re.I)
                        if match:
                            af_value = match.group(1)
                            if af_value == 'AF23':
                                af_23_count += 1
                                log.info('AF23 - Found - count is {0}'.format(af_23_count))
                            elif af_value == 'AF22':
                                af_22_count += 1
                                log.error('AF22 - Found -- Count is {0}'.format(af_22_count))
                                af_flag = 1
                            else:
                                log.error('Neither AF22 / AF23 is found')
                                af_flag  = 1
                    if af_23_count == 20:
                        log.info('The AF:23 is set for all the 10 sampled packets')
                    if af_23_count == 0:
                        log.error('The AF:23 is not set for all the 10 sampled packets')
                        af_flag = 1
                        

            with steps.start('Stopping the stream created for this test') as s:
                log.info(banner('Waiting for 20 seconds before Stopping the stream'))
                countDownTimer(20)
                b = tgn_hdl.traffic_control(action='stop', handle = trf_hdl, max_wait_timer=60)
                
            with steps.start('Deleteing the Traffic stream created for this tests') as s:
                if not stream_flag:
                    c = tgn_hdl.traffic_config(mode='remove',stream_id=vxlan_traffic_config['stream_id'], )
                    
            with steps.start('Restore Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error('Unable to retrive the DCI interface list..')
                    if stream_flag:
                        log.error('unable to start / stop the created stream. Refer Logs for details.')
                    if af_flag:
                        log.error('The AF Flag is not as expected. Refer logs for details.')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

# Verify policing the dci interface
class VxlanCloudSec_Func137(aetest.Testcase):

    """ Vxlan CloudSec - Verify policing the dci interface-FUNC137"""

    uid = 'VXLAN-CS-FUNC-137'

    @aetest.test
    def VxlanCloudSec_VerifyingRewriteQOSPriority_Func137(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test136:- Verify policing the dci interface'))
        
        
        global_flag = 0
        traffic_flag = 0
        restore_flag = 0
        dci_flag = 0
        af_flag = 0
        stream_flag = 0
        stats_success_stream = []
        stats_fail_stream = []
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            leaf_dict = scale_config_obj.getMultisiteDeviceDict('leaf')
            cloudsec_config_dict = configdict['cloudsec_config_dict']
            verify_cloudsec_obj = MyLib.my_cloudsec_lib.verifyTunnelEncryptionConfigs(log,cloudsec_config_dict,node_dict,alias_intf_mapping)
            
            cloudsec_peer_per_dut = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
            log.info('The value of cloudsec_peer_per_dut is : {0}'.format(cloudsec_peer_per_dut))
            dci_core = node_dict['DCI']
            log.info('the value of dci_core is: {0}'.format(dci_core))
            all_boxes = {}
            for i in [bgw_dict,leaf_dict]:
                all_boxes.update(i)
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Get CloudSec Current mode') as s:
                log.info('Get CloudSec Current mode')
                for dut in bgw_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    out = hdl.configure('sh tunnel-encryption info global  | xml')
                    s = BeautifulSoup(out)
                    try:
                        current_mode = s.find('policy_mode').string
                    except Exception:
                        log.error('Unable to find the Current Mode')
                        self.failed()
                    if re.search('Must',current_mode,re.I):
                        log.info(banner('The Tunnel-Encryption mode on Dut {0} is as expected'.format(dut)))
                    if re.search('Should', current_mode, re.I):
                        hdl.configure('tunnel-encryption must-secure-policy ')
                        
            with steps.start('Verify Tunnel-Encryption Session') as s:
                log.info('Verify CloudSec Session across dut: ')
                
                from_configfile = verify_cloudsec_obj.getCloudSecPeersFromConfigs()
                
                res = verify_cloudsec_obj.verifyCloudSecOnAllPeers(bgw_dict,from_configfile)
                if not res:
                    log.error('CloudSec Peer is not expected')
                    self.failed()

            with steps.start('Backup Configs - on Required boxes') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Creating Ixia Interfaces required for the test') as s:
                source_port = testscript.parameters['configdict']['TG'][TG]['TEST-021']['traffic_config_dict']['source']
                receiver_port = testscript.parameters['configdict']['TG'][TG]['TEST-021']['traffic_config_dict']['receivers']
                traffic_args=testscript.parameters['configdict']['TG'][TG]['TEST-021']['traffic_config_dict']['params']
                src_port = [port_handle_dict[x] for x in source_port]
                dst_port = [port_handle_dict[x] for x in receiver_port]
                
                log.info(banner('Creating an Host Interface on Ixia:'))
                intf_params = traffic_args['host_params']
                ixia_intf_conf = configureIxNetworkInterface(self,intf_params,tg_hdl = tgn_hdl,port_handle = port_handle_dict[receiver_port[0]])
                
                traffic_gen_object = MyLib.my_config_utils.IxiaRawTrafficGeneration(log,tgn_hdl,configdict,port_handle_dict)
                
                end_point_args = traffic_args['Traffic_End_points']
                log.info(banner('The value of end_point_args is : {0}'.format(end_point_args)))
                
                vxlan_traffic_config = traffic_gen_object.configureTrafficEndPoints(end_point_args,emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                log.info('The value of ixia_traffic_config is : {0}'.format(vxlan_traffic_config))
                
                if vxlan_traffic_config['status'] == 1:
                    log.info(banner('Traffic End points is configured as expected.. configuring the STream params'))
                    trf_hdl = vxlan_traffic_config['traffic_item']
                    traffic_stream_args  = traffic_args['StreamParameters']
                    vxlan_traffic_config1 = traffic_gen_object.configureTrafficStreamParameters(trf_hdl,traffic_stream_args)
                    if vxlan_traffic_config1['status'] == 1:
                        log.info(banner('Configuring the Ethernet Header -- Stack 1 '))
                        ethernet1_header_args = traffic_args['EthernetHeader1']
                        vxlan_traffic_config2 = traffic_gen_object.configureEthernetHeader(trf_hdl,ethernet1_header_args)
                        if vxlan_traffic_config2['status'] == 1:
                            log.info(banner('Configuring the Vlan Header -- Stack 2 '))
                            vlan_header_args = traffic_args['VlanHeader']
                            vxlan_traffic_config3 = traffic_gen_object.configureVlanHeader(trf_hdl,vlan_header_args)
                            if vxlan_traffic_config3['status'] == 1:
                                log.info(banner('Configuring the IPv4 Header with DSCP-- Stack 3'))
                                ip1_header_args = traffic_args['IPHeader1']
                                vxlan_traffic_config4 = traffic_gen_object.configureIPv4ProtocolHeader(trf_hdl,ip1_header_args)
                                
            with steps.start('Ping the host from Leaf2 to simulate ARP entry and EVPN Route Propogation') as s:
                for dut, hdl in node_dict['Site2']['LEAF'].items(): pass
                out = hdl.execute('ping 142.100.1.123 vrf V-001 count 20')
                pat = '(\d+)\s+packets transmitted.\s+(\d+)\s+packets received,\s+(\d+.\d+)%\s+packet loss'
                match = re.search(pat,out,re.M)
                if match:
                    pass_percent = match.group(3)
                    if float(pass_percent) < 10.0:
                        log.info('Ping to Host is successful as expected..')
                    else:
                        log.error('Ping to host is unsuccessful.')
                        self.failed()
                else:
                    log.error('Could not fetch the Ping results Failing the test cases.')
                    self.failed()
                    
            with steps.start('Staring the Newly Created Stream for this test') as s:
                log.info(banner('Waiting for 20 seconds before collecting the stats'))
                countDownTimer(20)
                b = tgn_hdl.traffic_control(action='run', handle = trf_hdl, max_wait_timer=60)
                if not b['status']:
                    stream_flag = 1
            
            with steps.start('Measuring the Traffic stats for this stream') as s:
                stream_dict = {}
                stream_dict.setdefault('TEST-021',{})
                stream_dict['TEST-021']['stream_id'] = vxlan_traffic_config['stream_id']
                
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,stream_dict,'TEST-021')
                
                if abs(res['tx']-res['rx']) < threshold:
                    log.info('Traffic flow is as expected..The value of tx and Rx is : {0} and {1}'.format(res['tx'],res['rx']))
                else:
                    log.error('Traffic Flow is not as expected. The value of tx and Rx is : {0} and {1}'.format(res['tx'],res['rx']))
                    traffic_flag = 1
                    global_flag = 1
                    
            with steps.start('Applying the QOS policy on the Nve Interface:') as s:
                if not traffic_flag:
                    cfg = '''class-map type qos match-all dscp-20
                             match dscp 20
                             policy-map type qos dscp-policy
                             class dscp-20
                             police cir 1 mbps bc 200 ms conform set-dscp-transmit 22 violate set-dscp-transmit 24
                             int nve 1
                             service-policy type qos input dscp-policy'''
                    
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    site1_hdl.configure(cfg)
                    
            with steps.start('Configuring the Monitor Session') as s:
                if not traffic_flag:
                    cfg = '''monitor session 1
                             source interface Ethernet1/13 tx
                             destination interface sup-eth0
                             no shut'''
                    site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                    site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                    
                    site1_hdl.configure(cfg)
                    
            with steps.start('Getting the DCI Links from BGW on Site 1') as s:
                site1_dut = list(node_dict['Site1']['BGW'].keys())[0]
                site1_hdl = list(node_dict['Site1']['BGW'].values())[0]
                
                dci_interface_list = []
                cfg = 'show nve multisite dci-links | xml'
                out = site1_hdl.configure(cfg)
                for line in out.splitlines():
                    log.info('line is --->{0}'.format(line))
                    if re.search('if-name', line, re.I):
                        s = BeautifulSoup(line)
                        try:
                            intf_name = s.find('if-name').string
                            dci_interface_list.append(intf_name)
                        except Exception as e:
                            log.info('The Exeception Occured is: {0}'.format(e))
                            log.error('Unable to get the Interface name')
                            dci_flag = 1
                log.info('dci_interface_list is -----> {0}'.format(dci_interface_list))
                    
            with steps.start('Configuring the Monitor session on the BGW') as s:
                if not traffic_flag:
                    if dci_interface_list:
                        for item in dci_interface_list:
                            cfg = '''monitor session 1
                                     source interface {0} tx
                                     destination interface sup-eth0
                                     no shut'''.format(item)
                            
                            site1_hdl.configure(cfg)
                    else:
                        log.error('Unable to retrive the dci_interface list')
                        global_flag = 1
                        dci_flag = 1
                            
            with steps.start('Verifying the DSCP value after applying the QOS policy') as s:
                if not traffic_flag:
                    out = site1_hdl.execute('ethanalyzer local interface inband display-filter "ip.src==141.100.1.123" limit-captured-frames 10 detail | i DSCP')
                    pat = 'Differentiated\s+Services\s+Field\:\s+0x\d+\s+\(DSCP\:\s+([A-F0-9]+),\s+ECN'
                    cs_count = 0
                    af_23_count = 0
                    for line in out.splitlines():
                        match = re.search(pat,line,re.I)
                        if match:
                            af_value = match.group(1)
                            if af_value == 'CS3':
                                cs_count += 1
                                log.info('AF23 - Found - count is {0}'.format(cs_count))
                            elif af_value == 'AF23':
                                af_22_count += 1
                                log.error('AF22 - Found -- Count is {0}'.format(af_23_count))
                                af_flag = 1
                            else:
                                log.error('Neither AF22 / AF23 is found')
                                af_flag  = 1
                    if cs_count > 16:
                        log.info('The CS3 is set for almost all the  10 sampled packets')
                    if af_23_count < 4:
                        log.error('The AF:23 is  set for some packets on the  10 sampled packets. no of packets set is : {0}'.format(af_23_count))
                    if af_23_count > 4:
                        log.error('The AF:23 is  set for more packets on the  10 sampled packets. no of packets set is : {0}'.format(af_23_count))
                        af_flag = 1

            with steps.start('Stopping the stream created for this test') as s:
                log.info(banner('Waiting for 20 seconds before Stopping the stream'))
                countDownTimer(20)
                b = tgn_hdl.traffic_control(action='stop', handle = trf_hdl, max_wait_timer=60)
                
            with steps.start('Deleteing the Traffic stream created for this tests') as s:
                if not stream_flag:
                    c = tgn_hdl.traffic_config(mode='remove',stream_id=vxlan_traffic_config['stream_id'], )
                    
            with steps.start('Restore Configs - on Required boxes') as s:
                log.info(banner('Restoring up configs on duts {0}'.format(list(all_boxes.keys()))))
                
                for dut in all_boxes.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if dci_flag:
                        log.error('Unable to retrive the DCI interface list..')
                    if stream_flag:
                        log.error('unable to start / stop the created stream. Refer Logs for details.')
                    if af_flag:
                        log.error('The AF Flag is not as expected. Refer logs for details.')
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   




class CommonCleanup(aetest.Testcase):
    
    """ VLan State Change on Both the DUTS """

    uid = 'VXLAN-L3-TRM-FUNC-001'

    @aetest.subsection
    def checkTopo(self):
        pass
        
        
class CommonCleanup(aetest.CommonCleanup):

    @aetest.subsection
    def disconnect(self):
        pass

