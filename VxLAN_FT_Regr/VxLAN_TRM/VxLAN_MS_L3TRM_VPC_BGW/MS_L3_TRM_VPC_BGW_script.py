#
#   Demo script file for setup bring

# python generic imports
import yaml
import logging
import argparse
import re
import time
from common_lib import utils
from common_lib.utils import *
import MyLib
from MyLib import my_utils
from MyLib import my_config_utils
from MyLib import my_trigger_utils
from MyLib import my_multisite_lib
from MyLib import my_cloudsec_lib

from common_lib import routing_utils
from common_lib.routing_utils import *
from pyats import aetest
from common_lib import config_bringup
from common_lib import parserutils_lib
# from common_lib import config_bringup_test
from common_lib import config_bringup_test_vijay
import yaml
import logging
from pyats.topology import loader
import argparse
import MyLib
from MyLib import my_utils
from MyLib import my_config_utils
from MyLib import my_trigger_utils
from MyLib import *

# pyATS imports

from unicon import Connection
from ats import aetest
from ats.log.utils import banner
from ats.datastructures.logic import Not, And, Or
from ats.easypy import run
from ats.log.utils import banner
from common_lib import bringup_lib
#import evpn_lib
from feature_lib.vxlan import vxlan_lib
from feature_lib.l3 import ospfv2_lib
from feature_lib.l3 import ospfv3_lib
from feature_lib.l3 import bgp_lib
from feature_lib.vxlan import evpn_lib
from common_lib import tcam_lib
from feature_lib.l3 import pim_lib
from feature_lib.l2 import vpc_lib
#import oam_lib
from pyats.async_ import pcall
from pyats.async_ import Pcall

import threading

#Ixia Libraries
from common_lib import ixia_lib_new
from common_lib.ixia_lib_new import *

# N39k Library imports
# from common_lib import config_bringup
# from common_lib import config_bringup_test
from common_lib import interface_lib
import ipaddress

from itertools import chain
from collections import OrderedDict
from itertools import permutations
import json
from bs4 import BeautifulSoup
from prettytable import PrettyTable
from _ast import alias


def expandTrafficItemList(a):
    skip_list = []
    pat = re.compile(r'([A-Za-z]+)(\d+)-[A-Za-z]+(\d+)', flags=re.I)
    if a:
        log.info(banner('The Value of a is : {0}'.format(a)))
        c = a.split(',')
        log.info(banner('The Value of c is : {0}'.format(c)))
        for items in c:
            b = pat.search(items)
            [skip_list.append(b.group(1) + str("{:03d}".format(i))) for i in range(int(b.group(2)), int(b.group(3))+1)]
            
    return skip_list

def countDownTimer(a):
    for i in range(a):
        log.info('seconds remaining is: {0}'.format(int(a-i)))
        time.sleep(1)
    return 1

def startStopIgmpReports(tg_hdl='',action=''):
    log.info('The value of tg_hdl is = %r', tg_hdl)
    log.info('The value of action  is = %r', action)
    igmp_status = tg_hdl.test_control(action = action)
    return(igmp_status)  


def parseScaleTGParams(log,args):
    arggrammar = {}
    arggrammar['no_of_intf'] = '-type int'
    arggrammar['no_of_vlans'] = '-type int'
    arggrammar['vlan_start'] = '-type int'
    arggrammar['ip_addr_start'] = '-type str'
    arggrammar['netmask'] = '-type str'
    arggrammar['ip_addr_step'] = '-type str'
    arggrammar['ipv4_network_step'] = '-type str'
    arggrammar['gateway'] = '-type str'
    arggrammar['mode'] = '-type str'
    arggrammar['vlan'] = '-type int'
    ns = parserutils_lib.argsToCommandOptions(args,arggrammar,log)
    return ns

def generateTrafficGenIntfConfigs(log,args):
    intf_list = []
    count = 1
    ns = parseScaleTGParams(log,args)
    no_of_intf_per_vlan = ns.no_of_intf / ns.no_of_vlans
    print('The value of no_of_intf_per_vlan is : {0}'.format(no_of_intf_per_vlan))
    ip_addr = ipaddress.IPv4Address(ns.ip_addr_start)
    gw = ipaddress.IPv4Address(ns.gateway)
    v = ns.vlan_start
    ip_addr_step = '0.0.0.1'
    gw_addr_step = '0.0.0.0'
    vlan_step = 0
    for i in range(0,ns.no_of_intf):
        if(count <= int(no_of_intf_per_vlan)): 
            if(count == 1):
                a = "".join('-mode {0} -connected_count {1} -intf_ip_addr {2} -intf_ip_addr_step {3} -netmask {4} -gateway {5} -gateway_step {6} -vlan {7} -vlan_id {8} -vlan_id_step {9}'.format(ns.mode,int(no_of_intf_per_vlan),ip_addr,ip_addr_step,ns.netmask,gw,gw_addr_step,ns.vlan,v,vlan_step))
                intf_list.append(a)
            ip_addr = ipaddress.IPv4Address(ip_addr) + int(ipaddress.IPv4Address(ns.ip_addr_step))
            count = count+1
        if(count > no_of_intf_per_vlan):
            ns.ip_addr_start = ipaddress.IPv4Address(ns.ip_addr_start)+int(ipaddress.IPv4Address(ns.ipv4_network_step))
            ip_addr = ns.ip_addr_start
            gw = ipaddress.IPv4Address(gw) + int(ipaddress.IPv4Address(ns.ipv4_network_step))
            v = v + 1
            count = 1
            
    return intf_list

def verifyProcessRestart(dut, p_name):
    
    log.info('Inside verifyProcessRestart .....')
#     unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
#     unicon_state.add_state_pattern(pattern_list = "r'bash-*$'")
    
    dut.configure("feature bash-shell")
    dut.configure('system no hap-reset')
    
    # Get the PID of the process before killing it
    pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    pid_regex = re.search("PID = (\\d+)",pid_data,re.I)
    if pid_regex is not 0:
        pid = pid_regex.group(1)
    
    # Kill the process in bash prompt
    dut.execute("run bash", allow_state_change = "True")
    dut.execute("sudo su", allow_state_change = "True")
    dut.execute("kill -9 "+str(pid), allow_state_change = "True")
    dut.execute("exit", allow_state_change = "True")
    dut.execute("exit", allow_state_change = "True")
    
#     unicon_state.restore_state_pattern()
#     unicon_state = ""
    
    countDownTimer(30)
    
    # Get the PID of the process after killing it
    post_kill_pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    post_kill_pid_regex = re.search("PID = (\\d+)",post_kill_pid_data,re.I)
    if post_kill_pid_regex is not 0:
        post_kill_pid = post_kill_pid_regex.group(1)
    
    # Check if pre-kill PID and post-kill PID are different
    if pid != post_kill_pid:
        return 1
    else:
        return 0

def verifyProcessRestartWithFlushRoutes(dut, p_name,**kwargs):
    
    log.info('Inside verifyProcessRestart wtih Flush Route .....')
#     unicon_state = unicon.statemachine.statemachine.State(name='enable', pattern=r'^.*|%N#')
#     unicon_state.add_state_pattern(pattern_list = "r'bash-*$'")
    
    dut.configure("feature bash-shell")
    dut.configure('system no hap-reset')
    
    if kwargs:
        process_id = kwargs['process_id']
    # Get the PID of the process before restarting it
    pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    pid_regex = re.search("PID = (\\d+)",pid_data,re.I)
    if pid_regex is not 0:
        pid = pid_regex.group(1)
    
    if p_name == 'ospf' and kwargs:
        cfg = ''' router {0} {1}
                  flush-routes
              '''.format(p_name,process_id)
        dut.configure(cfg)
        dut.configure('restart {0} {1}'.format(p_name,process_id))
    if p_name == 'igmp':
        dut.configure('ip igmp flush-routes')
        dut.configure('restart {0}'.format(p_name))
    if p_name == 'pim':
        dut.configure('ip pim flush-routes')
        dut.configure('restart {0}'.format(p_name))
    if p_name == 'bgp' and kwargs:
        cfg = ''' router {0} {1}
                  flush-routes
              '''.format(p_name,process_id)
        dut.configure(cfg)
        dut.configure('restart {0} {1}'.format(p_name,process_id))
    if p_name == 'ngmvpn':
        dut.configure('restart {0}'.format(p_name))

    countDownTimer(30)
    # Get the PID of the process after restarting it
    post_kill_pid_data = dut.execute("show system internal sysmgr service name " + str(p_name) + " | i i PID")
    post_kill_pid_regex = re.search("PID = (\\d+)",post_kill_pid_data,re.I)
    if post_kill_pid_regex is not 0:
        post_kill_pid = post_kill_pid_regex.group(1)

    # Check if pre-kill PID and post-kill PID are different
    if pid != post_kill_pid:
        return 1
    else:
        return 0


class CommonSetup(aetest.CommonSetup):
    

    '''
    Setup :
        **********

    '''

    uid = 'common_setup'
    @aetest.subsection
    def initialize_logging(self, testscript):
        """ Common setup section to initialize logging for script"""

        log = logging.getLogger(__name__)
        log.setLevel(logging.DEBUG)
        testscript.parameters['log'] = log


    @aetest.subsection
    def check_topology(self, testbed, testscript,log,traffic_threshold='', tgn_connect = '', **kwargs):
        """ common setup subsection: connecting devices """

        testscript.parameters['traffic_threshold'] = traffic_threshold
        testscript.parameters['tgn_connect'] = tgn_connect
 
        log.info(banner('The value of kwargs is : {0}'.format(kwargs)))
        testscript.parameters['config_interface'] = kwargs['config_interface']
        testscript.parameters['config_ospf'] = kwargs['config_ospf']
        testscript.parameters['config_ospfv3'] = kwargs['config_ospfv3']
        testscript.parameters['config_bgp'] = kwargs['config_bgp']
        testscript.parameters['config_keepalive_vrf'] = kwargs['config_keepalive_vrf']
        testscript.parameters['config_vpc'] = kwargs['config_vpc']
        testscript.parameters['config_pim'] = kwargs['config_pim']
        testscript.parameters['config_vxlan_global'] = kwargs['config_vxlan_global']
        testscript.parameters['config_bgp_global'] = kwargs['config_bgp_global']
        testscript.parameters['config_vlan'] = kwargs['config_vlan']
        testscript.parameters['config_vrf'] = kwargs['config_vrf']
        testscript.parameters['config_svi'] = kwargs['config_svi']
        testscript.parameters['config_evpn'] = kwargs['config_evpn']
        testscript.parameters['config_nve_global'] = kwargs['config_nve_global'] 
        testscript.parameters['config_nve_l2vni'] = kwargs['config_nve_l2vni']
        testscript.parameters['config_nve_l3vni'] = kwargs['config_nve_l3vni']
        testscript.parameters['config_sub_intf'] = kwargs['config_sub_intf']
        testscript.parameters['config_loopback_intf'] = kwargs['config_loopback_intf']
        testscript.parameters['config_ospf_router_id'] = kwargs['config_ospf_router_id']
        testscript.parameters['config_prefix_list'] = kwargs['config_prefix_list']
        testscript.parameters['config_route_map'] = kwargs['config_route_map']
        testscript.parameters['config_multisite'] = kwargs['config_multisite']
        testscript.parameters['config_tunnel_encryption'] = kwargs['config_tunnel_encryption']
        testscript.parameters['config_tgn_conn'] = kwargs['config_tgn_conn']
        testscript.parameters['config_tgn_interface'] = kwargs['config_tgn_interface']
                                         
        parser = argparse.ArgumentParser()
        parser.add_argument('--config-file',dest='config_file',type=str)
        args = parser.parse_args()
        config_file = args.config_file
        fp = open(config_file)
        configdict=yaml.safe_load(fp)
        fp.close()        
        fail_result=0
        log.info('Getting testbed objects from the testbed file')
        testbed_obj = testbed

        # Way to get password and login from Testbed file
        passw = testbed_obj.passwords['tacacs']
        login = testbed_obj.tacacs['username']

        log.info(banner('The Devices in Testbed File are : \n {0}'.format("\n".join(list(testbed_obj.devices.keys())))))

        duts = list(filter(lambda x: 'TG' not in x, list(testbed_obj.devices.aliases)))
        TGs = list(filter(lambda x: 'uut' not in x , list (testbed_obj.devices.aliases)))

        log.info('{0} are the available duts in the testbed'.format(duts))
        log.info('{0} are the available TGs in the testbed'.format(TGs))   
                
        duts.sort()
        TGs.sort()

        # As per Testbed File following links are present.
        
        alias_intf_mapping = {}
        for dut in list(testbed_obj.devices.keys()):
            a = testbed_obj.devices[dut].alias
            log.info(banner('Dut Alias is  : {0}'.format(a)))
            alias_intf_mapping[a] = {}
            if 'ixia' not in dut:
                log.info(banner('DUT is {0}'.format(dut)))
            else:
                log.info(banner('TRAFFIC GENERATOR is: {0}'.format(dut)))
            intf = [x for x in testbed_obj.devices[dut].interfaces.keys()]
            alias = [testbed_obj.devices[dut].interfaces[x].alias for x in testbed_obj.devices[dut].interfaces.keys()]
            res = list(zip(intf,alias))
            alias_intf_mapping.update(dict(zip(alias,intf)))
            alias_intf_mapping[a].update(dict(zip(alias,intf)))
            alias_intf_mapping.setdefault('all_intf',{})
            alias_intf_mapping['all_intf'].update(dict(zip(alias,intf)))
            log.info(banner('The interfaces and alias on dut {1} are \n {0}'.format("\n".join(["->".join(x) for x in res]),dut)))
            
            
        log.info('The value of alias_intf_mapping is {0}'.format(yaml.dump(alias_intf_mapping)))

        # Way to take variable to other section
        testscript.parameters['testbed_obj'] = testbed_obj
        testscript.parameters['configdict'] = configdict
        testscript.parameters['fail_result'] = fail_result
        testscript.parameters['alias_intf_mapping'] = alias_intf_mapping
       
    @aetest.subsection
    def configBringUp(self,testscript,log,steps):
        
        testbed_obj = testscript.parameters['testbed_obj']

        # DUTs required to test this feature 
        dutList_config_file = list(testscript.parameters['configdict']['dut'].keys())
        log.info('{0} are the duts required for EVPN tests'.format(dutList_config_file))
        
        # TGNs required for this CFD
        TGList_config_file = list(testscript.parameters['configdict']['TG'].keys())
        log.info('{0} are the TGNs required for EVPN tests'.format(TGList_config_file))
        
        # Create obj for each node from config file
        dutList_obj_config_file = []
        for dut_config_file in dutList_config_file:
            dutList_obj_config_file.append(testscript.parameters['testbed_obj'].devices[dut_config_file])
            
        # declaring vtep list
        node_dict = {}
        
        for node in list(testbed_obj.devices.keys()):
            log.info('The Value of node is : {0}'.format(node))
            log.info('The value of node.type is : {0}'.format(testbed_obj.devices[node].type))
            if re.search('Site1',testbed_obj.devices[node].type,re.IGNORECASE):
                node_dict.setdefault('Site1',{})
                node_dict.setdefault('all_bgws',{})
                if re.search('BGW',testbed_obj.devices[node].type,re.IGNORECASE):
                    if re.search('VPC',testbed_obj.devices[node].type,re.IGNORECASE):
                        node_dict['Site1'].setdefault('VPC_BGW',{})
                        node_dict['Site1']['VPC_BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    else:
                        node_dict['Site1'].setdefault('BGW',{})
                        node_dict['Site1']['BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    node_dict['all_bgws'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('SPINE',testbed_obj.devices[node].type,re.IGNORECASE):
                    log.info('Inside the Site1: Spine re.search block()')
                    node_dict['Site1'].setdefault('SPINE',{})
                    node_dict['Site1']['SPINE'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('LEAF',testbed_obj.devices[node].type,re.IGNORECASE):
                    log.info('Inside the Site1: leaf re.search block()')
                    node_dict['Site1'].setdefault('LEAF',{})
                    node_dict['Site1']['LEAF'][testbed_obj.devices[node].alias] = testbed_obj.devices[node] 
                if re.search('ACCESS_SWITCH',testbed_obj.devices[node].type,re.IGNORECASE):
                    log.info('Inside the Site1: access_switch re.search block()')
                    node_dict['Site1'].setdefault('ACCESS_SWITCH',{})
                    node_dict['Site1']['ACCESS_SWITCH'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]  
            elif re.search('Site2',testbed_obj.devices[node].type,re.IGNORECASE):
                node_dict.setdefault('Site2',{})
                node_dict.setdefault('all_bgws',{})
                if re.search('BGW',testbed_obj.devices[node].type,re.IGNORECASE):
                    node_dict['Site2'].setdefault('BGW',{})
                    node_dict['Site2']['BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    node_dict['all_bgws'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('SPINE',testbed_obj.devices[node].type,re.IGNORECASE):
                    node_dict['Site2'].setdefault('SPINE',{})
                    node_dict['Site2']['SPINE'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('LEAF',testbed_obj.devices[node].type,re.IGNORECASE):
                    node_dict['Site2'].setdefault('LEAF',{})
                    node_dict['Site2']['LEAF'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('Site3',testbed_obj.devices[node].type,re.IGNORECASE):
                node_dict.setdefault('Site3',{})
                node_dict.setdefault('all_bgws',{})
                if re.search('BGW',testbed_obj.devices[node].type,re.IGNORECASE):
                    node_dict['Site3'].setdefault('BGW',{})
                    node_dict['Site3']['BGW'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                    node_dict['all_bgws'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('SPINE',testbed_obj.devices[node].type,re.IGNORECASE):
                    node_dict['Site3'].setdefault('SPINE',{})
                    node_dict['Site3']['SPINE'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
                if re.search('LEAF',testbed_obj.devices[node].type,re.IGNORECASE):
                    node_dict['Site3'].setdefault('LEAF',{})
                    node_dict['Site3']['LEAF'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('DCI',testbed_obj.devices[node].type,re.IGNORECASE):
                node_dict.setdefault('DCI',{})
                node_dict['DCI'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('External',testbed_obj.devices[node].type,re.IGNORECASE):
                node_dict.setdefault('External_RP',{})
                node_dict['External_RP'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            elif re.search('ixia',testbed_obj.devices[node].type,re.IGNORECASE):
                node_dict.setdefault('trf_gen',{})
                node_dict['trf_gen'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]
            node_dict.setdefault('all_dut',{})
            node_dict['all_dut'][testbed_obj.devices[node].alias] = testbed_obj.devices[node]

        log.info(banner('Value of Node dict is : {0}'.format(node_dict)))
#         log.info('Value of Node dict is : {0}'.format(node_dict))
#         log.info(banner('The Value of node_dict - Readability is '))
#         
#         log.info(json.dumps(node_dict,sort_keys=True,indent=4))
                
        for dut in node_dict['all_dut']:
            if not re.search(r'TG',dut,re.I):
                node_dict['all_dut'][dut].connect()
        
        testscript.parameters['node_dict'] = node_dict
        testscript.parameters['TGList'] = TGList_config_file

    @aetest.subsection
    def configureInterfaces(self,testscript,log):
        
        config_interface = testscript.parameters['config_interface']
        
        if config_interface:
            #interface config dict 
            config_dict = testscript.parameters['configdict']
            node_dict = testscript.parameters['node_dict']
            testbed_obj = testscript.parameters['testbed_obj']
            
            intf_config_dict = testscript.parameters['configdict']['interface_config_dict']
    
            log.info(banner('The value of interface_config_dict is {0} '.format(intf_config_dict)))
            
            log.info(banner('The value of node_dict is {0} '.format(node_dict)))
            
            intf_obj = config_bringup_test_vijay.configSetup(config_dict,testbed_obj,log)
            #intf_obj = config_bringup_test.configSetup(config_dict,testbed_obj,log)
            
            if not intf_obj:
                self.failed()
        else:
            pass
        
    @aetest.subsection
    def configureUnderlayOSPF(self,testscript,log):

        config_ospf = testscript.parameters['config_ospf']
        if config_ospf:
            #ospf_config_dict
            ospf_config_dict = testscript.parameters['configdict']['ospfv2_config_dict']
            node_dict = testscript.parameters['node_dict']
            
            obj_ospf=ospfv2_lib.configOspfv2(node_dict['all_dut'],ospf_config_dict,log)
            
            if not obj_ospf:
                self.failed()
        else:
            pass

    @aetest.subsection
    def configureUnderlayOSPFv3(self,testscript,log):
        
        config_ospfv3 = testscript.parameters['config_ospfv3']
        
        if config_ospfv3:
            #ospf_config_dict
            ospfv3_config_dict = testscript.parameters['configdict']['ospfv3_config_dict']
            node_dict = testscript.parameters['node_dict']
            
            obj_ospf=ospfv3_lib.configOspfv3(node_dict['all_dut'],ospfv3_config_dict,log)
            
            if not obj_ospf:
                self.failed()
        else:
            pass
            
            
    @aetest.subsection       
    def configureBGPNeighbors(self,testscript,log):

        config_bgp = testscript.parameters['config_bgp']
        
        if config_bgp:
        
            #BGP_config_dict 
            bgp_config_dict = testscript.parameters['configdict']['bgp_config_dict']
    
            node_dict = testscript.parameters['node_dict']
            
            for dut in bgp_config_dict.keys():
                obj_bgp=bgp_lib.configBgp(bgp_config_dict,node_dict['all_dut'],log)
                if not obj_bgp.Nodes(dut):
                    self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureKeepAliveVRF(self,testscript,log):     
        
        config_keepalive_vrf = testscript.parameters['config_keepalive_vrf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_keepalive_vrf:
            
            for node in config_dict['vrf_config_dict'].keys():
                hdl = node_dict['all_dut'][node]
                cfg = 'vrf context {0}'.format(config_dict['vrf_config_dict'][node])
                log.info('The value of cfg is : {0}'.format(cfg))
                hdl.configure(cfg)
        else:
            pass
        
    @aetest.subsection       
    def configureVPCSwitches(self,testscript,log):
        
        config_vpc = testscript.parameters['config_vpc']
        
        if config_vpc:
            node_dict = testscript.parameters['node_dict']
            config_dict = testscript.parameters['configdict']
            for items in node_dict.keys():
                if re.search('Site',items):
                    log.info('The value of item is : {0}'.format(items))
                    for sub_items in node_dict[items].keys():
                        if re.search('VPC',sub_items, re.IGNORECASE):
                            vpc_vteps = node_dict[items][sub_items].keys()
                            log.info('The value of vpc_vteps is: {0}'.format(vpc_vteps))
                    
            
            for dut in vpc_vteps:
                hdl = node_dict['all_dut'][dut]
                d = config_bringup_test_vijay.setupConfigVpc(hdl,dut,log,config_dict)
                #d = config_bringup_test.setupConfigVpc(hdl,dut,log,config_dict)
        else:
            pass
        
    @aetest.subsection       
    def configurePIMNeighbors(self,testscript,log):

        config_pim = testscript.parameters['config_pim']
        
        if config_pim:
            intf_config_dict = testscript.parameters['configdict']['interface_config_dict']
      
            pim_config_dict = testscript.parameters['configdict']['pim_config_dict']
    
            node_dict = testscript.parameters['node_dict']
            
            for dut in pim_config_dict.keys():
                obj_pim = pim_lib.configPim(intf_config_dict,pim_config_dict,node_dict['all_dut'],log,'-dut {0}'.format(dut))
                
            if  obj_pim.result=='fail':
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureGlobalVxlan(self,testscript,log):    
        
        config_vxlan_global = testscript.parameters['config_vxlan_global']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_vxlan_global:
            #SCALE_Config_dict
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
            log.info(banner('The value of vtep_dict is {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureGlobalVxlanParams(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureGlobalBGP(self,testscript,log):    
        
        config_bgp_global = testscript.parameters['config_bgp_global']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_bgp_global:
            #SCALE_Config_dict
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            vtep_dict.update(node_dict['External_RP'])

            log.info(banner('The value of vtep_dict is {0}'.format(vtep_dict)))
            
            res = scale_config_obj.configureGlobalBGPParams(vtep_dict)
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection       
    def configureScaleVlan(self,testscript,log):
        
        config_vlan = testscript.parameters['config_vlan']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_vlan:
            #SCALE_Config_dict
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            for items in node_dict.keys():
                if re.search('Site', items, re.IGNORECASE):
                    for sub_items in node_dict[items].keys():
                        if re.search('ACCESS', sub_items, re.IGNORECASE):
                            device_dict.update(node_dict[items][sub_items])
                if re.search('External', items, re.IGNORECASE):
                    device_dict.update(node_dict[items])
                            
            log.info('The value of device_dict is: {0}'.format(device_dict))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            
            res = scale_config_obj.configScaleVlans(device_dict)
    
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection  
    def configureScaleVRF(self,testscript,log):
        
        config_vrf = testscript.parameters['config_vrf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_vrf:
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            
            device_dict.update(node_dict['External_RP'])
            # device_dict = {}
            # for dut in ['all_vtep','external_rp','core']:
            #     device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            
            res = scale_config_obj.configScaleVRFs(device_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection       
    def configureScaleSVI(self,testscript,log):     
        
        config_svi = testscript.parameters['config_svi']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_svi:
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            device_dict.update(node_dict['External_RP'])
#             device_dict = {}
#             for dut in ['all_vtep','core']:
#             for dut in ['core']:
#                 device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            
            res = scale_config_obj.configScaleSVIs(device_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureScaleEvpn(self,testscript,log):  
        
        config_evpn = testscript.parameters['config_evpn']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
                
        if config_evpn:
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configScaleEVPN(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureNveInterfaceGlobals(self,testscript,log):  
        
        config_nve_global = testscript.parameters['config_nve_global']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']        
        
        if config_nve_global:
            
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureNveGlobal(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureL2VNIOnNveInterface(self,testscript,log):     
        
        config_nve_l2vni = testscript.parameters['config_nve_l2vni']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']  
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_nve_l2vni:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureL2VNIOnNve(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def configureL3VNIOnNveInterface(self,testscript,log):     
        
        config_nve_l3vni = testscript.parameters['config_nve_l3vni']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_nve_l3vni:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureL3VNIOnNve(vtep_dict)
            
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureSubInterfaces(self,testscript,log):     
        
        config_sub_intf = testscript.parameters['config_sub_intf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_sub_intf:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            device_dict = {}
            '''
            for dut in ['vpc_vtep','external_rp','core']:
                device_dict.update(scale_config_obj.getDeviceDict(dut))

            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
            '''
            for dut in config_dict['scale_config_dict'].keys():
                for items in config_dict['scale_config_dict'][dut].keys():
                    if re.search('interface', items, re.IGNORECASE):
                        for intf in config_dict['scale_config_dict'][dut][items].keys():
                            if re.search('sub',intf,re.IGNORECASE):
                                device_dict.update({dut:node_dict['all_dut'][dut]})
                    
            log.info(banner('The value of device_dict_dict is : {0}'.format(device_dict)))
                
            res = scale_config_obj.configureL3SubInterface(device_dict)
             
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureLoopbackInterfaces(self,testscript,log):     
        
        config_loopback_intf = testscript.parameters['config_loopback_intf']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_loopback_intf:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            external_rp_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')

            log.info(banner('The value of external_rp_dict is : {0}'.format(external_rp_dict)))
    
            res = scale_config_obj.configureLoopbackInterface(external_rp_dict)
             
            if not res:
                self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureMultisiteConfigs(self,testscript,log):     
        
        config_multisite = testscript.parameters['config_multisite']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_multisite:
        
            multisite_config_dict = config_dict['multisite_config_dict']
    
            for dut in multisite_config_dict.keys():
                obj_ms=MyLib.my_multisite_lib.configMultisite(multisite_config_dict,node_dict,alias_intf_mapping,log)
                if not obj_ms.Nodes(dut):
                    self.failed()
        else:
            pass

        
    @aetest.subsection                     
    def configureVRFOspfRouterID(self,testscript,log):     
        
        config_ospf_router_id = testscript.parameters['config_ospf_router_id']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_ospf_router_id:
        
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            vtep_dict = scale_config_obj.getDeviceDict('vpc_vtep')

            log.info(banner('The value of external_rp_dict is : {0}'.format(vtep_dict)))
    
            res = scale_config_obj.configureOspfRouterID(vtep_dict)
             
            if not res:
                self.failed()
        else:
            pass


    @aetest.subsection                     
    def configureGlobalPrefixLists(self,testscript,log):     
        
        config_prefix_list = testscript.parameters['config_prefix_list']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_prefix_list:
            
            device_dict = {}
            prefix_list_config_dict = config_dict['prefix_list_config_dict']
            for prefix_dut in prefix_list_config_dict.keys():
                for node_dut in node_dict['all_dut'].keys():
                    if node_dut == prefix_dut:
                        device_dict.update({prefix_dut:node_dict['all_dut'][prefix_dut]})

            log.info('The value of device_dict is : {0}'.format(device_dict))
            res = routing_utils.configPrefixLists(log,device_dict,prefix_list_config_dict)
                

    @aetest.subsection                     
    def configureGlobalRouteMaps(self,testscript,log):     
        
        config_route_map = testscript.parameters['config_route_map']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        if config_route_map:
            
            scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            temp_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            dci_dict= node_dict['DCI']
            log.info('The value of dci_dict is : {0}'.format(dci_dict))
            temp_dict.update(dci_dict)
            route_map_config_dict = config_dict['route_map_config_dict']
            res = routing_utils.configRouteMaps(log,temp_dict,route_map_config_dict)
                
            
            # scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
            # vtep_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            # 
            # log.info(banner('The value of vtep_dict is : {0}'.format(vtep_dict)))
            # 
            # res = scale_config_obj.configureRouteMap(vtep_dict)
            #  
            # if not res:
            #     self.failed()
        else:
            pass    
        



    @aetest.subsection                     
    def configureMultisiteConfigs(self,testscript,log):     
        
        config_multisite = testscript.parameters['config_multisite']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_multisite:
        
            multisite_config_dict = config_dict['multisite_config_dict']
    
            for dut in multisite_config_dict.keys():
                obj_ms=MyLib.my_multisite_lib.configMultisite(multisite_config_dict,node_dict,alias_intf_mapping,log)
                if not obj_ms.Nodes(dut):
                    self.failed()
        else:
            pass

    @aetest.subsection                     
    def configureTunnelEncryptionConfigs(self,testscript,log):     
        
        config_tun_encr = testscript.parameters['config_tunnel_encryption']
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping'] 
        
        if config_tun_encr:
        
            cloudsec_config_dict = config_dict['cloudsec_config_dict']
    
            for dut in cloudsec_config_dict.keys():
                obj_cs=MyLib.my_cloudsec_lib.configTunnelEncryption(cloudsec_config_dict,node_dict,alias_intf_mapping,log)
                if not obj_cs.Nodes(dut):
                    self.failed()
        else:
            pass
        
    @aetest.subsection                     
    def connectionToTrafficGenerator(self,testscript,log): 


        config_tgn_conn =  testscript.parameters['config_tgn_conn']
        
        if config_tgn_conn:
            # Connect and confiure TG
    
            log.info('Connecting and configuring TG as per config dict...')
            # Get physical interface from logical interface of config file for TG
             
            testbed_obj = testscript.parameters['testbed_obj']
     
            TGList_config_file = testscript.parameters['TGList']
            ix_port_list = []
            ix_port_list_alias = []
            tgn_port_dut_mapping={}
            for TG in TGList_config_file:
                d = testscript.parameters['testbed_obj'].devices[TG]
                log.info('The value of d is : {0}'.format(d))
                TGIntList = testscript.parameters['configdict']['TG'][TG]['global']['ports'].keys()
                for port in TGIntList:
                    a = d.interfaces[port].alias
                    b = re.search('(uut[\d]+)',a)
                    if b:
                        dut = b.group(1)
                        tgn_port_dut_mapping[port] = dut
                
                
                for TGInt in TGIntList:
                    log.info('The value of TGint is : {0}'.format(TGInt))
                    ix_port_list.append(d.interfaces[TGInt].name)
                    ix_port_list_alias.append(d.interfaces[TGInt].alias)
                    # Connect to TG
                ix_port_list.sort(key=lambda x: '{0:0>8}'.format(x).lower())
                log.info('The value of ix_port_list is : {0}'.format(ix_port_list))
                log.info('The value of ix_port_list_alias is : {0}'.format(ix_port_list_alias))
                ixia_connect = connectToIxNetwork(self, tg_hdl = d, port_list = ix_port_list)
                     
                # Get port handles
                port_handle_list = []
                for port_handle in ixia_connect['vport_list'].split():
                    port_handle_list.append(port_handle)
                 
                port_handle_list.sort(key=lambda x: '{0:0>8}'.format(x).lower())
                 
                port_handle_dict = dict(zip(ix_port_list,port_handle_list))

                for tgPort,ixPort in zip(ix_port_list,port_handle_list):
                    # Updating the IXIA port type
                    result = d.interface_config(port_handle = ixPort, phy_mode=d.interfaces[tgPort].type)
                    if result.status:
                        log.info("Changed the interface phymode successfully")
                    else:
                        log.info("Changed the interface phymode failed")

                log.info("Port handles are {0}".format(port_handle_list))
                log.info('The Value of port_handle_dict is: {0}'.format(port_handle_dict))
                testscript.parameters['port_handle_dict'] = port_handle_dict
                log.info('The value of tgn_port_dut_mapping is : {0}'.format(tgn_port_dut_mapping))
                testscript.parameters['tgn_port_dut_mapping'] = tgn_port_dut_mapping
                
    @aetest.subsection      
    def configuringInterfacesOnTrafficGenerator(self,testscript,log):
        
        config_tgn_interface = testscript.parameters['config_tgn_interface']

        if config_tgn_interface:
            tg_interface_hdl_dict = {}
            port_handle_dict = testscript.parameters['port_handle_dict']
     
                #interface_handle_list = []
            TGList_config_file = testscript.parameters['TGList']
            for TG in TGList_config_file:
                tg_interface_hdl_dict[TG] = {}
                d = testscript.parameters['testbed_obj'].devices[TG]
                skip_traffic_items = testscript.parameters['configdict']['TG'][TG]['skip_traffic_items']
                log.info('Type of skip_traffic_items is : {0}'.format(type(skip_traffic_items)))
                if skip_traffic_items:
                    traffic_item_skip_list = expandTrafficItemList(testscript.parameters['configdict']['TG'][TG]['skip_traffic_items'])
                    log.info('The value of traffic_item_skip_list is : {0}'.format(traffic_item_skip_list))
                else:
                    traffic_item_skip_list = ''
                log.info('The value of traffic_item_skip_list is : {0}'.format(traffic_item_skip_list))       
                configured_stream  = []
                skipped_stream = []     
                for trf_stream in testscript.parameters['configdict']['TG'][TG]:
                    if(re.search('TRF',trf_stream)):
                        if trf_stream not in traffic_item_skip_list:
                            configured_stream.append(trf_stream)
                            tg_interface_hdl_dict[TG][trf_stream] = {}
                            TGIntList = testscript.parameters['configdict']['TG'][TG][trf_stream]['tg_interface_config_dict'].keys()
                            for TGInt in TGIntList:
                                log.info('The value of TGInt is : {0}'.format(TGInt))
                                ixia_intf_ip_list=[]
                                tg_interface_hdl_dict[TG][trf_stream][TGInt] = {}
                                intf_args = generateTrafficGenIntfConfigs(log,testscript.parameters['configdict']['TG'][TG][trf_stream]['tg_interface_config_dict'][TGInt]) 
                                log.info('The value of intf_args is : {0}'.format(intf_args))
                                for j,k  in enumerate(intf_args):
                                    a = intf_args[j]
                                    ixia_interface_config = configureMultiIxNetworkInterface(self,a,tg_hdl=d,port_handle=port_handle_dict[TGInt])
                                    log.info('the value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                                    for b in ixia_interface_config:
                                        ixia_intf_ip_list.append(b)
                                        tg_interface_hdl_dict[TG][trf_stream][TGInt][b]={}
                                        tg_interface_hdl_dict[TG][trf_stream][TGInt][b]['handle']=ixia_interface_config[b]
                                    tg_interface_hdl_dict[TG][trf_stream][TGInt]['ip_list']=ixia_intf_ip_list
                        else:
                            skipped_stream.append(trf_stream)

                    elif(re.search('RAW',trf_stream)):
                        if trf_stream not in traffic_item_skip_list:
                            configured_stream.append(trf_stream)
                        else:
                            skipped_stream.append(trf_stream)
            
            log.info(banner('The following traffic stream  %s is skipped from configuring ... ' % skipped_stream))
                        
            c = yaml.dump(tg_interface_hdl_dict)
            log.info('The value of c is : {0}'.format(c))
            testscript.parameters['tg_interface_hdl_dict'] = tg_interface_hdl_dict
            testscript.parameters['configured_stream'] = configured_stream
            log.info(banner('The value of configured_stream is : {0}'.format(configured_stream)))


    
    @aetest.subsection                     
    def verifyConfiguationsBeforeStartOfTest(self,testscript,log,steps):
        config_dict = testscript.parameters['configdict']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        
        scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
        vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
                
        verify_obj = MyLib.my_config_utils.VerifyConfigs(log,config_dict,node_dict,alias_intf_mapping)
        '''
        with steps.start('Verify OSPFv2 Neighborship on all duts') as s:
            log.info('Verifying the OSPFv2 Neighborship on all duts ......')
            res = verify_obj.verifyOSPFv4Neighorship()
            if not res:
                self.failed()


        log.info('Waiting for 30 seconds before checking the BGP Neighborship')
        countDownTimer(30)
        with steps.start('Verify BGP L2EVPN Neighborship on all duts') as s:
            log.info('Verify BGP L2EVPN Neighborship on all duts ......')
            res = verify_obj.verifyBGPL2EVPNNeighbor()
            if not res:
                self.failed()

        with steps.start('Verify BGP L2EVPN Neighborship on all duts') as s:
            log.info('Verify BGP mVPN Neighborship on all duts ......')
            res = verify_obj.verifyBGPL2EVPNNeighbor()
            if not res:
                self.failed()
                        
        with steps.start('Verify L2 and L3 VNI Status on all VTEPS') as s:
            log.info('Verifying L2 and L3 VNI status on all VTEPs ......')
            res = verify_obj.verifyVNIStatus(vtep_dict)
            if not res:
                self.failed()

        with steps.start('Verify Nve Peers in VTEPs') as s:
            log.info('VVerify Nve Peers in VTEPs ......')
            res = verify_obj.verifyNVEStatus(vtep_dict)
            if not res:
                self.failed()  
        
        log.info(banner('Waiting for 30 seconds before Configuring the Traffic ... {0}'.format(countDownTimer(30))))
    
        '''
    @aetest.subsection 
    def configureIGMPReports(self,testscript,log):
        
#         '''
        TGList_config_file = testscript.parameters['TGList']
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict']
        config_dict = testscript.parameters['configdict']
        configured_stream = testscript.parameters['configured_stream'] 
        
        log.info(banner('The value of traffic_interface_handle_dict is : {0}'.format(yaml.dump(tg_interface_hdl_dict))))

        for TG in TGList_config_file:
            d = testscript.parameters['testbed_obj'].devices[TG]
            for trf_stream in configured_stream:
                if(re.search('TRF',trf_stream)):
                    log.info('The value of trf_stream is : {0}'.format(trf_stream))
                    TGIgmpIntList = list(config_dict['TG'][TG][trf_stream]['igmp_config_dict'].keys())
                    for TGIgmpInt in TGIgmpIntList:
                        e = d.interfaces[TGIgmpInt].tgen_port_handle
                        igmp_group_dict = MyLib.my_config_utils.generateIGMPGroupList(log,config_dict['TG'][TG][trf_stream]['igmp_config_dict'][TGIgmpInt])
                        log.info('the value of igmp_group_dict is : {0}'.format(igmp_group_dict))
                        ip_list = tg_interface_hdl_dict[TG][trf_stream][TGIgmpInt]['ip_list']
                        group_list = igmp_group_dict['groups']
                        group_config = igmp_group_dict['configs']
                        for i,ip in enumerate(ip_list):
                            tg_interface_hdl_dict[TG][trf_stream][TGIgmpInt][ip]['group'] = group_list[i]
                            if igmp_group_dict['v3_configs']:
                                emulation_igmp_group_cfg = configureIgmpReports(self, group_config[i], tg_hdl=d, port_handle = e, intf_handle=tg_interface_hdl_dict[TG][trf_stream][TGIgmpInt][ip]['handle'],
                                                                                g_filter_mode=igmp_group_dict['v3_configs']['g_filter_mode'],source_pool_handle=igmp_group_dict['v3_configs']['source_pool_handle'])
                            else:
                                emulation_igmp_group_cfg = configureIgmpReports(self, group_config[i], tg_hdl=d, port_handle = e, intf_handle=tg_interface_hdl_dict[TG][trf_stream][TGIgmpInt][ip]['handle'])
                            tg_interface_hdl_dict[TG][trf_stream][TGIgmpInt][ip]['session_handle'] = emulation_igmp_group_cfg.handle
              
        a = yaml.dump(tg_interface_hdl_dict)
        log.info('the value of tg_interface_hdl_dict is : {0}'.format(a)) 
#         '''
#         pass 

    @aetest.subsection     
    def configureTrafficStreams(self,testscript,log):
        
#         '''
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        log.info('the value of tg_interface_hdl_dict is : {0}'.format(tg_interface_hdl_dict))
        configured_stream = testscript.parameters['configured_stream']
        
        log.info(banner('The value of configured_stream is : {0}'.format(configured_stream)))
        port_handle_dict = testscript.parameters['port_handle_dict']
        log.info('the value of port_handle_dict is : {0}'.format(port_handle_dict))
         
        TGList_config_file = testscript.parameters['TGList']
         
        traffic_stream_dict = {}
        for TG in TGList_config_file:
            d = testscript.parameters['testbed_obj'].devices[TG]
            for trf_stream in testscript.parameters['configdict']['TG'][TG]:
                log.info(banner('The value of trf_stream is : {0}'.format(trf_stream)))
                if(re.search('TRF',trf_stream)):
                    if trf_stream in configured_stream:
                        TGIgmpIntList = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict'].keys()
                        src_handle = []
                        dest_handle = []
                        traffic_stream_dict[trf_stream] = {}
                        source_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['source']
                        receiver_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['receivers']
                        traffic_args=testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['params']
                        if isinstance(source_port, list):
                            for i in source_port:
                                log.info('src: The value of i is : {0}'.format(i))
                                for port in tg_interface_hdl_dict[TG][trf_stream]:
                                    log.info('src: The value of port is : {0}'.format(port))
                                    if(port == i):
                                        pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                        for ip in tg_interface_hdl_dict[TG][trf_stream][port]:
                                            test=pat.match(ip)
                                            if test:
                                                log.info('src: The value of i is : {0}'.format(i))
                                                log.info('src: The value of port is : {0}'.format(port))
                                                log.info('src: The value of ip is : {0}'.format(ip))
                                                log.info('src: The value of trf_stream is : {0}'.format(trf_stream))
                                                handle = tg_interface_hdl_dict[TG][trf_stream][port][ip]['handle']
                                                src_handle.append(handle)
                     
                        if isinstance(receiver_port,list):
                            for i in receiver_port:
                                log.info('rcv:The value of i is : {0}'.format(i))
                                for port in tg_interface_hdl_dict[TG][trf_stream]:
                                    log.info('rcv: The value of port is : {0}'.format(port))
                                    if(port == i):
                                        pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                                        for ip in tg_interface_hdl_dict[TG][trf_stream][port]:
                                            test=pat.match(ip)
                                            if test:
                                                log.info('rcv: The value of i is : {0}'.format(i))
                                                log.info('rcv: The value of port is : {0}'.format(port))
                                                log.info('rcv: The value of ip is : {0}'.format(ip))
                                                log.info('rcv: The value of trf_stream is : {0}'.format(trf_stream))
                                                handle = tg_interface_hdl_dict[TG][trf_stream][port][ip]['session_handle']
                                                dest_handle.append(handle)
                        traffic_stream_dict[trf_stream]['source'] = source_port
                        traffic_stream_dict[trf_stream]['destination'] = receiver_port
                     
                        log.info('The value of src_handle is : {0}'.format(src_handle))
                        log.info('The value of dest_handle is : {0}'.format(dest_handle))
                         
                        ixia_traffic_config = configureIxNetworkTraffic(self, traffic_args, tg_hdl=d, emulation_src_handle=src_handle, emulation_dst_handle=dest_handle)
                        log.info('The value of ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                    
                        traffic_stream_dict[trf_stream]['stream_id'] = ixia_traffic_config.stream_id
                        traffic_stream_dict[trf_stream]['traffic_item'] = ixia_traffic_config.traffic_item
                        traffic_stream_dict[trf_stream]['status'] = ixia_traffic_config.status
                        
                elif(re.search('RAW',trf_stream)):
                    log.info(banner('Inside RAW Stream Configuration : '))
                    if trf_stream in configured_stream:
                        TGIgmpIntList = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict'].keys()
                        traffic_stream_dict[trf_stream] = {}
                        source_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['source']
                        receiver_port = testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['receivers']
                        traffic_args=testscript.parameters['configdict']['TG'][TG][trf_stream]['traffic_config_dict']['params']

                        traffic_stream_dict[trf_stream]['source'] = source_port
                        traffic_stream_dict[trf_stream]['destination'] = receiver_port
                         
                        src_port = [port_handle_dict[x] for x in source_port]
                        dst_port = [port_handle_dict[x] for x in receiver_port]
                        log.info('The value of src_port is : {0}'.format(src_port))
                        log.info('The value of dst_port is : {0}'.format(dst_port))
                        
                        ixia_traffic_config = configureIxNetworkRawTrafficL2(self, traffic_args, tg_hdl=d, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                        log.info('The value of ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                    
                        traffic_stream_dict[trf_stream]['stream_id'] = ixia_traffic_config.stream_id
                        traffic_stream_dict[trf_stream]['traffic_item'] = ixia_traffic_config.traffic_item
                        traffic_stream_dict[trf_stream]['status'] = ixia_traffic_config.status
                    
 
        log.info('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict))
        testscript.parameters['traffic_stream_dict']  = traffic_stream_dict     
    
    
    @aetest.subsection     
    def sendIGMPReports(self,testscript,log):  
        
#         '''
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
        
            igmp_status = startStopIgmpReports(tgn_hdl, action='start_all_protocols')
        
            if not igmp_status:
                log.info('IGMP Groups have not been sent successfully .. . Pls debug ')
#         '''
#         pass    
    
        
    @aetest.subsection     
    def startAllTrafficStreams(self,testscript,log):  
   
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold'] 
        
        log.info(banner('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict)))
           
        unstarted_stream = []
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            flag = 1
            failed_traffic_stream_stats = {}
            for trf_stream in traffic_stream_dict:
                if traffic_stream_dict[trf_stream]['status']:
                    stream_handle = traffic_stream_dict[trf_stream]['traffic_item']
                    x = tgn_hdl.traffic_control(action='run', handle = stream_handle, max_wait_timer=60)
                    stream_id = traffic_stream_dict[trf_stream]['stream_id']
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(stream_id)))
                        unstarted_stream.append(stream_id)
                        
        if unstarted_stream:
            log.error(banner('The Following Streams could not be started..{0}'.format(unstarted_stream)))
            self.failed()
            
        log.info(banner('Waiting for 30 seconds before measring the Traffic Stats:'))
        countDownTimer(30)
    
    @aetest.subsection     
    def checkAllTrafficStreamsStats(self,testscript,log):  
   
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        
        log.info(banner('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict)))
        
        failed_stream_list = []
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            for trf_stream in traffic_stream_dict:
                if traffic_stream_dict[trf_stream]['status']:
                    stream_handle = traffic_stream_dict[trf_stream]['traffic_item']
                    x = tgn_hdl.traffic_control(action='clear_stats', handle = stream_handle, max_wait_timer=60)
                    stream_id = traffic_stream_dict[trf_stream]['stream_id']
                    countDownTimer(10)
                    y = tgn_hdl.traffic_stats(stream=stream_id,mode='traffic_item')
                    log.info(banner('The value of y is : {0}'.format(y)))
                    for i in y['traffic_item']:
                        if i == stream_id:
                            loss_percent= y['traffic_item'][i]['rx']['loss_percent']
                            log.info(banner('The value of loss_percent is : {0}'.format(loss_percent)))
                            if loss_percent > 1.0:
                                failed_stream_list.append(trf_stream)
            
            log.info(banner('Traffic Stream Details and Breakup is'))
            
            traffic_obj = MyLib.my_config_utils.TrafficStatistics(log,tg_interface_hdl_dict,traffic_stream_dict,port_handle_dict,
                                                              threshold,node_dict,alias_intf_mapping,configured_stream)
            
            traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
#            traffic_obj.getAllRawStreamStatistics(tgn_hdl)
        
            if failed_stream_list:
                log.error(banner('The Initial Traffic Pass Criteria is not met for the following streams..{0}'.format(failed_stream_list)))
                failed_stream_dict = {}
                for stream in failed_stream_list:
                    failed_stream_dict[stream] = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,traffic_stream_dict,stream)
                log.info('the value of failed_stream_dict is : {0}'.format(failed_stream_dict))
                MyLib.my_config_utils.drawTrafficTable(log,failed_stream_dict,traffic_stream_dict)
                self.failed()


    @aetest.subsection     
    def initializeFewThingsForTest(self,testscript,log):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict']
        traffic_stream_dict = testscript.parameters['traffic_stream_dict']
        port_handle_dict = testscript.parameters['port_handle_dict']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        config_dict = testscript.parameters['configdict']

        traffic_obj = MyLib.my_config_utils.TrafficStatistics(log,tg_interface_hdl_dict,traffic_stream_dict,port_handle_dict,
                                                       threshold,node_dict,alias_intf_mapping,configured_stream)
        testscript.parameters['traffic_obj'] = traffic_obj
        
        traffic_config_obj = MyLib.my_config_utils.TrafficConfiguration(log,testscript,config_dict,port_handle_dict)
        
        testscript.parameters['traffic_config_obj'] = traffic_config_obj
        
        scale_config_obj = MyLib.my_config_utils.ScaleConfig(log,node_dict,config_dict,alias_intf_mapping)
        
        testscript.parameters['scale_config_obj'] = scale_config_obj
        
        multicast_trigger_obj = MyLib.my_trigger_utils.MulticastTrigger(log,node_dict,config_dict,alias_intf_mapping)
        
        testscript.parameters['multicast_trigger_obj'] = multicast_trigger_obj
        
        trigger_obj = MyLib.my_utils.TriggerItems(log,node_dict,config_dict,traffic_stream_dict,port_handle_dict,threshold,alias_intf_mapping,configured_stream)
        testscript.parameters['trigger_obj'] = trigger_obj
 
 
class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream002(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 002"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-002'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF002(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            
            
            with steps.start('Creating a new Traffic Stream - TRF002') as s:

                log.info('Creating a new Traffic Stream - TRF002')
                traffic_item = tgn_config_dict[TG]['TRF002']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF002') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF002') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF002') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF002')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF002') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF002')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF002 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF002',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF002'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF002')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()
                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream003(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 003"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-003'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF003(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            
     
            
            with steps.start('Creating a new Traffic Stream - TRF003') as s:

                log.info('Creating a new Traffic Stream - TRF003')
                traffic_item = tgn_config_dict[TG]['TRF003']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            

            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF005') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF003') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF003') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF003')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF003 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF003') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF003')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF003 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF003',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF003'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF003')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream004(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 004"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-004'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF004(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            
            
            with steps.start('Creating a new Traffic Stream - TRF004') as s:

                log.info('Creating a new Traffic Stream - TRF004')
                traffic_item = tgn_config_dict[TG]['TRF004']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            

            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF004') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF004') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF004') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF004')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF005 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF004') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF004')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF004 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF004',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF004'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF004')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream005(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 005"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-005'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF005(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF005') as s:

                log.info('Creating a new Traffic Stream - TRF005')
                traffic_item = tgn_config_dict[TG]['TRF005']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
     
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()
                    
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF005') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF005') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF005') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF005')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF005 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF005') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF005')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF005 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF005',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF005'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF005')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream006(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 006"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-006'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF006(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            
            
            with steps.start('Creating a new Traffic Stream - TRF006') as s:

                log.info('Creating a new Traffic Stream - TRF006')
                traffic_item = tgn_config_dict[TG]['TRF006']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
        
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF006') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF006') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF006') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF006')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF006 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF006') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF006')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF006 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF006',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF006'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF006')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream007(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 007"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-007'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF007(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            
            
            with steps.start('Creating a new Traffic Stream - TRF007') as s:

                log.info('Creating a new Traffic Stream - TRF007')
                traffic_item = tgn_config_dict[TG]['TRF007']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            

            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF007') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF007') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF007') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF007')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF007 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF007') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF007')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF007 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF007',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF007'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF007')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream008(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 008"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-008'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF008(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF008') as s:

                log.info('Creating a new Traffic Stream - TRF008')
                traffic_item = tgn_config_dict[TG]['TRF008']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()
                    
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF008') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF008') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF008') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF008')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF008 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF008') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF008')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF008 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF008',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF008'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF008')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

                log.info('Waiting for 30 seconds before starting the next test')
                countDownTimer(30)

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream009(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 009"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-009'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF009(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF009') as s:

                log.info('Creating a new Traffic Stream - TRF009')
                traffic_item = tgn_config_dict[TG]['TRF009']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()
                    
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF009') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF009') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF009') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF009')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF009 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF009') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF009')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF009 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF009',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF009'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF009')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream010(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 010"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-010'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF010(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF010') as s:

                log.info('Creating a new Traffic Stream - TRF010')
                traffic_item = tgn_config_dict[TG]['TRF010']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
 
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF010') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF010') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF010') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF010')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF010 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF010') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF010')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF010 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF010',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF010'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF010')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream011(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 011"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-011'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF011(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF011') as s:

                log.info('Creating a new Traffic Stream - TRF011')
                traffic_item = tgn_config_dict[TG]['TRF011']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)

            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF011') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF011') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF011') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF011')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF011 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF011') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF011')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF011 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF011',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF011'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF011')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream012(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 012"""

    uid ='VXLAN-MS-L3-TRM-VPC-BGW-TRF-012'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF012(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF012') as s:

                log.info('Creating a new Traffic Stream - TRF012')
                traffic_item = tgn_config_dict[TG]['TRF012']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)

            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF012') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF012') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF012') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF012')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF012 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF012') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF012')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF012 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF012',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF012'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF012')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream013(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 013"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-013'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF013(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()                                
            
            with steps.start('Creating a new Traffic Stream - TRF013') as s:

                log.info('Creating a new Traffic Stream - TRF013')
                traffic_item = tgn_config_dict[TG]['TRF013']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
 
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF013') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF013') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF013') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF013')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF013 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF013') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF013')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF013 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF013',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF013'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF013')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream014(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 014"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-014'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF014(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            

            
            with steps.start('Creating a new Traffic Stream - TRF014') as s:

                log.info('Creating a new Traffic Stream - TRF014')
                traffic_item = tgn_config_dict[TG]['TRF014']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            

            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF014') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF014') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF014') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF014')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF014 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF014') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF014')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF014 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF014',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF014'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF014')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream015(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 015"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-015'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF015(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be stopped')
                    self.failed()            

            
            with steps.start('Creating a new Traffic Stream - TRF015') as s:

                log.info('Creating a new Traffic Stream - TRF015')
                traffic_item = tgn_config_dict[TG]['TRF015']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()            

            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF015') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF015') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF015') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF015')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF015 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF015') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF015')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF015 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF015',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF015'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF015')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream016(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 016"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-016'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF016(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF016') as s:

                log.info('Creating a new Traffic Stream - TRF016')
                traffic_item = tgn_config_dict[TG]['TRF016']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF016') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF016') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF016') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF016')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF016 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF016') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF016')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF016 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF016',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF016'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF016')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream017(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 017"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-017'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF017(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF017') as s:

                log.info('Creating a new Traffic Stream - TRF017')
                traffic_item = tgn_config_dict[TG]['TRF017']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF017') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF017') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF017') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF017')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF017 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF017') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF017')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF017 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF017',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF017'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF017')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream018(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 018"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-018'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF018(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF018') as s:

                log.info('Creating a new Traffic Stream - TRF018')
                traffic_item = tgn_config_dict[TG]['TRF018']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF018') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF018') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF018') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF018')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF018 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF018') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF018')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF018 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF018',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF018'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF018')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream019(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 019"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-019'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF019(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF019') as s:

                log.info('Creating a new Traffic Stream - TRF019')
                traffic_item = tgn_config_dict[TG]['TRF019']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF019') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF019') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF019') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF019')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF019 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF019') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF019')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF019 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF019',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF019'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF019')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream020(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 020"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-020'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF020(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF020') as s:

                log.info('Creating a new Traffic Stream - TRF020')
                traffic_item = tgn_config_dict[TG]['TRF020']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF020') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF020') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF020') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF020')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF020 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF020') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF020')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF020 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF020',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF020'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF020')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream021(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 021"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-021'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF021(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF021') as s:

                log.info('Creating a new Traffic Stream - TRF021')
                traffic_item = tgn_config_dict[TG]['TRF021']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF021') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF021') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF021') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF021')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF021 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF021') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF021')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF021 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF021',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF021'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF021')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream022(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 022"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-022'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF022(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF022') as s:

                log.info('Creating a new Traffic Stream - TRF022')
                traffic_item = tgn_config_dict[TG]['TRF022']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF022') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF022') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF022') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF022')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF022 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF022') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF022')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF022 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF022',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF022'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF022')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream023(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 023"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-023'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF023(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF023') as s:

                log.info('Creating a new Traffic Stream - TRF023')
                traffic_item = tgn_config_dict[TG]['TRF023']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF023') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF023') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF023') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF023')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF023 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF023') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF023')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF023 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF023',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF023'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF023')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream024(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 024"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-024'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF024(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF024') as s:

                log.info('Creating a new Traffic Stream - TRF024')
                traffic_item = tgn_config_dict[TG]['TRF024']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF024') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF024') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF024') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF024')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF024 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF024') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF024')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF024 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF024',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF024'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF024')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream025(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 025"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-025'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF025(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF025') as s:

                log.info('Creating a new Traffic Stream - TRF025')
                traffic_item = tgn_config_dict[TG]['TRF025']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF025') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF025') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF025') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF025')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF025 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF025') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF025')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF025 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF025',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF025'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF025')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream026(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 026"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-026'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF026(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF026') as s:

                log.info('Creating a new Traffic Stream - TRF026')
                traffic_item = tgn_config_dict[TG]['TRF026']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF026') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF026') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF026') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF026')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF026 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF026') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF026')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF026 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF026',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF026'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF026')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   
class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream027(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 027"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-027'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF027(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF027') as s:

                log.info('Creating a new Traffic Stream - TRF027')
                traffic_item = tgn_config_dict[TG]['TRF027']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF027') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF027') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF027') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF027')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF027 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF027') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF027')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF027 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF027',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF027'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF027')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream028(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 028"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-028'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF028(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF028') as s:

                log.info('Creating a new Traffic Stream - TRF028')
                traffic_item = tgn_config_dict[TG]['TRF028']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF028') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF028') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF028') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF028')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF028 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF028') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF028')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF028 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF028',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF028'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF028')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream029(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 029"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-029'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF029(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF029') as s:

                log.info('Creating a new Traffic Stream - TRF029')
                traffic_item = tgn_config_dict[TG]['TRF029']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF029') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF029') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF029') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF029')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF029 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF029') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF029')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF029 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF029',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF029'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF029')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream030(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 030"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-030'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF030(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF030') as s:

                log.info('Creating a new Traffic Stream - TRF030')
                traffic_item = tgn_config_dict[TG]['TRF030']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF030') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF030') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF030') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF030')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF099 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF030') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF030')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF030 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF030',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF030'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF030')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream031(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 031"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-031'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF031(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF031') as s:

                log.info('Creating a new Traffic Stream - TRF031')
                traffic_item = tgn_config_dict[TG]['TRF031']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF031') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF031') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF031') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF031')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF031 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF031') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF031')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF031 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF031',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF031'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF031')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream032(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 032"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-032'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF032(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF032') as s:

                log.info('Creating a new Traffic Stream - TRF032')
                traffic_item = tgn_config_dict[TG]['TRF032']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF032') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF032') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF032') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF032')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF032 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF032') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF032')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF032 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF032',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF032'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF032')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream033(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 033"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-033'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF033(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF033') as s:

                log.info('Creating a new Traffic Stream - TRF033')
                traffic_item = tgn_config_dict[TG]['TRF033']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF033') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF033') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF033') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF033')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF033 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF033') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF033')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF033 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF033',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF033'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF033')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream034(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 034"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-034'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF034(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF034') as s:

                log.info('Creating a new Traffic Stream - TRF034')
                traffic_item = tgn_config_dict[TG]['TRF034']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF034') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF034') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF034') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF034')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF034 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF034') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF034')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF034 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF034',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF034'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF034')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream035(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 035"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-035'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF035(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF035') as s:

                log.info('Creating a new Traffic Stream - TRF035')
                traffic_item = tgn_config_dict[TG]['TRF035']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF035') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF035') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF035') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF035')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF035 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF035') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF035')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF035 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF035',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF035'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF035')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream036(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 036"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-036'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF036(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF036') as s:

                log.info('Creating a new Traffic Stream - TRF036')
                traffic_item = tgn_config_dict[TG]['TRF036']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF036') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF036') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF036') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF036')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF036 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF036') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF036')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF036 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF036',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF036'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF036')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream037(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 037"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-037'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF037(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF037') as s:

                log.info('Creating a new Traffic Stream - TRF037')
                traffic_item = tgn_config_dict[TG]['TRF037']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF037') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF037') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF037') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF037')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF037 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF037') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF037')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF037 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF037',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF037'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF037')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream038(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 038"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-038'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF038(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF038') as s:

                log.info('Creating a new Traffic Stream - TRF038')
                traffic_item = tgn_config_dict[TG]['TRF038']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF038') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF038') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF038') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF038')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF038 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF038') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF038')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF038 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF038',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF038'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF038')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream039(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 039"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-039'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF039(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF039') as s:

                log.info('Creating a new Traffic Stream - TRF039')
                traffic_item = tgn_config_dict[TG]['TRF039']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF039') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF039') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF039') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF039')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF039 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF039') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF039')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF039 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF039',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF039'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF039')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream040(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 040"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-040'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF040(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF040') as s:

                log.info('Creating a new Traffic Stream - TRF040')
                traffic_item = tgn_config_dict[TG]['TRF040']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF040') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF040') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF040') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF040')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF040 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF040') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF040')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF040 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF040',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF040'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF040')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream041(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 041"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-041'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF041(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF041') as s:

                log.info('Creating a new Traffic Stream - TRF041')
                traffic_item = tgn_config_dict[TG]['TRF041']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF041') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF041') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF041') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF041')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF041 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF041') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF041')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF041 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF041',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF041'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF041')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream042(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 042"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-042'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF042(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF042') as s:

                log.info('Creating a new Traffic Stream - TRF042')
                traffic_item = tgn_config_dict[TG]['TRF042']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF042') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF042') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF042') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF042')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF042 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF042') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF042')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF042 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF042',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF042'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF042')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream043(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 043"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-043'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF043(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF043') as s:

                log.info('Creating a new Traffic Stream - TRF043')
                traffic_item = tgn_config_dict[TG]['TRF043']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF043') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF043') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF043') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF043')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF043 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF043') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF043')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF043 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF043',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF043'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF043')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream044(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 044"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-044'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF044(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF044') as s:

                log.info('Creating a new Traffic Stream - TRF044')
                traffic_item = tgn_config_dict[TG]['TRF044']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF044') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF044') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF044') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF044')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF044 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF044') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF044')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF044 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF044',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF044'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF044')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream045(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 045"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-045'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF045(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF045') as s:

                log.info('Creating a new Traffic Stream - TRF045')
                traffic_item = tgn_config_dict[TG]['TRF045']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF045') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF045') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF045') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF045')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF045 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF045') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF045')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF045 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF045',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF045'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF045')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream046(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 046"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-046'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF046(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF046') as s:

                log.info('Creating a new Traffic Stream - TRF046')
                traffic_item = tgn_config_dict[TG]['TRF046']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF046') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF046') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF046') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF046')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF046 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF046') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF046')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF046 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF046',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF046'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF046')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream047(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 047"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-047'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF047(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF047') as s:

                log.info('Creating a new Traffic Stream - TRF047')
                traffic_item = tgn_config_dict[TG]['TRF047']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF047') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF047') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF047') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF047')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF047 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF047') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF047')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF047 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF047',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF047'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF047')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream048(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 048"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-048'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF048(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF048') as s:

                log.info('Creating a new Traffic Stream - TRF048')
                traffic_item = tgn_config_dict[TG]['TRF048']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF048') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF048') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF048') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF048')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF048 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF048') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF048')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF048 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF048',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF048'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF048')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream049(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 049"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-049'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF049(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF049') as s:

                log.info('Creating a new Traffic Stream - TRF049')
                traffic_item = tgn_config_dict[TG]['TRF049']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF049') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF049') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF049') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF049')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF049 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF049') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF049')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF049 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF049',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF049'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF049')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream050(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 050"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-050'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF050(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF050') as s:

                log.info('Creating a new Traffic Stream - TRF050')
                traffic_item = tgn_config_dict[TG]['TRF050']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF050') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF050') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF050') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF050')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF050 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF050') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF050')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF050 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF050',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF050'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF050')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream051(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 051"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-051'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF051(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF051') as s:

                log.info('Creating a new Traffic Stream - TRF051')
                traffic_item = tgn_config_dict[TG]['TRF051']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF051') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF051') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF051') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF051')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF051 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF051') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF051')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF051 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF051',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF051'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF051')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream052(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 052"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-052'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF052(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF052') as s:

                log.info('Creating a new Traffic Stream - TRF052')
                traffic_item = tgn_config_dict[TG]['TRF052']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF052') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF052') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF052') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF052')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF052 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF052') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF052')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF052 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF052',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF052'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF052')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream053(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 053"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-053'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF053(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF053') as s:

                log.info('Creating a new Traffic Stream - TRF053')
                traffic_item = tgn_config_dict[TG]['TRF053']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF053') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF053') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF053') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF053')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF053 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF053') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF053')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF053 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF053',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF053'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF053')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream054(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 054"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-054'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF054(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF054') as s:

                log.info('Creating a new Traffic Stream - TRF054')
                traffic_item = tgn_config_dict[TG]['TRF054']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF054') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF054') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF054') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF054')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF054 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF054') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF054')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF054 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF054',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF054'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF054')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream055(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 055"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-055'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF055(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF055') as s:

                log.info('Creating a new Traffic Stream - TRF055')
                traffic_item = tgn_config_dict[TG]['TRF055']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF055') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF055') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF055') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF055')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF055 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF055') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF055')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF055 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF055',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF055'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF055')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream056(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 056"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-056'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF056(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF056') as s:

                log.info('Creating a new Traffic Stream - TRF056')
                traffic_item = tgn_config_dict[TG]['TRF056']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF056') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF056') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF056') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF056')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF056 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF056') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF056')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF056 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF056',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF056'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF056')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream057(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 057"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-057'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF057(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF057') as s:

                log.info('Creating a new Traffic Stream - TRF057')
                traffic_item = tgn_config_dict[TG]['TRF057']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF057') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF057') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF057') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF057')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF057 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF057') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF057')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF057 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF057',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF057'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF057')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream058(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 058"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-058'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF058(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF058') as s:

                log.info('Creating a new Traffic Stream - TRF058')
                traffic_item = tgn_config_dict[TG]['TRF058']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF058') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF058') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF058') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF058')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF058 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF058') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF058')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF058 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF058',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF058'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF058')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream059(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 059"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-059'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF059(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF059') as s:

                log.info('Creating a new Traffic Stream - TRF059')
                traffic_item = tgn_config_dict[TG]['TRF059']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF059') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF059') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF059') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF059')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF059 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF059') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF059')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF059 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF059',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF059'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF059')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_InitializeTrafficStream060(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 060"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-TRF-060'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_TRF060(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating a new Traffic Stream - TRF060') as s:

                log.info('Creating a new Traffic Stream - TRF060')
                traffic_item = tgn_config_dict[TG]['TRF060']
                new_tg_intf_config_dict = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Stream - TRF060') as s:
    
                log.info(banner('Sending IGMP Joins now.. '))
                for i in new_tg_intf_config_dict['destination']:
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in new_tg_intf_config_dict[i]:
                        test=pat.match(ip)
                        if test:
                            a = new_tg_intf_config_dict[i][ip]['session_handle']
                            b = tgn_hdl.emulation_igmp_control(mode='start')
                            c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                            o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                            if not o.status:
                                log.info('IGMP join is not sent to the group . Pls debug.....')
                                self.failed()
                                    
            with steps.start('Starting the Traffic on stream  - TRF060') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - TRF060') as s:
                
                ixia_stream = new_tg_intf_config_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'TRF060')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream TRF060 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - TRF060') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'TRF060')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(new_tg_intf_config_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF060 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('TRF060',{})
                    trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict['TRF060'].update(trimmed_stream_config_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('TRF060')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func001(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-001"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-001'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func001(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()      
                    
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-001'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - BL-001') as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - BL-001') as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,'BL-001')
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    
            with steps.start('Stopping the Newly Created Stream - BL-001') as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,'BL-001')))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF060 to Global List') as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault('BL-001',{})
                    traffic_stream_dict['BL-001'].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append('BL-001')
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func002(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-002"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-002'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func002(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()      
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-002'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1

            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func003(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-003"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-003'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func003(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                         
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-003'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func004(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-004"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-004'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func004(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                  

            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-004'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1

            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()                  

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func005(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-005"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-005'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func005(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-005'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func006(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-006"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-006'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func006(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()           
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-006'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func007(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-007"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-007'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func007(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-007'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func008(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-008"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-008'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func008(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-008'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func009(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-009"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-009'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func009(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-009'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func010(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-010"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-010'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func010(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-010'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func011(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-011"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-011'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func011(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
      
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-011'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()                  
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func012(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-012"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-012'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func012(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-012'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func013(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-013"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-013'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func013(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-013'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_Func014(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-014"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-014'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func014(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-014'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
    
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()          
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func015(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-015"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-015'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func015(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-015'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func016(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-016"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-016'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func016(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-016'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func017(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-017"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-017'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func017(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-017'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func018(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-018"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-018'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func018(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
     
            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-018'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
            
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()      

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func019(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-019"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-019'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func019(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-019'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
         
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()               
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func020(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-020"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-020'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func020(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-020'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func021(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-021"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-021'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func021(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-021'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func022(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-022"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-022'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func022(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-022 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-022 as defined in Config File')
                traffic_item = 'BL-022'
                interface_hdl_dict = {}
                log.info('The value of tgn_config_dict[TG] is : {0}'.format(tgn_config_dict[TG].keys()))
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func023(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-023"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-023'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func023(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-023'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func024(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-024"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-024'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func024(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-024'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func025(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-025"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-025'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func025(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-025'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func026(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-026"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-026'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func026(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-026'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func027(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-027"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-027'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func027(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-027'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func028(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-028"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-028'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func028(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-028'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func029(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-029"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-029'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func037(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-029'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func030(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-030"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-030'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func030(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-030'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func031(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-031"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-031'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func031(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-031'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func032(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-032"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-032'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func032(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-032'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func033(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-033"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-033'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func033(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-033'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func034(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-034"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-034'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func034(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-034'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func035(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-035"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-035'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func037(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-035'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func036(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-036"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-036'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func036(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-036'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func037(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-037"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-037'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func037(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-037'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func038(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-038"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-038'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func038(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-038'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func039(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-039"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-039'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func039(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-039'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func040(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-040"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-040'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func040(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('Test1:- Establishing BGP Neighbor with Ixia - Pumping Routes'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Stopping the IGMP Protocol') as s:
                log.info('Stopping the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'stop_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be Stopped')
                    self.failed()                          
            
            with steps.start('Configuring Interfaces for Traffic BL-001 as defined in Config File') as s:
                log.info('Configuring Interfaces for Traffic BL-001 as defined in Config File')
                traffic_item = 'BL-040'
                interface_hdl_dict = {}
                TGIntList = tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'].keys()
                log.info('Value of TGIntList is : {0}'.format(TGIntList))
                for TGInt in TGIntList:
                    intf_args = generateTrafficGenIntfConfigs(log,tgn_config_dict[TG][traffic_item]['tg_interface_config_dict'][TGInt])
                    log.info('Value of intf_args is : {0}'.format(intf_args))
                    for i in intf_args:
                        ixia_interface_config = configureMultiIxNetworkInterface(self, i, tg_hdl=tgn_hdl, port_handle=port_handle_dict[TGInt])
                        log.info('The value of ixia_interface_config is : {0}'.format(ixia_interface_config))
                        for k,v in ixia_interface_config.items(): 
                            interface_hdl_dict.update({TGInt:v})
                    log.info('The value of interface_hdl_dict is {0}'.format(interface_hdl_dict))
                
            with steps.start('Configuring BGP Router on the Ixia') as s:
                log.info('Configuring BGP Router on the Ixia')
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    bgp_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['router_configs']
                    log.info('The value of bgp_args is : {0}'.format(bgp_args))
                    for i in bgp_args.split('\n'):
                        log.info('The value of i is : {0}'.format(i))
                    bgp_router_handle_list = []
                    ixia_emulation_bgp_config = configureBgpRouter(self, bgp_args, tg_hdl=tgn_hdl, port_handle= port_handle_dict[TGInt], intf_handle = interface_hdl_dict[TGInt])
                    log.info('The value of ixia_emulation_bgp_config is : {0}'.format(ixia_emulation_bgp_config))
                    bgp_router_handle_list.append(ixia_emulation_bgp_config['handles'])
                    log.info('The value of bgp_router_handle_list is : {0}'.format(bgp_router_handle_list))
                    
            with steps.start('Configuring BGP Route Ranges on the Ixia') as s:
                log.info('Configuring BGP Route Ranges on the Ixia')
                bgp_route_list = []
                for TGInt in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'].keys():
                    for routes in tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'].keys():
                        route_args = tgn_config_dict[TG][traffic_item]['bgp_router_config_dict'][TGInt]['route_ranges'][routes]
                        ixia_emulation_bgp_route_config = configureBgpRoutes(self, route_args, tg_hdl=tgn_hdl, bgp_router_hdl = bgp_router_handle_list[0])
                        log.info('The value of ixia_emulation_bgp_route_config is : {0}'.format(ixia_emulation_bgp_route_config))
                        bgp_route_list.append(ixia_emulation_bgp_route_config['bgp_routes'])
                log.info('The value of bgp_route_list is : {0}'.format(bgp_route_list))
    
            with steps.start('Starting BGP Protocols ') as s:
                log.info(banner('Starting BGP Protocols '))
                bgp_protocol_start = startBgpProtocol(self,tg_hdl = tgn_hdl, mode = 'start', handle = bgp_router_handle_list[0])
                log.info(banner('Waiting for 30 seconds before creating the Traffic Stream'))
                countDownTimer(30)
                if not bgp_protocol_start.status:
                    log.error('Problem in starting the BGP Protocol')
                    self.failed()
            
            with steps.start('Creating the Traffic Streams') as s:
                log.info(banner('Creating the Traffic Streams'))
                this_stream_dict = {}
                log.info('Interface Handle dictis : {0}'.format(interface_hdl_dict))
                
                traffic_args = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['params']
                source_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['source']
                destination_port = tgn_config_dict[TG][traffic_item]['traffic_config_dict']['receivers']
                log.info('Value of destination[0] is  : {0}'.format(destination_port[0]))
                log.info('Interface Handle is: {0}'.format(interface_hdl_dict[destination_port[0]]))
                
                ixia_traffic_config = configureIxNetworkTraffic(self,traffic_args,tg_hdl = tgn_hdl,\
                                                                emulation_src_handle = interface_hdl_dict[destination_port[0]],\
                                                                emulation_dst_handle = bgp_route_list[0])
                
                log.info('the Value of Ixia_traffic_config is : {0}'.format(ixia_traffic_config))
                this_stream_dict['source'] = source_port
                this_stream_dict['destination'] = destination_port
                this_stream_dict['stream_id'] = ixia_traffic_config['stream_id']
                this_stream_dict['status'] = ixia_traffic_config['status']
                this_stream_dict['traffic_item'] = ixia_traffic_config['traffic_item']
                if not ixia_traffic_config.status:
                    log.error('Problem in starting the Traffic Stream')
                    self.failed()
                
            with steps.start('Starting the Traffic on stream  - {0}'.format(traffic_item)) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                log.info(banner('Starting the New Stream Created for this test ..'))
                x = tgn_hdl.traffic_control(action='run', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats on Stream  - {0}'.format(traffic_item)) as s:
                
                ixia_stream = this_stream_dict['stream_id']
                log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                countDownTimer(15)
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,traffic_item)
                log.info(banner('The Value of res is: {0}'.format(res)))
                
                if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                    log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                    stream_add_flag = 1
                else:
                    log.error(banner('Traffic on Stream BL-002 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                    stream_add_flag = 0
                    self.failed()
                    
            with steps.start('Stopping the Newly Created Stream - {0}'.format(traffic_item)) as s:        
                    
                log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,traffic_item)))
                x1 = tgn_hdl.traffic_control(action='stop', handle = this_stream_dict['traffic_item'],max_wait_timer=60)
                log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                countDownTimer(30)
                
                if not x1.status:
                    log.error(banner('The Stream {0} could not be stopped as expected '.format(this_stream_dict['stream_id'])))
                    self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(traffic_item)) as s:
                
                if stream_add_flag:
                    log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                    traffic_stream_dict.setdefault(traffic_item,{})
                    #trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[k]) for k in new_tg_intf_config_dict.keys() if k in ['source','destination','stream_id','status','traffic_item'])
                    traffic_stream_dict[traffic_item].update(this_stream_dict)
                    log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                    log.info(banner('Adding the New stream to the configured stream list :'))
                    configured_stream.append(traffic_item)
                    log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                    testscript.parameters['configured_stream'] = configured_stream
                    testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                else:
                    log.info('Removing the stream {0}:'.format(ixia_stream))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                    flag = 1
       
            with steps.start('Starting the IGMP Protocol') as s:
                log.info('Starting the IGMP protocol')
                igmp_status = tgn_hdl.test_control(action = 'start_all_protocols')
                countDownTimer(10)
                log.info('The value of igmp_status is " {0}'.format(x))
                if not igmp_status.status:
                    log.error('The IGMP Protocol could not be started')
                    self.failed()             
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func041(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-041"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-041'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func041(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test1:- Generating BUM TRaffic - Broadcast Traffic'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            vlan_start = 101
            num_of_vlans = 100
            vni_start = 100101
            mcast_group = '225.250.1.1'
            mcast_group_mask = 32
            
            global_flag = 0
            stream_create_flag = 0
            stream_start_flag = 0
            stream_stat_fail_flag = 0
            stream_stop_flag = 0
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('Configuring the vlans required for the tests in all VTEPs') as s:
                log.info('Configuring the vlans required for the tests in all VTEPs')
                
            
                log.info(banner('Configuring the Vlans on all VTEPs'))
                                
                args = '-no_of_l2_vlans {0} -l2_vlan_start {1} -l2_vni_start {2}'.format(num_of_vlans,vlan_start,vni_start)
                
                threads = []
                for dut in vtep_dict:
                    t = threading.Thread(target = MyLib.my_config_utils.configureVlans,
                                         args = [log, vtep_dict[dut], args])
                    t.start()
                    threads.append(t)
                [thread.join() for thread in threads]
                
                
                '''
                for dut in vtep_dict.keys():
                    hdl = node_dict['all_dut'][dut]
                    MyLib.my_config_utils.configureVlans(log,hdl,args)
                '''
            
                testscript.parameters['bridge_vlan_start'] = vlan_start
                testscript.parameters['bridge_num_of_vlans'] = num_of_vlans
                testscript.parameters['bridge_vni_start'] = vni_start
                testscript.parameters['bridge_mcast_group'] = mcast_group
            
            
            with steps.start('Configuring the EVPN configs for the tests in all VTEPs') as s:
                log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                evpn_config_dict = {}
                for dut in vtep_dict:
                    evpn_config_dict[dut]={}
                    evpn_config_dict[dut]['evpn'] = '-no_of_vnis {0} -l2_vni_start {1} -rd auto -route_target_import_list auto -route_target_export_list auto'.format(num_of_vlans,vni_start)
                
                
                log.info(banner('Configuring the evpn_config_dict on all VTEPs is  : {0}'.format(evpn_config_dict)))
                
                new_evpn_config_dict = MyLib.my_config_utils.generateEvpnDict(log,evpn_config_dict,vtep_dict)
                log.info('The value of new_evpn_config_dict is: {0}'.format(new_evpn_config_dict))
                
                threads = []
                for dut in vtep_dict:
                    t = threading.Thread(target = evpn_lib.configEvpn,
                                         args = [dut, vtep_dict[dut], new_evpn_config_dict[dut],log])
                    t.start()
                    threads.append(t)
                [thread.join() for thread in threads]
                
                '''
                dut = 'uut1'
                res = evpn_lib.configEvpn(dut,node_dict['all_dut'][dut],new_evpn_config_dict[dut],log)
                '''
                
            with steps.start('Configuring the Member VNI configs for the tests in all VTEPs') as s:
                log.info('Configuring the EVPN configs for the tests in all VTEPs')
                
                args = '-no_of_l2_vni {0} -l2_vni_start {1} -evpn_mcast True -l2_vni_mcast {2} -l2_vni_mcast_mask {3} -multisite_ir True'.format(num_of_vlans,vni_start,mcast_group,mcast_group_mask)
                
                
                threads = []
                for dut in vtep_dict:
                    t = threading.Thread(target = MyLib.my_config_utils.cfgL2VNIOnNVeIntf,
                                         args = [dut,node_dict['all_dut'][dut],args,log])
                    t.start()
                    threads.append(t)
                [thread.join() for thread in threads]
                
                '''
                dut = 'uut1'
                res = MyLib.my_config_utils.cfgL2VNIOnNVeIntf(dut,node_dict['all_dut'][dut],args,log)
                '''
            
            
            
            with steps.start('Configuring Raw Traffic -BUM - Broadcast Trafic') as s:
                raw_traffic_dict = {}
                raw_list  = []
                fail_stream = []
                for trf_item in tgn_config_dict[TG].keys():
                    if re.search('RAW', trf_item, re.IGNORECASE):
                        raw_list.append(trf_item)
                        
                log.info(banner('The value of raw_list is : {0}'.format(raw_list)))
                        
                for item in raw_list:
                    raw_traffic_dict[item] = {}
                    log.info('Creating Raw stream for traffic stream {0} as defined in Config File'.format(item))
                    source_port = tgn_config_dict[TG][item]['traffic_config_dict']['source']
                    receiver_port = tgn_config_dict[TG][item]['traffic_config_dict']['receivers']
                    trf_args = tgn_config_dict[TG][item]['traffic_config_dict']['params']
                    
                    src_port = [port_handle_dict[x] for x in source_port]
                    dst_port = [port_handle_dict[x] for x in receiver_port]
                    
                    raw_traffic_cfg = configureIxNetworkRawTrafficL2(self, trf_args, tg_hdl=tgn_hdl, emulation_src_handle=src_port, emulation_dst_handle=dst_port)
                    log.info('The value of ixia_traffic_config is : {0}'.format(raw_traffic_cfg))

                    if not raw_traffic_cfg.status:
                        log.error('The Raw stream {0} could not be generated'.format(item))
                        fail_stream.append(item)
                    else:
                        raw_traffic_dict[item]['source'] = source_port
                        raw_traffic_dict[item]['destination'] = receiver_port
                        raw_traffic_dict[item]['stream_id'] = raw_traffic_cfg['stream_id']
                        raw_traffic_dict[item]['status'] = raw_traffic_cfg['status']
                        raw_traffic_dict[item]['traffic_item'] = raw_traffic_cfg['traffic_item']
                        
                    if fail_stream:
                        global_flag  = 1
                        stream_create_flag  = 1

                
            with steps.start('Starting the BUM Traffic Stream one by one') as s:
                log.info(banner('Starting the BUM Traffic Stream one by one'))
                countDownTimer(30)
                start_fail_stream = []
                
                for item in raw_traffic_dict.keys():
                    log.info(banner('Starting the New Stream Created for this test . {0}'.format(item)))
                    x = tgn_hdl.traffic_control(action='run', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(this_stream_dict['stream_id'])))
                        start_fail_stream.append(item)
                    
                    if len(raw_list) > 1:
                        log.info(banner('Waiting for 10 seconds before starting the other stream:'))
                        countDownTimer(10)
                    
                        
                if start_fail_stream:
                    global_flag  = 1
                    stream_start_flag = 1
                
            with steps.start('Measuring Traffic Stats on Stream one by one') as s:
                log.info(banner('Measuring Traffic Stats on Stream one by one'))
                stats_success_stream = []
                stats_fail_stream = []
                
                for item in raw_traffic_dict.keys():
                    ixia_stream = raw_traffic_dict[item]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,item)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    exp_rx_traffic = res['tx'] * len(receiver_port)
                    log.info('The value of exp_rx_traffic is : {0}'.format(exp_rx_traffic))
                    
                    if res['tx'] !=0 and abs(exp_rx_traffic-res['rx']) < threshold:
                        log.info('The BL traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        stats_success_stream.append(item)
                    else:
                        log.error(banner('Traffic on Stream RAW001 is not as expected. The value of tx and rx is : {0} and {1}'.format(res['tx'],res['rx'])))
                        stats_fail_stream.append(item)
                        
                if stats_fail_stream:
                    log.error('Stream Pass Criteria Failed for streams {0}'.format(stats_fail_stream))
                    global_flag = 1
                    stream_stat_fail_flag = 1
                    
            with steps.start('Stopping All the Newly Created streams: {0}'.format(list(raw_traffic_dict.keys()))) as s:
                
                stop_fail_stream_list = []
                
                for item in raw_traffic_dict.keys():
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(raw_traffic_dict[item]['stream_id'],item)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = raw_traffic_dict[item]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 15 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(15)
                
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(raw_traffic_dict[item]['stream_id'])))
                        stop_fail_stream_list.append(item)
                if stop_fail_stream_list:
                    log.error(banner('The following streams could not be stopped {0}'.format(stop_fail_stream_list)))
                    global_flag = 1
                    stream_stop_flag = 1
            
            with steps.start('Adding / Deleting the Newly Created Stream - {0} to Global List'.format(list(raw_traffic_dict.keys()))) as s:
                
                if stats_success_stream:
                    for item in stats_success_stream:

                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: {0}'.format(item)))
                        traffic_stream_dict.setdefault(item,{})
                        traffic_stream_dict[item].update(raw_traffic_dict[item])
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(item)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif stats_fail_stream:
                    log.info('Removing the stream {0}:'.format(raw_traffic_dict[item]['stream_id']))
                    y = tgn_hdl.traffic_config(mode='remove',stream_id=raw_traffic_dict[item]['stream_id'])
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    global_flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if global_flag:
                    if stream_create_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream Creation Failed {0}'.format(fail_stream))
                        self.failed()
                    elif stream_start_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The following Stream could not be started {0}'.format(start_fail_stream))
                        self.failed()
                    elif stream_stat_fail_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Traffic pass criteria could not be met for following streams {0}'.format(stats_fail_stream))
                        self.failed()
                    elif stream_stop_flag:
                        log.info('Starting all the streams from global list:')
                        z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                        log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                        countDownTimer(30)
                        log.error('The Following stream could not be stopped {0}'.format(stop_fail_stream_list))
                        self.failed()
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func042(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-042"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-042'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func042_RemovingFeatureNGMVPNOnBGW(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Removing Feature NGMVPN on BGWs'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Backup Configs - on BGWs') as s:
                log.info(banner('Backing up configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Backing up config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('Backup Failed on the dut: {0}'.format(dut)))
                        self.failed()
            
            with steps.start('Remove Feature NGMVPN  - on BGWs') as s:
                log.info(banner('Remove Feature NGMVPN on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Removing feature ngmvpn on dut : {0}'.format(dut)))
                    out=bringup_lib.unconfigFeature(node_dict['all_dut'][dut], log, '-feature ngmvpn' )
                    if out.result=='fail':
                        log.error('Disable of NGMVPN failed on dut %s' % dut)
                        self.failed()
                    else:
                        log.info('Disable of NGMVPN passes on dut %s' % dut)

            with steps.start('Checking the Traffic Stats after removing the feature ngmvpn') as s:
                log.info('Checking the Traffic Stats after removing the feature ngmvpn')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)

            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            
            

class VXlanMultiSiteL3TRMWithVPCasBGW_Func043(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-043"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-043'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func043_ShuttingDCILinksOnVPCPrimary(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Shutting DCI links on VPC Primary...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info('The value of VPC_primary is: {0}'.format(vpc_primary))

            
            with steps.start('Getting the DCI links from VPC Primary') as s:
                log.info(banner('Getting the DCI links from VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh nve multisite dci-links | xml'
                switch_hdl = vpc_primary['hdl']
                out = switch_hdl.execute(cfg)
                intf_list = []
                for line in out.splitlines():
                    if re.search('if-name',line,re.IGNORECASE):
                        s = BeautifulSoup(line)
                        try:
                            intf = s.find('if-name').string
                            intf_list.append(intf)
                        except Exception:
                            log.error('Interface name could not be generated')
                            flag = 2
                log.info('The value of intf_list is : {0}'.format(intf_list))
                
                if intf_list:
                    for intf in intf_list:
                        cfg = '''interface {0}
                                 shutdown'''.format(intf)
                        switch_hdl.configure(cfg)

            with steps.start('Checking the Traffic Stats after removing the feature ngmvpn') as s:
                log.info('Checking the Traffic Stats after removing the feature ngmvpn')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)

            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            

class VXlanMultiSiteL3TRMWithVPCasBGW_Func044(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-044"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-044'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func043_ShuttingFabricLinksOnVPCPrimary(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Shutting Fabric links on VPC Primary...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info('The value of VPC_primary is: {0}'.format(vpc_primary))

            
            with steps.start('Getting the Fabric links from VPC Primary') as s:
                log.info(banner('Getting the Fabric links from VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh nve multisite fabric-links  | xml'
                switch_hdl = vpc_primary['hdl']
                out = switch_hdl.execute(cfg)
                intf_list = []
                for line in out.splitlines():
                    if re.search('if-name',line,re.IGNORECASE):
                        s = BeautifulSoup(line)
                        try:
                            intf = s.find('if-name').string
                            intf_list.append(intf)
                        except Exception:
                            log.error('Interface name could not be generated')
                            flag = 2
                log.info('The value of intf_list is : {0}'.format(intf_list))
                
                if intf_list:
                    for intf in intf_list:
                        cfg = '''interface {0}
                                 shutdown'''.format(intf)
                        switch_hdl.configure(cfg)

            with steps.start('Checking the Traffic Stats after removing the feature ngmvpn') as s:
                log.info('Checking the Traffic Stats after removing the feature ngmvpn')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)

            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            


class VXlanMultiSiteL3TRMWithVPCasBGW_Func045(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-045"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-045'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func045_ShuttingVPCPeerkeepalive(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Flapping VPC Peer-Keepalive on VPC Primary...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
                        
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info('The value of VPC_primary is: {0}'.format(vpc_primary))

            
            with steps.start('Getting the Peer Keepalive link from VPC Primary') as s:
                log.info(banner('Getting the Peer Keepalive link VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh ip arp detail vrf VPC-KEEPALIVE | xml'
                switch_hdl = vpc_primary['hdl']
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                try:
                    intf = s.find('intf-out').string
                except Exception:
                    log.error(banner('Could not find the Interface Corresponding to VPC Keepalive. Failing the test case'))
                    self.failed()
                
            with steps.start('Shutting down the vPC Keepalive on VPC Primary') as s:
                log.info(banner('Shutting down the vPC Keepalive on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = '''interface {0}
                         shutdown'''.format(intf)
                switch_hdl.configure(cfg)
                
            with steps.start('Checking status of Keepalive link') as s:
                cfg = 'show int {0} | xml'.format(intf)
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                try:
                    state = s.find('admin_state').string
                    if re.search('down', state, re.IGNORECASE):
                        log.info('The link is admin shut as expected. state is {0}'.format(state))
                except Exception:
                    log.error(banner('Could not find the admin state of the interface .. Hence failing the test case.'))
                    self.failed()
                    
            log.info('Waiting for 30 seconds before bringing up the Interface')
            countDownTimer(30)
  
            with steps.start('Bringing up the VPC Keepalive link') as s:
                log.info(banner('Bringing up the VPC Keepalive link on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                log.info('Checking the status of Peer-keepalive')
                out = switch_hdl.execute('show vpc | xml')
                s = BeautifulSoup(out)
                try:
                    keepalive_status = s.find('vpc-peer-keepalive-status').string
                    if re.search('not', keepalive_status,re.IGNORECASE):
                        log.info('The Keepalive status is as expected.. .The state is {0}'.format(keepalive_status))
                        
                        cfg = '''interface {0}
                                 no shutdown'''.format(intf)
                        switch_hdl.configure(cfg)
                        countDownTimer(15)
                        
                except Exception:
                    log.error('The VPC KEepalive status is not as expected. Failing the test case w/o proceeding')
                    self.failed()
                    
            with steps.start('Check VPC Keepalive interface status and VPC Status ') as s:
                log.info(banner('Check VPC Keepalive interface status and VPC Status on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                log.info('Checking the Interface status:')
                
                cfg = 'show int {0} | xml'.format(intf)
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                link_flag = 0
                try:
                    state = s.find('admin_state').string
                    if re.search('up', state, re.IGNORECASE):
                        log.info('The link is Up as expected. state is {0}'.format(state))
                        link_flag = 1
                except Exception:
                    log.error(banner('Link is not up as expected. .. Hence failing the test case.'))
                    self.failed()
                    
                if link_flag:
                    log.info(banner('Checking the VPC Keepalive status:'))
                    out = switch_hdl.execute('show vpc | xml')
                    s = BeautifulSoup(out)
                    try:
                        keepalive_status = s.find('vpc-peer-keepalive-status').string
                        if re.search('peer-alive', keepalive_status,re.IGNORECASE):
                            log.info('The Keepalive status is as expected.. .The state is {0}'.format(keepalive_status))
                            log.info(banner('Proceeding with traffic measurement.. Waiting for 100 sec'))

                    except Exception:
                        log.error('The VPC KEepalive status is not as expected. Failing the test case w/o proceeding')
                        self.failed()                

                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            


class VXlanMultiSiteL3TRMWithVPCasBGW_Func046(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-046"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-046'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func046_SplitBrainScenario(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- L3 TRM with VPC as BGW - SplitBrain Scenario...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
                        
            flag = 0
            with steps.start('1. Initial Traffic Stream Stats:') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('2. Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info(banner('The value of VPC_primary is: {0}'.format(vpc_primary)))

            
            with steps.start('3. Getting the Peer Keepalive link') as s:
                log.info(banner('Getting the Peer Keepalive link VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh ip arp detail vrf VPC-KEEPALIVE | xml'
                switch_hdl = vpc_primary['hdl']
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                try:
                    keepalive_intf = s.find('intf-out').string
                    log.info(banner('The value of keepalive_intf is : {0}'.format(keepalive_intf)))
                except Exception:
                    log.error(banner('Could not find the Interface Corresponding to VPC Keepalive. Failing the test case'))
                    self.failed()
                
            with steps.start('4. Getting the Peer-link') as s:
                log.info(banner('Getting the Peer-link from VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh vpc  | xml'
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                try:
                    peerlink_intf = s.find('peerlink-ifindex').string
                    log.info(banner('The value of peerlink_intf is : {0}'.format(peerlink_intf)))
                except Exception:
                    log.error(banner('Could not find the Interface Corresponding to VPC Keepalive. Failing the test case'))
                    self.failed()

            with steps.start('5. Shutting down the vPC Keepalive') as s:
                log.info(banner('Shutting down the vPC Keepalive on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = '''interface {0}
                         shutdown'''.format(keepalive_intf)
                switch_hdl.configure(cfg)
                
            with steps.start('6. Shutting down the vPC PeerLink') as s:
                log.info(banner('Shutting down the vPC PeerLink on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = '''interface {0}
                         shutdown'''.format(peerlink_intf)
                switch_hdl.configure(cfg)

            with steps.start('7. Checking status of Keepalive link') as s:
                cfg = 'show int {0} | xml'.format(keepalive_intf)
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                try:
                    state = s.find('admin_state').string
                    if re.search('down', state, re.IGNORECASE):
                        log.info(banner('The link is admin shut as expected. state is {0}'.format(state)))
                except Exception:
                    log.error(banner('Could not find the admin state of the interface .. Hence failing the test case.'))
                    self.failed()
                    
            with steps.start('8. Checking status of Peerlink') as s:
                cfg = 'show int {0} | xml'.format(peerlink_intf)
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                try:
                    state = s.find('admin_state').string
                    if re.search('down', state, re.IGNORECASE):
                        log.info(banner('The link is admin shut as expected. state is {0}'.format(state)))
                except Exception:
                    log.error(banner('Could not find the admin state of the interface .. Hence failing the test case.'))
                    self.failed()


            log.info('Waiting for 180 seconds before bringing up the Interface')
            countDownTimer(180)
  
            with steps.start('9. Bringing up the VPC Keepalive link') as s:
                log.info(banner('Bringing up the VPC Keepalive link on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                log.info('Checking the status of Peer-keepalive')
                out = switch_hdl.execute('show vpc | xml')
                s = BeautifulSoup(out)
                try:

                    keepalive_status = s.find('vpc-peer-keepalive-status').string
                    peer_link_status = int(s.find('peer-link-port-state').string)

                    if re.search('not', keepalive_status,re.IGNORECASE):
                        log.info('The Keepalive status is as expected.. .The state is {0}'.format(keepalive_status))
                        cfg = '''interface {0}
                                 no shutdown'''.format(keepalive_intf)
                        switch_hdl.configure(cfg)
                        countDownTimer(15)
                        
                    log.info('The value of peer_link_status is : {0} and type is : {1}'.format(peer_link_status, type(peer_link_status)))
                    
                    if not peer_link_status:
                        log.info('The peerlink Status is as expected.. The state is {0}'.format(peer_link_status))
                        cfg = '''interface {0}
                                 no shutdown'''.format(peerlink_intf)
                        switch_hdl.configure(cfg)
                        countDownTimer(15)

                except Exception:
                    log.error('The VPC KEepalive status  / peerlink status is not as expected. Failing the test case w/o proceeding')
                    self.failed()
                    
            with steps.start('10. Check VPC Keepalive interface status and VPC Status ') as s:
                log.info(banner('Check VPC Keepalive interface status and VPC Status on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                log.info('Checking the Interface status:')
                
                cfg = 'show int {0} | xml'.format(keepalive_intf)
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                link_flag = 0
                try:
                    state = s.find('admin_state').string
                    if re.search('up', state, re.IGNORECASE):
                        log.info(banner('The link is Up as expected. state is {0}'.format(state)))
                        link_flag = 1
                except Exception:
                    log.error(banner('Link is not up as expected. .. Hence failing the test case.'))
                    self.failed()
                    
                if link_flag:
                    log.info(banner('Checking the VPC Keepalive status:'))
                    out = switch_hdl.execute('show vpc | xml')
                    s = BeautifulSoup(out)
                    try:
                        keepalive_status = s.find('vpc-peer-keepalive-status').string
                        if re.search('peer-alive', keepalive_status,re.IGNORECASE):
                            log.info(banner('The Keepalive status is as expected.. .The state is {0}'.format(keepalive_status)))
                            log.info(banner('Proceeding with traffic measurement.. Waiting for 100 sec'))

                    except Exception:
                        log.error('The VPC KEepalive status is not as expected. Failing the test case w/o proceeding')
                        self.failed()                


            with steps.start('11. Check VPC Peerlink interface status and VPC Status ') as s:
                log.info(banner('Check VPC Peerlink interface status and VPC Status on VPC Primary {0}'.format(vpc_primary['dut'])))
                
                log.info('Checking the Interface status:')
                
                cfg = 'show int {0} | xml'.format(peerlink_intf)
                out = switch_hdl.execute(cfg)
                s = BeautifulSoup(out)
                link_flag = 0
                try:
                    state = s.find('admin_state').string
                    if re.search('up', state, re.IGNORECASE):
                        log.info(banner('The link is Up as expected. state is {0}'.format(state)))
                        link_flag = 1
                except Exception:
                    log.error(banner('Link is not up as expected. .. Hence failing the test case.'))
                    self.failed()
                    
                if link_flag:
                    log.info(banner('Checking the VPC Peerlink status:'))
                    out = switch_hdl.execute('show vpc | xml')
                    s = BeautifulSoup(out)
                    try:
                        peerlink_status = s.find('peer-link-port-state').string
                        if peerlink_status:
                            log.info(banner('The Keepalive status is as expected.. .The state is {0}'.format(peerlink_status)))
                            log.info(banner('Proceeding with traffic measurement.. Waiting for 180 sec'))

                    except Exception:
                        log.error('The VPC KEepalive status is not as expected. Failing the test case w/o proceeding')
                        self.failed()      
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('12. Checking the Traffic Stats ') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            


class VXlanMultiSiteL3TRMWithVPCasBGW_Func047(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-047"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-047'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func047_sendingIGMPLeave(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        tgn_port_dut_mapping = testscript.parameters['tgn_port_dut_mapping']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- L3 TRM with VPC as BGW - Sending IGMP Leave from L2 Access switch...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            traffic_stream = 'TRF001'
                        
            flag = 0
            with steps.start('1. Initial Traffic Stream Stats:') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()

            with steps.start('2. Stopping Existing Traffic Streams') as s:
                log.info('Stopping Existing Traffic Streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()         
            
            with steps.start('3. Starting Stream {0}'.format(traffic_stream)) as s:
                log.info(banner('The value of traffic_stream dict is : {0}'.format(traffic_stream_dict)))
                stream_handle = traffic_stream_dict[traffic_stream]['traffic_item']
                x = tgn_hdl.traffic_control(action='run', handle = stream_handle, max_wait_timer=60)
                if not x.status:
                    log.error(banner('The Stream {0} could not be started as expected '.format(traffic_stream)))
                    self.failed()

            with steps.start('4. Sending IGMP Leave on L2 Access Switch') as s:
                log.info(banner('Sending IGMP Leave on L2 Access Switch'))
                receiver = tgn_config_dict[TG][traffic_stream]['traffic_config_dict']['receivers']
                for item in node_dict.keys():
                    if re.search('Site', item, re.I):
                        for sub_item in node_dict[item].keys():
                            if re.search('ACCESS', sub_item, re.I):
                                for dut, hdl in node_dict[item][sub_item].items(): pass
                                
                log.info('The Access Switch is {0}'.format(dut))
                              
                for ixia_port in tgn_port_dut_mapping.keys():
                    log.info('The value of ixia_port and tgn_port_dut_mapping[ixia_port] are : {0} and {1}'.format(ixia_port,tgn_port_dut_mapping[ixia_port]))
                    if tgn_port_dut_mapping[ixia_port] == dut:
                        access_port = ixia_port
                          
                log.info('the value of access_port is : {0}'.format(access_port))
                
                for tg_item in tg_interface_hdl_dict.keys():
                    log.info('1. {0} \n'.format(tg_interface_hdl_dict))
                    log.info('2. {0} \n'.format(tg_interface_hdl_dict[tg_item]))
                    log.info('3. {0} \n'.format(tg_interface_hdl_dict[tg_item][traffic_stream]))
                    log.info('4. {0} \n'.format(tg_interface_hdl_dict[tg_item][traffic_stream][access_port]))
                    pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                    for ip in tg_interface_hdl_dict[tg_item][traffic_stream][access_port]:
                        test = pat.match(ip)
                        if test:
                            log.info('5. {0}'.format(tg_interface_hdl_dict[tg_item][traffic_stream][access_port][ip]))
                            session_hdl = tg_interface_hdl_dict[tg_item][traffic_stream][access_port][ip]['session_handle']
                            log.info(banner('Sending IGMP leave from host {0} on dut {1}'.format(ip,dut)))
                            a = tgn_hdl.emulation_igmp_control(mode='leave',group_member_handle=session_hdl)
                            if not a.status:
                                log.error(banner('IGMP Leave Message status is not as expected.'))
                                self.failed()
                    
            with steps.start('5. Measuring Traffic Stats') as s:
                log.info(banner('Measuring Traffic Stats'))
                
                log.info('Waiting for 30 seconds before measuring traffic')
                countDownTimer(30)
                
                log.info('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict))
                
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,traffic_stream_dict,traffic_stream)
                
                log.info(banner('The value of res is : {0}'.format(res)))
                
                log.info('Value of receiver is : {0}'.format(receiver))
                tx_traffic_per_port = res['tx'] / len(receiver)
                log.info('Value of tx_traffic_per_port is : {0}'.format(tx_traffic_per_port))
                receiver.remove(access_port)
                log.info('Value of receiver is : {0}'.format(receiver))
                log.info('Value of len of receiver is : {0}'.format(len(receiver)))
                exp_traffic = tx_traffic_per_port * len(receiver)
                log.info('Value of exp_traffic is : {0}'.format(exp_traffic))
                if abs(exp_traffic - res['rx']) < threshold:
                    log.info('Traffic flow is as expected after sending IGMP Leave. Expected and Actual are {0} and {1}'.format(exp_traffic,res['rx']))
                else:
                    log.error('Traffic Flow is not expcted. Expected and Actual are {0} and {1}'.format(exp_traffic,res['rx']))
                    self.failed()
 
 
            with steps.start('6. Sending IGMP Report on L2 Access Switch') as s:
                log.info(banner('Sending IGMP Report on L2 Access Switch'))
                a = tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=session_hdl)
                if not a.status:
                    log.error(banner('IGMP Leave Message status is not as expected.'))
                    self.failed()                 
 
            with steps.start('7. Measuring Traffic Stats') as s:
                log.info(banner('Measuring Traffic Stats'))
                
                log.info('Waiting for 30 seconds before measuring traffic')
                countDownTimer(30)
                
                log.info('The value of traffic_stream_dict is : {0}'.format(traffic_stream_dict))
                
                res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,traffic_stream_dict,traffic_stream)
                
                log.info(banner('The value of res is : {0}'.format(res)))

                
                if abs(res['tx'] - res['rx']) < threshold:
                    log.info('Traffic flow is as expected after sending IGMP Leave. Expected and Actual are {0} and {1}'.format(exp_traffic,res['rx']))
                    flag = 1
                else:
                    log.error('Traffic Flow is not expcted. Expected and Actual are {0} and {1}'.format(exp_traffic,res['rx']))
                               

            with steps.start('8. Starting All Traffic Streams') as s:
                log.info('Starting all Traffic Streams')
                x = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()         
                                
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('9. Checking the Traffic Stats ') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            

class VXlanMultiSiteL3TRMWithVPCasBGW_ExtSrcIntRcv(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 002"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-048'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_ExtSourceInternalReceivers(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('Stopping all the Existing Traffic Stream') as s:
                log.info('Initial traffic is fine. proceeding with stopping the traffic streams')
                x = tgn_hdl.traffic_control(action='stop',max_wait_timer=60)
                countDownTimer(15)
                log.info('The value of x is " {0}'.format(x))
                if not x.status:
                    log.error('The Streams could not be stopped as expected. The stats are:')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            
            with steps.start('Creating New Traffic Streams - As Per Config Dict') as s:
                
                traffic_items = [x for x in tgn_config_dict[TG].keys() if re.search('TEST', x , re.I)]
                #traffic_items = ['TEST-019']
                log.info('The value of traffic_items are : {0}'.format(traffic_items))
                new_tg_intf_config_dict = {}
                for item in traffic_items:
                    log.info('Creating a new Traffic Stream : {0}'.format(item))
                    traffic_item = tgn_config_dict[TG][item]
                    new_tg_intf_config_dict[item] = traffic_config_obj.generateIGMPTrafficdict(tgn_hdl,traffic_item)
                    log.info(banner('The value of new_tg_intf_config_dict is : {0}'.format(new_tg_intf_config_dict)))
                    log.info(banner('Waiting For 30 seconds before Sending IGMP JOINS .'))
                    countDownTimer(30)
                
            with steps.start('Sending IGMP Joins for the newly Created Traffic Streams') as s:
    
                for stream in new_tg_intf_config_dict.keys():
                    log.info('The value of stream is : {0}'.format(stream))
                    for i in new_tg_intf_config_dict[stream]['destination']:
                        pat = re.compile("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$")
                        for ip in new_tg_intf_config_dict[stream][i]:
                            test=pat.match(ip)
                            if test:
                                a = new_tg_intf_config_dict[stream][i][ip]['session_handle']
                                b = tgn_hdl.emulation_igmp_control(mode='start')
                                c = tgn_hdl.emulation_igmp_control(mode='start', group_member_handle=a)
                                o=tgn_hdl.emulation_igmp_control(mode='join',group_member_handle=a)
                                if not o.status:
                                    log.info('IGMP join is not sent to the group . Pls debug.....')
                                    self.failed()
                                    
            with steps.start('Starting the Traffic Streams {0}'.format(list(new_tg_intf_config_dict.keys()))) as s:
                log.info(banner('Waiting for 30 seconds before starting the traffic:'))
                countDownTimer(30)
                
                for stream in new_tg_intf_config_dict.keys():
                
                    log.info(banner('Starting the New Stream Created for this test ..{0}'.format(stream)))
                    x = tgn_hdl.traffic_control(action='run', handle = new_tg_intf_config_dict[stream]['traffic_item'],max_wait_timer=60)
                    
                    if not x.status:
                        log.error(banner('The Stream {0} could not be started as expected '.format(new_tg_intf_config_dict[stream]['stream_id'])))
                        self.failed()
                
            with steps.start('Measuring Traffic Stats on all streams {0}'.format(list(new_tg_intf_config_dict.keys()))) as s:
                
                pass_stream = []
                fail_stream = []
                for stream in new_tg_intf_config_dict.keys():
                    ixia_stream = new_tg_intf_config_dict[stream]['stream_id']
                    log.info(banner('Waiting for 15 sec before collecting the Traffic Stats:'))
                    countDownTimer(15)
                    res = MyLib.my_config_utils.getTrafficItemStatistics(log,tgn_hdl,ixia_stream,stream)
                    log.info(banner('The Value of res is: {0}'.format(res)))
                    
                    if res['tx'] !=0 and abs(res['tx']-res['rx']) < threshold:
                        log.info('The TRM traffic is as expected.... Proceeding with adding the stream to the Global list.:')
                        pass_stream.append(stream)
                    else:
                        log.error(banner('Traffic on Stream {0} is not as expected. The value of tx and rx is : {0} and {1}'.format(stream, res['tx'],res['rx'])))
                        fail_stream.append(stream)
                    
            with steps.start('Stopping the all Created Stream') as s:
                
                for stream in new_tg_intf_config_dict.keys():
                    ixia_stream_name = new_tg_intf_config_dict[stream]['stream_id']
                    log.info(banner('Stopping the newly created Stream. Ixia Name: {0} Config_file Name is  : {1}'.format(ixia_stream,stream)))
                    x1 = tgn_hdl.traffic_control(action='stop', handle = new_tg_intf_config_dict[stream]['traffic_item'],max_wait_timer=60)
                    log.info(banner('Waiting for 30 seconds before adding / removing the newly created stream {0}'.format(ixia_stream)))
                    countDownTimer(30)
                    
                    if not x1.status:
                        log.error(banner('The Stream {0} could not be stopped as expected '.format(ixia_stream_name)))
                        self.failed()
            
            with steps.start('Adding / Deleting the Newly Created Stream - TRF002 to Global List') as s:
                
                if pass_stream:
                    for stream in pass_stream:
                        log.info(banner('Adding the New stream to the Main Traffic Stream Dict: '))
                        traffic_stream_dict.setdefault(stream,{})
                        trimmed_stream_config_dict = dict((k,new_tg_intf_config_dict[stream][k]) for k in new_tg_intf_config_dict[stream].keys() if k in ['source','destination','stream_id','status','traffic_item'])
                        traffic_stream_dict[stream].update(trimmed_stream_config_dict)
                        log.info('The value of traffic_stream_dict is : {0}'.format(yaml.dump(traffic_stream_dict)))
                        log.info(banner('Adding the New stream to the configured stream list :'))
                        configured_stream.append(stream)
                        log.info(banner('Sending the Modified Traffic_stream_dict and Configured_stream to global Testscript params'))
                        testscript.parameters['configured_stream'] = configured_stream
                        testscript.parameters['traffic_stream_dict'] = traffic_stream_dict
                elif fail_stream:
                    for stream in pass_stream:
                        log.info(banner('The Traffic stats on thie stream {0} is not proper. Refer logs'.format(stream)))
                        log.info('Removing the stream {0}:'.format(stream))
                        y = tgn_hdl.traffic_config(mode='remove',stream_id=ixia_stream)
                        flag = 1
            
            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)     
           
            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_ModifyNVESourceLoopbackIPOnVPCPrimary(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 029"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-049'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_ModifyNVESourceLoopbackIPOnVPCPrimary(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('2. Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info(banner('The value of VPC_primary is: {0}'.format(vpc_primary)))
                
            with steps.start('Changing VPC Primary PIP') as s:
                log.info(banner('Changing VPC Primary PIP'))
                uut = vpc_primary['dut']
                
                args = configdict['scale_config_dict'][uut]['interface']['nve']
                ns  = MyLib.my_config_utils.parseNVEParams(log,args)
                log.info('The value of source_interface is : {0}'.format(ns.source_interface))
                cfg = '''interface nve 1
                         shutdown
                         interface {0}
                         ip add 101.101.101.101/32 tag 11111
                         interface nve 1
                         no shutdown
                         '''.format(ns.source_interface)
                         
                vpc_primary['hdl'].configure(cfg) 
            
            with steps.start('Getting List of Devices to check') as s:
                log.info(banner('Getting List of Devices to check'))
                vtep_dict = {}
                leaf_at_site = 0
                for site in node_dict.keys():
                    if re.search('Site', site, re.I):
                        for dut in node_dict[site].keys():
                            if re.search('VPC_BGW', dut, re.I):
                                vtep_dict.update(node_dict[site][dut])
                                leaf_at_site = site
                            elif re.search(r'^BGW$', dut, re.I):
                                vtep_dict.update(node_dict[site][dut])
                if leaf_at_site:
                    vtep_dict.update(node_dict[leaf_at_site]['LEAF'])
                
                vtep_dict.pop(uut)
                log.info('The value of vtep_dict is {0}'.format(vtep_dict))
                
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
                        
            with steps.start('Checking Nve Peers ') as s:
                log.info(banner('Checking Nve Peers '))
                track_list  = []
                cfg = 'sh nve peers | xml'
                for dut in vtep_dict.keys():
                    out  = vtep_dict[dut].configure(cfg)
                    for line in out.splitlines():
                        if re.search('peer-ip', line, re.I):
                            log.info('The value of line is : {0}'.format(line))
                            s = BeautifulSoup(line)
                            try:
                                peer_ip = s.find('peer-ip').string
                                log.info('The value of peer_ip is : {0} and type is : {1}'.format(peer_ip,type(peer_ip)))
                                if peer_ip == '101.101.101.101':
                                    track_list.append(1)
                            except Exception:
                                log.error('Some exception Occured while finding the peer_ip')
                                
                if len(track_list) == len(list(vtep_dict.keys())):
                    log.info('New Peer-IP is found on all devives')
                else:
                    log.inf('New peer-IP is not found on one / more devices')
                    self.failed()
                    
                           

            with steps.start('Starting All the Stream from the Global list ') as s:      
                log.info(banner('Waiting for 30 seconds before starting all the streams..'))
                countDownTimer(30)

                log.info('Starting all the other streams')
                z = tgn_hdl.traffic_control(action='run',max_wait_timer=60)
                
                if not z:
                    log.error(banner('The Streams could not be started as expected '))
                    self.failed()
                
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    

            with steps.start('Reverting back VPC Primary PIP') as s:
                log.info(banner('Reverting back VPC Primary PIP'))
                uut = vpc_primary['dut']
                
                args = configdict['scale_config_dict'][uut]['interface']['nve']
                ns  = MyLib.my_config_utils.parseNVEParams(log,args)
                log.info('The value of source_interface is : {0}'.format(ns.source_interface))
                cfg = '''interface nve 1
                         shutdown
                         interface {0}
                         ip add 10.10.10.10/32 tag 11111
                         interface nve 1
                         no shutdown
                         '''.format(ns.source_interface)
                         
                vpc_primary['hdl'].configure(cfg)             
           
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
  
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)

            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   

class VXlanMultiSiteL3TRMWithVPCasBGW_Func050(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-050"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-050'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func050_RemoveDCILinkTrackingCliOnVPCPrimary(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Removing DCI link Tracking CLI on VPC Primary...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info('The value of VPC_primary is: {0}'.format(vpc_primary))

            
            with steps.start('Getting the DCI links from VPC Primary') as s:
                log.info(banner('Getting the DCI links from VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh nve multisite dci-links | xml'
                switch_hdl = vpc_primary['hdl']
                out = switch_hdl.execute(cfg)
                intf_list = []
                for line in out.splitlines():
                    if re.search('if-name',line,re.IGNORECASE):
                        s = BeautifulSoup(line)
                        try:
                            intf = s.find('if-name').string
                            intf_list.append(intf)
                        except Exception:
                            log.error('Interface name could not be generated')
                            flag = 2
                log.info('The value of intf_list is : {0}'.format(intf_list))
                
                if intf_list:
                    for intf in intf_list:
                        cfg = '''interface {0}
                                 no evpn multisite dci-tracking'''.format(intf)
                        switch_hdl.configure(cfg)

            with steps.start('Checking the Traffic Stats after removing the Dci-Tracking CLI') as s:
                log.info('Checking the Traffic Stats after removing the Dci-Tracking CLI')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)

            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            

class VXlanMultiSiteL3TRMWithVPCasBGW_Func051(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-051"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-051'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func051_RemoveFabricLinkTrackingCliOnVPCPrimary(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Removing DCI link Tracking CLI on VPC Primary...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    
            with steps.start('Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info('The value of VPC_primary is: {0}'.format(vpc_primary))

            
            with steps.start('Getting the DCI links from VPC Primary') as s:
                log.info(banner('Getting the DCI links from VPC Primary {0}'.format(vpc_primary['dut'])))
                
                cfg = 'sh nve multisite fabric-links | xml'
                switch_hdl = vpc_primary['hdl']
                out = switch_hdl.execute(cfg)
                intf_list = []
                for line in out.splitlines():
                    if re.search('if-name',line,re.IGNORECASE):
                        s = BeautifulSoup(line)
                        try:
                            intf = s.find('if-name').string
                            intf_list.append(intf)
                        except Exception:
                            log.error('Interface name could not be generated')
                            flag = 2
                log.info('The value of intf_list is : {0}'.format(intf_list))
                
                if intf_list:
                    for intf in intf_list:
                        cfg = '''interface {0}
                                 no evpn multisite fabric-tracking'''.format(intf)
                        switch_hdl.configure(cfg)

            with steps.start('Checking the Traffic Stats after removing the Dci-Tracking CLI') as s:
                log.info('Checking the Traffic Stats after removing the Dci-Tracking CLI')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)

            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            


class VXlanMultiSiteL3TRMWithVPCasBGW_Func052(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-052"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-052'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func052_RemoveAddL3VNIonBothVPCSwitches(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Removing/Adding L3 VNI on BOth VPC Switches...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vpc_dict = scale_config_obj.getMultisiteDeviceDict('vpc_vtep')
            
            log.info('The value of VPC_DICT is : {0}'.format(vpc_dict))
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    

            with steps.start('Backing Up Configs - on VPC Switches') as s:
                log.info(banner('Backing Up  configs on duts {0}'.format(list(vpc_dict.keys()))))
                
                for dut in vpc_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Remove L3 VNI from the VPC Switches')  as s:
                log.info(banner('Backing Up  configs on duts {0}'.format(list(vpc_dict.keys()))))
                for dut in vpc_dict:
                    args = configdict['scale_config_dict'][dut]['global']['vlan']
                    ns = MyLib.my_config_utils.parseScaleVlanParms(log,args)
                    for i in range(ns.l3_vni_start, ns.l3_vni_start+ns.no_of_l3_vlans):
                        cfg = '''interface nve1
                                 no member vni {0} associate-vrf'''.format(i)
                        node_dict['all_dut'][dut].configure(cfg)
                        
            log.info(banner('Wait for 120 seconds before collecting the Traffic stats:'))
            countDownTimer(120)
            
            
            with steps.start('Traffic Stats after removing L3 VNI association on VPC Switches') as s:
                log.info('Traffic Stats after removing L3 VNI association on VPC Switches')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)     


            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            

class VXlanMultiSiteL3TRMWithVPCasBGW_Func053(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Func-053"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-053'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_Func053_RemoveAddMultisiteConfig(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        log = testscript.parameters['log'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
                
        log.info(banner('Test:- Removing/Adding Multisite Config - multisite ingress-replication optimized on BOth VPC Switches...'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vpc_dict = scale_config_obj.getMultisiteDeviceDict('vpc_vtep')
            
            log.info('The value of VPC_DICT is : {0}'.format(vpc_dict))
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
                    

            with steps.start('Backing Up Configs - on VPC Switches') as s:
                log.info(banner('Backing Up  configs on duts {0}'.format(list(vpc_dict.keys()))))
                
                for dut in vpc_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'backup')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed()
                        
            with steps.start('Remove Multisite Config from the VPC Switches')  as s:
                log.info(banner('Remove Multisite Config on duts {0}'.format(list(vpc_dict.keys()))))
                for dut in vpc_dict:
                    args = configdict['scale_config_dict'][dut]['global']['vlan']
                    ns = MyLib.my_config_utils.parseScaleVlanParms(log,args)
                    for i in range(ns.l3_vni_start, ns.l3_vni_start+ns.no_of_l3_vlans):
                        cfg = '''interface nve1
                                 member vni {0} associate-vrf
                                 no multisite ingress-replication optimized'''.format(i)
                        node_dict['all_dut'][dut].configure(cfg)
                        
            log.info(banner('Wait for 120 seconds before collecting the Traffic stats:'))
            countDownTimer(120)
            
            
            with steps.start('Traffic Stats after removing L3 VNI association on VPC Switches') as s:
                log.info('Traffic Stats after removing L3 VNI association on VPC Switches')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)     


            with steps.start('Restoring Configs - on BGWs') as s:
                log.info(banner('Restoring  configs on duts {0}'.format(list(bgw_dict.keys()))))
                
                for dut in bgw_dict.keys():
                    log.info(banner('Restoring config on dut : {0}'.format(dut)))
                    res = MyLib.my_utils.configBackUpOrRestoreOrCleanUp(log,node_dict['all_dut'][dut],'restore')
                    if not res:
                        log.error(banner('restore Failed on the dut: {0}'.format(dut)))
                        self.failed
                        
            log.info(banner('Waiting for 180 seconds before measuring the Traffic Stats: '))
            countDownTimer(180)
            
            with steps.start('Checking the Traffic Stats After the Trigger on configured Traffic Stream') as s:
                log.info('Checking the Traffic Stats After the Trigger on configured Traffic Stream {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Traffic did not recover after the Trigger - Remove NGMVPN on DUTS.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    res2 = traffic_obj.getAllRawStreamStatistics(tgn_hdl)
                    self.failed()            

class VXlanMultiSiteL3TRMWithVPCasBGW_NVESourceLoopbackFlapOnVPCPrimary(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 034"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-054'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_NVESourceLoopbackFlapOnVPCPrimary(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('2. Getting VPC Primary handle') as s:
                log.info(banner('Getting VPC Primary handle'))
                vpc_dict = {}
                
                for dev in node_dict.keys():
                    if re.search('Site',dev, re.IGNORECASE):
                        for dut in node_dict[dev].keys():
                            if re.search('VPC', dut):
                                vpc_dict.update(node_dict[dev][dut])
                log.info(banner('The value of VPC_dict is: {0}'.format(vpc_dict)))
                
                vpc_primary = MyLib.my_utils.returnVPCSwitchHandle(log,vpc_dict)['primary']
                log.info(banner('The value of VPC_primary is: {0}'.format(vpc_primary)))
                
            with steps.start('Shut Down PIP Loopback on VPC Primary') as s:
                log.info(banner('ShutDown PIP Loopback on VPC Primary'))
                uut = vpc_primary['dut']
                
                args = configdict['scale_config_dict'][uut]['interface']['nve']
                ns  = MyLib.my_config_utils.parseNVEParams(log,args)
                log.info('The value of source_interface is : {0}'.format(ns.source_interface))
                cfg = '''interface {0}
                         shutdown
                         '''.format(ns.source_interface)
                         
                vpc_primary['hdl'].configure(cfg) 
                
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
                        
            with steps.start('Getting List of Devices to check') as s:
                log.info(banner('Getting List of Devices to check'))
                vtep_dict = {}
                leaf_at_site = 0
                for site in node_dict.keys():
                    if re.search('Site', site, re.I):
                        for dut in node_dict[site].keys():
                            if re.search('VPC_BGW', dut, re.I):
                                vtep_dict.update(node_dict[site][dut])
                                leaf_at_site = site
                            elif re.search(r'^BGW$', dut, re.I):
                                vtep_dict.update(node_dict[site][dut])
                if leaf_at_site:
                    vtep_dict.update(node_dict[leaf_at_site]['LEAF'])
                
                vtep_dict.pop(uut)
                log.info('The value of vtep_dict is {0}'.format(vtep_dict))

            with steps.start('Checking Nve Peers ') as s:
                log.info(banner('Checking Nve Peers '))
                count  = 0
                cfg = 'sh nve peers | xml'
                for dut in vtep_dict.keys():
                    out  = vtep_dict[dut].configure(cfg)
                    for line in out.splitlines():
                        if re.search('peer-ip', line, re.I):
                            log.info('The value of line is : {0}'.format(line))
                            s = BeautifulSoup(line)
                            try:
                                peer_ip = s.find('peer-ip').string
                                log.info('The value of peer_ip is : {0} and type is : {1}'.format(peer_ip,type(peer_ip)))
                                if peer_ip == '10.10.10.10':
                                    count += 1
                            except Exception:
                                log.error('Some exception Occured while finding the peer_ip')
                                
                if not count:
                    log.info('Nve Loopback is destroyed on all other VTEPs as expected.')
                else:
                    log.inf('New is still discovered after Loopback shut on one / more devices')
                    self.failed()
        

            with steps.start('Traffic Stats after removing L3 VNI association on VPC Switches') as s:
                log.info('Traffic Stats after removing L3 VNI association on VPC Switches')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)     
                    

            with steps.start('Unflapping the Loopback Interface on VPC Primary') as s:
                log.info(banner('Unflapping the Loopback Interface on VPC Primary'))
                uut = vpc_primary['dut']
                
                args = configdict['scale_config_dict'][uut]['interface']['nve']
                ns  = MyLib.my_config_utils.parseNVEParams(log,args)
                log.info('The value of source_interface is : {0}'.format(ns.source_interface))
                cfg = '''interface {0}
                         no shutdown
                         '''.format(ns.source_interface)
                         
                vpc_primary['hdl'].configure(cfg)             
           
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
  
            with steps.start('Checking Nve Peers ') as s:
                log.info(banner('Checking Nve Peers '))
                count  = 0
                cfg = 'sh nve peers | xml'
                for dut in vtep_dict.keys():
                    out  = vtep_dict[dut].configure(cfg)
                    for line in out.splitlines():
                        if re.search('peer-ip', line, re.I):
                            log.info('The value of line is : {0}'.format(line))
                            s = BeautifulSoup(line)
                            try:
                                peer_ip = s.find('peer-ip').string
                                log.info('The value of peer_ip is : {0} and type is : {1}'.format(peer_ip,type(peer_ip)))
                                if peer_ip == '10.10.10.10':
                                    count += 1
                            except Exception:
                                log.error('Some exception Occured while finding the peer_ip')
                                
                if len(list(vtep_dict.keys())) ==  count:
                    log.info('Nve Loopback is seen on all other VTEPs as expected.')
                else:
                    log.inf('Nve Peer is still discovered after Loopback shut on one / more devices')
                    self.failed()

            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)

            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_VlanShutUnshutOnVPCSwitches(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 055"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-055'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_VlanShutUnshutOnVPCSwitches(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vpc_dict = scale_config_obj.getMultisiteDeviceDict('vpc_vtep')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('ShutDown Vlans on VPC Switches') as s:
                log.info('ShutDown Vlans on VPC Switches {0}'.format(list(vpc_dict.keys())))
                for dut in vpc_dict.keys():
                    args = configdict['scale_config_dict'][dut]['global']['vlan']
                    ns = MyLib.my_config_utils.parseScaleVlanParms(log,args)
                    for i in range(ns.l2_vlan_start,ns.l2_vlan_start + ns.no_of_l2_vlans):
                        cfg = '''vlan {0}
                                 shutdown'''.format(i)
                        node_dict['all_dut'][dut].configure(cfg)
                    
                
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
                                

            with steps.start('Traffic Stats after removing L3 VNI association on VPC Switches') as s:
                log.info('Traffic Stats after removing L3 VNI association on VPC Switches')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)     
                    
            with steps.start('UnShutDown Vlans on VPC Switches') as s:
                log.info('ShutDown Vlans on VPC Switches {0}'.format(list(vpc_dict.keys())))
                for dut in vpc_dict.keys():
                    args = configdict['scale_config_dict'][dut]['global']['vlan']
                    ns = MyLib.my_config_utils.parseScaleVlanParms(log,args)
                    for i in range(ns.l2_vlan_start,ns.l2_vlan_start + ns.no_of_l2_vlans):
                        cfg = '''vlan {0}
                                 no shutdown'''.format(i)
                        node_dict['all_dut'][dut].configure(cfg)       
           
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
  
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)

            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   


class VXlanMultiSiteL3TRMWithVPCasBGW_VRFLiteLinkFlapOnVPCSwitches(aetest.Testcase):

    """ Vxlan MS L3TRM -VPC as BGW - Int RP - Traffic Test 056"""

    uid = 'VXLAN-MS-L3-TRM-VPC-BGW-FUNC-056'

    @aetest.test
    def VxlanMSL3TRMVPCasBGW_VRFLiteLinkFlapOnVPCSwitches(self,log,testscript,testbed, steps):
        tg_interface_hdl_dict = testscript.parameters['tg_interface_hdl_dict'] 
        traffic_stream_dict = testscript.parameters['traffic_stream_dict'] 
        port_handle_dict = testscript.parameters['port_handle_dict']
        TGList_config_file = testscript.parameters['TGList']
        configdict = testscript.parameters['configdict'] 
        tgn_config_dict = configdict['TG']
        threshold = testscript.parameters['traffic_threshold']
        node_dict = testscript.parameters['node_dict']
        alias_intf_mapping = testscript.parameters['alias_intf_mapping']
        configured_stream = testscript.parameters['configured_stream']
        traffic_obj = testscript.parameters['traffic_obj'] 
        traffic_config_obj = testscript.parameters['traffic_config_obj']
        scale_config_obj = testscript.parameters['scale_config_obj']
        trigger_obj = testscript.parameters['trigger_obj'] 
        
        res = [node_dict['all_dut'][dut].execute('terminal session-timeout 0') for dut in node_dict['all_dut'] if re.search('uut', dut)]
        
        log.info(banner('VRFLite Link Flap On VPCSwitches'))
        
        for TG in tgn_config_dict.keys():
            log.info('The value of TG is = %r', TG)
            tgn_hdl = testscript.parameters['testbed_obj'].devices[TG]
            
            flag = 0
            
            vtep_dict = scale_config_obj.getMultisiteDeviceDict('all_vtep')
            bgw_dict = scale_config_obj.getMultisiteDeviceDict('bgw')
            vpc_dict = scale_config_obj.getMultisiteDeviceDict('vpc_vtep')
            
            with steps.start('Checking the Traffic Stats of Initially configured Traffic Stream') as s:
                log.info('The Initially configured streams are {0}'.format(configured_stream))
                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                if not out:
                    log.error('The Initial Traffic stream stats is not as expected.')
                    res1 = traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    self.failed()
            
            with steps.start('VRF Lite Link Shut on VPC Switches') as s:
                log.info('VRF lite Link shut on VPC Switches {0}'.format(list(vpc_dict.keys())))
                
                for dut in vpc_dict.keys():
                    try:
                        intf = list(configdict['scale_config_dict'][dut]['interface']['sub_if'].keys())[0]
                                            
                        if re.search('uut', intf,re.I):
                            intf = alias_intf_mapping[dut][intf]
                            
                        cfg = '''interface {0}
                                 shutdown'''.format(intf)
                        node_dict['all_dut'][dut].configure(cfg)
                    except Exception:
                        log.info('Sub-interface config does not exist on config_dict for dut {0}'.format(dut))


                    
                
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
                                

            with steps.start('Traffic Stats after removing L3 VNI association on VPC Switches') as s:
                log.info('Traffic Stats after removing L3 VNI association on VPC Switches')
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                traffic_obj.getAllRawStreamStatistics(tgn_hdl)     
                    
            with steps.start('VRF Lite Link unshut on VPC Switches') as s:
                log.info('VRF lite Link unshut on VPC Switches {0}'.format(list(vpc_dict.keys())))
                
                for dut in vpc_dict.keys():
                    try:
                        intf = list(configdict['scale_config_dict'][dut]['interface']['sub_if'].keys())[0]
                        if re.search('uut', intf,re.I):
                            intf = alias_intf_mapping[dut][intf]
                            
                        cfg = '''interface {0}
                                 no shutdown'''.format(intf)
                        node_dict['all_dut'][dut].configure(cfg) 
                    except Exception:
                        log.info('Sub-interface config does not exist on config_dict for dut {0}'.format(dut))

           
            log.info(banner('Waiting for 120 seconds before checking the Nve peers'))
            countDownTimer(120)
  
            with steps.start('Measuring Traffic Stats of all stream at end of test') as s:
                
                log.info(banner('Waiting for 30 seconds for the traffic to Converge'))
                countDownTimer(30)

                out = trigger_obj.checkAllStreamStats(tgn_hdl)
                traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                
                if not out:
                    log.error(banner('Traffic  Stream stats is not as expected after the end of the test .. Traffic status in Table format is: .. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    flag = 1

                else:
                    log.info(banner('Cummulative Traffic flow is as expected.. '))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)

            with steps.start('Global verdict of this test case - after adding the new stream') as s:         
                if flag:
                    log.info(banner('Traffic flow is not as expected. Breakup is as follows:'))
                    traffic_obj.getAllBoundStreamStatistics(tgn_hdl)
                    countDownTimer(300)
                    self.failed()   



class CommonCleanup(aetest.Testcase):
    
    """ VLan State Change on Both the DUTS """

    uid = 'VXLAN-L3-TRM-FUNC-001'

    @aetest.subsection
    def checkTopo(self):
        pass
        
        
class CommonCleanup(aetest.CommonCleanup):

    @aetest.subsection
    def disconnect(self):
        pass

